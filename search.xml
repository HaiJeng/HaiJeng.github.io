<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[左偏堆]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B7%A6%E5%81%8F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[一.序强烈安利&lt;数据结构与算法分析-c语言描述&gt;这本书!!!更好的讲解可阅读该书.或者看这位大佬的博客%% 二.用处这个左式堆啊~直接当作可以合并的二叉堆来理解,这是再最好不过的了,其他和堆没啥区别. 三.基本概念 零路径长（$null\ pathength$）$Npl(X)$：结点$X$到一个没有两个儿子的结点的最短路径的长度。这里我们定义没有两个儿子的结点的$Npl(x)=1$；$Npl(NULL) = 0$。 左堆和堆一样，也具有结构性质和堆序性质。左堆的结构性质是指：对于堆中的每一个结点$X$，它的左儿子的零路径长要不小于其右儿子的零路径长。堆序信息与堆的一样，即：最小的结点应该是根节点，鉴于我们希望子树也是堆，那么每个子树的根节点也应该是最小的这一性质必然会导致左堆是一个极其不平衡的树。书上原话 四.合并每次合并都从右子树开始合并.这图我也看不大懂,大致理解就好了.反正代码写出来,感觉和图的方法没大关系 五.代码实现(一).结构12345typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root; 1234567891011121314151617181920### (二).合并```cppnd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆,小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) //保证性质不变 swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; //合并后,根节点的npl距离取右儿子的距离+1 &#125; return p;&#125; (三).插入插入这个命令,可以理解为,一个单个数的堆,与大堆合并.即把要插入的数当作一个堆,与要插入的堆合并即可. 1234567891011nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; (四).删除删除堆首的值,可以理解为,将堆根节点的左右儿子分成两个堆,然后再合并成一个新的堆. 12345678910nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125; (五).样例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson),close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆的小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; 例题(hdu 1512) Monkey Kinghttp://acm.hdu.edu.cn/showproblem.php?pid=1512 Problem DescriptionOnce in a forest, there lived $N$ aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can’t avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, $10$ will be reduced to $5$ and $5$ will be reduced to $2$).And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel. InputThere are several test cases, and each case consists of two parts.First part: The first line contains an integer $N$($N\leq100000$), which indicates the number of monkeys. And then $N$ lines follows. There is one number on each line, indicating the strongness value of ith monkey($\leq32768$).Second part: The first line contains an integer $M$($M\leq100000$), which indicates there are $M$ conflicts happened. And then $M$ lines follows, each line of which contains two integers $x$ and $y$, indicating that there is a conflict between the $X_{th}$ monkey and $Y_{th}$. OutputFor each of the conflict, output $-1$ if the two monkeys know each other, otherwise output the strongness value of the strongest monkey in all friends of them after the duel. Sample Input520161010452 33 43 54 51 5Sample Output855-110AuthorJIANG, YanyanSourceZOJ 3rd Anniversary ContestRecommendlinle 解析 一开始有$n$只孤独的猴子，然后他们要打$m$次架，每次打架呢，都会拉上自己朋友最牛叉的出来跟别人打，打完之后战斗力就会减半，每次打完架就会成为朋友（正所谓不打不相识o(∩_∩)o）。问每次打完架之后那俩猴子最牛叉的朋友战斗力还有多少，若朋友打架就输出$-1$. 并查集+可并堆每次猴子和猴子打架做朋友,就并在一起.每次要打架就查一下是不是在一起的朋友,不是就打架,是就输出$-1$. 在经历了无数次$re$和$mle$后,我把$close$函数删了==,遗留的指针遗留就遗留吧.就$ac$了…….$wtf$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;cstdio&gt;#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;struct vec &#123; int d,fa; nd p; vec() &#123; d = 0, p = NULL; &#125;&#125;a[101000];void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson); close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆的小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125;int top(nd p)&#123; return p-&gt;d;&#125;int ffa(int x)&#123; if (x == a[x].fa) return x; return a[x].fa=ffa(a[x].fa);&#125;int read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int main()&#123; int n, m; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; a[i].d=read(); a[i].fa = i; a[i].p = insert(a[i].p, a[i].d); &#125; m=read(); for (int i = 1; i &lt;= m; i++) &#123; int x, y, fx, fy; x=read(),y=read(); fx = ffa(x), fy = ffa(y); if (fx != fy) &#123; a[fy].fa = fx; int num1 = top(a[fx].p) / 2, num2 = top(a[fy].p) / 2; a[fx].p = pop(a[fx].p); a[fy].p = pop(a[fy].p); a[fx].p = a[fy].p = merge(a[fx].p, a[fy].p); a[fx].p = a[fy].p = insert(a[fx].p, num1); a[fx].p = a[fy].p = insert(a[fx].p, num2); cout &lt;&lt; top(a[fx].p) &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; for (int i = 1; i &lt;= n; i++) a[i].p = NULL; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>左偏堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F08%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[引例洛谷P3865$RMQ$的中文翻译为:静态区间最值查询.英文我不知道所以不写给你$n$个数,$m$次查询,查询的内容为区间$[l,r]$中的最大值.$RMQ$有解法蛮多的,$st$表,线段树,树状数组,划分树都可以做.$st$表的复杂度为预处理$O(n*{\log_2} n)$+查询$O(m)$而线段树则需要预处理$O(n*{\log_2} n)$+查询$O(m*{\log_2} n)$树状数组没学,不清楚线段树可以看我之前的博客. 定义这个算法就是基于$DP$和位运算符，我们用$dp[i][j]$表示从第 $i$ 位开始，到第 $i + 2^j -1$ 位的最大值或者最小值。 那么我求$dp[i][j]$的时候可以把它分成两部分，第一部分从 $i$ 到 $i + 2 ^{(j-1)} - 1$ ，第二部分从 $i + 2 ^{(j-1)}$ 到$i + 2^j- 1$,那么可以得到$$dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1])$$当$j=0$时,求的是长度为1的区间的最小值,$j=1$时,求的是长度为2的区间最小值$j=2$时,求的是长度为4的区间最小值以此类推,故可在$O(n\log_2 n)$的复杂度处理完.如图所示查询的话,只需要反过来就阔以了. 完整代码这里mm[i] = mm[i - 1] +((i&(i - 1)) == 0);123456789101112131415161718192021222324252627282930313233343536373839```cppconst int MAXN = 1e5 + 10;int dp[MAXN][31],a[MAXN],mm[MAXN];void initRMQ(int n)&#123; mm[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; mm[i] = mm[i - 1] +((i&amp;(i - 1)) == 0); dp[i][0] = a[i]; &#125; for (int j = 1; j &lt;= mm[n]; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int x, int y)&#123; int k = mm[y - x + 1]; return max(dp[x][k], dp[y - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m;//scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initRMQ(n); while (m--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; rmq(x, y) &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; 二维st表暂存https://blog.csdn.net/VictoryCzt/article/details/83684082 约束RMQhttps://www.cnblogs.com/ghostcai/p/9280720.htmlhttps://blog.csdn.net/VictoryCzt/article/details/83348579 练习题目洛谷P2251裸的$RMQ$问题洛谷P3865$st$表模板题目洛谷P2048$st$表+前缀和+贪心+堆优化]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2F2019%2F08%2F09%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[不得不说&emsp;&emsp;本来标题想写分治,但是想了想发现自己分治能说的不多,主要的内容就是$CDQ$分治.便取了这个标题. 预备知识 关于什么是分治&emsp;&emsp;分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。在计算机科学中，分治法就是运用分治思想的一种很重要的算法。分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。 一般步骤 划分步：把输入的问题划分为$k$个子问题，并尽量使这$k$个子问题的规模大致相同。 治理步：当问题的规模大于某个预定的阈值$n_0$时，治理步由$k$个递归调用组成。 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。 时间复杂度 直观估计 分治由以上三部分构成，整体时间复杂度则由这三部分的时间复杂度之和构成. 由于递归，最终的子问题变得极为简单，以至于其时间复杂度在整个分治策略上的比重微乎其微. 经典例题 归并排序,快排等 求逆序对等经典例题$Atcoder\ A\ -\ Colorful\ Subsequence$https://atcoder.jp/contests/agc031/tasks/agc031_a 题目简析: 问多少种子序列,子序列中的字母不同. 列如$baa$,包括:$b,a,a,$两个不同位置$a$的$ba$,总计$5$个,$baa$排除是因为$a$是重复的. 解法 先将每个字母的个数统计下来,然后分治计算,一个字母的时候,答案是该字母出现的次数. 只有两个字母的时候,如$ab$,包含的排列有$a,b,ab$,相当于’$a$的个数,$b$的个数,$a$和$b$组合个数’的加和,而$a$和$b$组合个数,则是$a$的个数$\times b$的个数 同理可得,$ans$即为$ansL+ansR+ansL\times ansR$.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e5 + 10;const int MOD = 1e9 + 7;typedef long long ll;char s[INF];int num[27];string s1="0";ll solve(int L, int R)&#123; if (L == R) return num[s1[L] - 'a']; int mid = (L + R) &gt;&gt; 1; ll nL = solve(L, mid), nR = solve(mid + 1, R); return (nL%MOD + nR%MOD + (nL%MOD * nR%MOD)%MOD)%MOD;&#125;int main()&#123; int n; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (!num[s[i] - 'a']) s1 = s1 + s[i]; num[s[i] - 'a']++; &#125; cout &lt;&lt; solve(1, s1.length() - 1)&lt;&lt;endl; return 0;&#125; CDQ分治前面絮絮叨叨的简单介绍了下分治,想必各位对分治有了一定认识.下面是重头戏:$CDQ$分治.这个算法,是由陈丹琦大牛在论文中提出的%%%.首先,我们需要知道一些事情: 优势在于可以顶替复杂的高级数据结构，而且常数比较小 缺点在于必须离线操作 用来解决什么问题呢? 首先,分治问题2333 分治后的答案,不仅单单考虑子问题${L,mid}$和子问题${mid+1,R}$. 还需要考虑子问题${L,mid}$对子问题${mid+1,R}$的影响$/$联系产生的答案. 列如: 二维偏序问题 给定一个二元组${x,y}$,要求问有多少对${x_i,y_i},{x_j,y_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$ 解法为: 先将二元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的二元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得左区间相对于右区间的点的个数. 三维偏序问题 和二维偏序问题类似,但有一定不同 给定一个三元组${x,y,z}$,要求问有多少对${x_i,y_i,z_i},{x_j,y_j,z_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$&&$z_i&gt;z_j$ 解法为: 先将三元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的三元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得满足$y$条件的点. 再建立一个权值树状数组$/$线段树,再将上面符合的${x,y,z}$对应中满足不等式的$z$的点求出. 例题 BZOJ3262: 陌上花开 BZOJ4237: 稻草人或者这个LibreOJ稻草人 伪代码123456789101112void cdq(int left,int right)&#123; if(left==right) return ; int mid=(left+right)&gt;&gt;1; cdq(left,mid),cdq(mid+1,right); sort(a+l,a+mid+1,cmp); sort(a+mid+1,a+right+1,cmp); /** *处理左区间对于右区间影响的代码 */]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[我好羡慕会用java的人为什么要用到高精度呢?我们知道,$int$的范围是$\pm2^{31}-1$,$long,long$的范围是$\pm2^{63}-1$,那么当我们想要表示更往上的数字,应该怎么做?虽然,我已经学会了 我上小学很计算机的一种方式,将每一位放在一个$a[i]$中,这样,一个数字就变成一个数组,对数字的四则运算,也就变成了对数组的操作. 高精度加法问:$1234+5678$答案是多少?答:$我不知道$咳咳,按照小学的教法,我们知道,要列个竖式,对齐数位,一位一位相加,满$10$进$1$.于是:$$\quad\quad1234\\underline{,\quad+5678}\\quad\quad6912$$分析一下计算过程,我们发现,当我们用数组$a$,数组$b$,分别存下$1234$和$5678$后,从数组的最后一位开始$for$循环,用数组$S$保存和,$temp$保存进位可以得到再将这个过程转化为代码,高精度加法就写出来了 123456789101112131415BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125; 高精度减法众所周知,减法是加法的逆运算.所以,我们将加法的过程反过来就是减法. 从头往后处理 $temp$保存向后一位的借位 处理负数的偷懒方式为,将第一位前加个符号,输出的时候就加上了符号1234567891011121314151617181920212223242526272829303132333435363738BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度乘法我们现在还是小学提问:$1234\times5678$答案是多少我们来列个式杂$\quad\quad\quad1234$$;\quad\underline{\quad\times5678}$$\quad\quad\quad9872$$\quad\quad8638$$\quad;;7404$$\underline{\quad6170\quad;}$$\quad7006652$那么分析一下这个过程.设一个空的$s$数组,$b$数组的个位$\times a$从个位开始和$s$的每一位相加,$b$数组的十位$\times a$从十位开始和$s$的每一位相加,以此类推,一直到$b$的千位计算结束,得到的便是答案 1234567891011121314151617181920212223242526BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 高精度除法好的,我们现在还是小学生 高精度除低精度好的,首先,除法是乘法的逆元,所以我们~倒着做回去 从头往后处理 $down$储存余数 当余数+该位小于低精度的数时,我们向后延续一位12345678910111213BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret, len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#define MAXN 9999 //MAXN控制每个a[i]内大小#define DLEN 4 //DLEN控制a[i]中有几位#define MAXSIZE 5010 //控制数字位数class BigNum &#123;private: int a[MAXSIZE]; int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator +(const BigNum &amp;)const; BigNum operator -(const BigNum &amp;)const; BigNum operator *(const BigNum &amp;)const; BigNum operator /(const int &amp;)const; BigNum operator ^(const int &amp;)const; long long operator %(const long long &amp;)const; bool operator &gt;(const BigNum&amp;i_T)const; bool operator &gt;(const int &amp;i_T)const; void print();&#125;;//int-&gt;BigNumBigNum::BigNum(const int i_b)&#123; int c, d = i_b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1))*(MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;//char-&gt;BigNumBigNum::BigNum(const char *i_s)&#123; int t, k, index, L; memset(a, 0, sizeof(a)); L = strlen(i_s); len = L / DLEN; if (L%DLEN) len++; index = 0; for (int i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + i_s[j] - '0'; a[index++] = t; &#125;&#125;//copyBigNum::BigNum(const BigNum &amp;i_T) :len(i_T.len)&#123; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_T.a[i];&#125;//BigNum复制BigNumBigNum&amp;BigNum::operator=(const BigNum&amp;i_n)&#123; len = i_n.len; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_n.a[i]; return *this;&#125;//cin&gt;&gt; BigNumistream&amp; operator &gt;&gt;(istream &amp;in, BigNum &amp;i_b)&#123; char ch[MAXSIZE * DLEN]; in &gt;&gt; ch; int L = strlen(ch), count = 0, sum = 0; for (int i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; DLEN &amp;&amp; i &gt;= 0; j++, i--, t *= 10) sum += (ch[i] - '0')*t; i_b.a[count] = sum; count++; &#125; i_b.len = count++; return in;&#125;//cout&lt;&lt;BigNumostream&amp; operator &lt;&lt;(ostream&amp; out, BigNum&amp; i_b)&#123; cout &lt;&lt; i_b.a[i_b.len - 1]; for (int i = i_b.len - 2; i &gt;= 0; i--) printf("%04d", i_b.a[i]); return out;&#125;//高精度除低精度BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;//高精度%低精度long long BigNum::operator%(const long long &amp;i_b)const&#123; long long d = 0; for (int i = len - 1; i &gt;= 0; i--) d = ((d*MAXN + 1) % i_b + a[i] * 1LL) % i_b; return d;&#125;//高精度求幂BigNum BigNum::operator^(const int &amp;n)const&#123; int i; BigNum t, ret(1); if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;//高精与高精比较bool BigNum::operator&gt;(const BigNum &amp;i_T)const&#123; int ln; if (len &gt; i_T.len) return true; else if (len &lt; i_T.len) return false; else &#123; ln = len - 1; while (a[ln] == i_T.a[ln] &amp;&amp; ln &gt; 0) ln--; return (ln &gt;= 0 &amp;&amp; a[ln] &gt; i_T.a[ln]); &#125;&#125;//高精与低精度bool BigNum::operator&gt;(const int &amp;i_T)const&#123; BigNum b(i_T); return *this &gt; b;&#125;//打印高精度void BigNum::print()&#123; printf("%d", a[len - 1]); for (int i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;//高精度相乘BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度除高精度好的,我们现在不做小学生了考虑用除低精度的做法,太麻烦了.那么我们再回到那句话,除法是乘法的逆元.考虑:$a/b=c\ldots d$,那么也就意味着$d+c\times b=a$,那么只要找到一个数$c$,使得$c\times b+d=a$即可于是,问题变为了加法和乘法的组合.对于加法,一个个试的话,必定超时.考虑两种方式:二分法和牛顿法.高精度用不了牛顿法况且我也不会,使用二分法,复杂度为$O(logN)$.对于乘法 普通的模拟$O(N^2)$. 分治乘法：最简单的是$Karatsuba$乘法，一般化以后有$Toom-Cook$乘法； 快速傅里叶变换$FFT$：（为了避免精度问题，可以改用快速数论变换$FNTT$），时间复杂度$O(N lgN lglgN)$。参照$Schönhage–Strassen algorithm$和$Fürer’s algorithm$ 中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行 两者结合即可解决问题.$fft$的话可以看一下$hdu1402$$java$$AC$后,$c/c++$还在敲代码.]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块1-9(未完)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%88%86%E5%9D%971-9-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[序感谢@hzwer大佬出的练习题题目链接LOJ本蒟过弱,实在不知道怎么压缩代码量了-&gt;_-&gt; 数列分块入门 1给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，单点查值。 将$n$个数,按照每$\sqrt{n}$为一个块标记. 123belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; 每次对所给的$[l,r]$区间进行讨论,分为”单蹦”和”块”,对于不满块的数,直接暴力修改.对于满足块的数,直接打一个标记,当访问的时候再进行修改即可,类似于线段树$lazy$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/const int MAXN = 1e5 + 10;int belong[MAXN], tot = 1, a[MAXN], n, cnt;struct block &#123; int lazy; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // cin &gt;&gt; a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); // cin &gt;&gt; opt&gt;&gt; l &gt;&gt; r &gt;&gt; c; if (opt) cout &lt;&lt; p[belong[r]].lazy + a[r] &lt;&lt; endl; else &#123; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) a[j] += c; &#125; &#125; return 0;&#125; 数列分块入门 2给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的元素个数。 区间加法仿照$1$即可.对于每一个块内的数据,为了方便查询,我们分便对每一个块内的数据进行排序.对于不满足块的数据,我们暴力处理,再将这个块内的数据排序,满足块的区间,我们依然是打标记即可.查询的时候,二分查找即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN],b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for(int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[i]=a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = 0; c *= c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans += lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; if (p[belong[r]].end == r) ans += lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans += lowerbound(b + p[j].start, p[j].end - p[j].start + 1, c, p[j].lazy); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans += lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 3给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的前驱（比其小的最大元素）。 和$2$类似. 出题人的想法:可以在块内维护其它结构使其更具有拓展性，比如放一个 set ，这样如果还有插入、删除元素的操作，会更加的方便。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN], b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; //cin &gt;&gt; a[i];//scanf("%d", &amp;a[i]); belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = -1; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) &#123; int t = lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[p[belong[l]].start+t-1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); if (p[belong[r]].end == r) &#123; int t = lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); if (t) ans = max(ans, b[p[belong[r]].start + t - 1] + p[belong[r]].lazy); &#125; else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); for (int j = belong[l] + 1; j &lt; belong[r]; j++) &#123; int t = lowerbound(b + p[j].start, p[j].end- p[j].start + 1, c, p[j].lazy); if (t) ans = max(ans, b[p[j].start + t - 1] + p[j].lazy); &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) &#123; int t = lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[l + t - 1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 4给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，区间求和。 求和预处理一下就阔以了,打标记的时候是长度$*$加法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef long long ll;const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/ll cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; ll lazy; ll sum; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; //scanf("%d", &amp;a[i]); belong[i] = tot; p[tot].sum += a[i]; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; ll c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; ll ans = 0; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= p[belong[l]].end; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); if (p[belong[r]].end == r) ans = (ans + (p[belong[r]].lazy*(p[belong[r]].end - p[belong[r]].start + 1)) % (c + 1) + p[belong[r]].sum % (c + 1)) % (c + 1); else for (int j = p[belong[r]].start; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans = (ans + (p[j].lazy*(p[j].end - p[j].start + 1)) % (c + 1) + p[j].sum % (c + 1)) % (c + 1); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) &#123; p[belong[r]].sum += c; a[j] += c; &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; &#125; return 0;&#125; 数列分块入门 5给出一个长为 $n$ 的数列 ，以及 $n$ 个操作，操作涉及区间开方，区间求和。 这个题目其实比较搞人==对于一个数,其属于${-2^{31},2^{31}-1}$,最多开方不超过$4$次.还是和之前一样,单个暴力,整块标记.对于一个块,如果开方次数超过$4$次,或者整个块只有$1$或$0$,我们就可以认为不需要对其处理了,只记下和即可.自己代码实现的时候,注意细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200typedef long long ll;const int MAXN = 1e5 + 10;/* belong[x]:元素x所在的块的编号，样例代码中为bl[x]; start[x]:编号为x的块的最左边的点，样例代码中为st[x]; end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; */int cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; int lazy; ll sum; int start, end; bool f; block() &#123; lazy = start = end = sum = 0; f = false;&#125;&#125; p[MAXN];void built() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; // scanf("%d", &amp;a[i]); belong[i] = tot; if (a[i] != 0) p[tot].sum++; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125;&#125;void print(int l, int r) &#123; ll ans = 0, c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; if (p[belong[r]].end == r) if (p[belong[r]].lazy &gt; 4 || p[belong[r]].f) ans += p[belong[r]].sum; else &#123; p[belong[r]].f = true; for (int i = p[belong[r]].start; i &lt;= p[belong[r]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[r]].f = false; ans += x; &#125; &#125; else for (int i = p[belong[r]].start; i &lt;= r; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; for (int i = belong[l] + 1; i &lt; belong[r]; i++) if (p[i].lazy &gt; 4 || p[i].f) ans += p[i].sum; else &#123; p[i].f = true; for (int j = p[i].start; j &lt;= p[i].end; j++) &#123; int lazy = p[i].lazy, x = a[j]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[i].f = false; ans += x; &#125; &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= r; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125;void update(int l, int r) &#123; ll c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy++; else for (int i = l; i &lt;= p[belong[l]].end; i++) a[i] = sqrt(a[i]); if (p[belong[r]].end == r) p[belong[r]].lazy++; else for (int i = p[belong[r]].start; i &lt;= r; i++) a[i] = sqrt(a[i]); for (int i = belong[l] + 1; i &lt; belong[r]; i++) p[i].lazy++; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy++; else for (int i = l; i &lt;= r; i++) a[i] = sqrt(a[i]);&#125;int main() &#123; built(); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; // scanf("%d %d %d %d", // &amp;opt, // &amp;l, &amp;r, &amp;c); if (opt) print(l, r); else update(l, r); &#125; return 0;&#125; 数列分块入门 6给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及单点插入，单点询问，数据随机生成. 到了喜闻乐见的动态分块了$23333$.$c++$的$vector$大法好,我是不会用指针写链表的,拒绝每次插入一个数,就找到对应的块,扔进去就行.将插入的次数记下来,当次数超过$\sqrt n$的时候就进行重构,也就是重新分块.然后就没有然后了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int MAXN = 1e6 + 10;const int INF = 1e8 + 10;const int MOD = 998244353;const int ans = 11;typedef long long ll;int a[MAXN];vector&lt;int&gt;p[MAXN];int n, tot = 0, m, optt;void find(int k)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; cout &lt;&lt; p[i][k] &lt;&lt; '\n'; break; &#125; &#125;&#125;void rebuild()&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; for (int j = 0; j &lt; p[i].size(); j++) a[++num] = p[i][j]; p[i].clear(); &#125; n = num, m = sqrt(n), tot = 0; for (int i = 1; i &lt;= n; i++) &#123; p[tot].push_back(a[i]); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++;&#125;void insert(int k, int x)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; p[i].insert(p[i].begin() + k, x); optt++; break; &#125; &#125; if (optt == m) &#123; rebuild(); optt = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); p[tot].push_back(x); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++; int opt, l, r, c, q = n; for (int i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d%d",&amp;opt,&amp;l,&amp;r,&amp;c); if (opt) find(r); else insert(l, r); &#125; return 0;&#125; 未完待续]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]随机数生成器]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[序这个题,难在阅读. 题目大意跳过!链接:🔗 解析 首先根据题目得到一个随机数列$\lbrace x_i=(a×x_{i−1}^2+b×x_{i−1}+c)$mod$d\rbrace$其中$i\in{1…n×m}$ 搞一个数列$T$,其中$T_i=i$,$i\in{1….n×m}$ 对每一项$T_i$,我们$swap(T_i,$$T_{x_imodi+1})$ 以上$3$步结束后,得到的就是棋盘要填的数$T_i$ 样例一数据生成的棋盘如下: 12917 51162 41038 &emsp;&emsp;路线便是$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;一个有技巧的贪心来选数.&emsp;&emsp;首先,$map[1][1]$必定选.&emsp;&emsp;如果我们不考虑棋盘顺序,若要序列最小,显然是选最小数的放进去,那么我们便从$1$这个数开始贪心.那么,这个数我们什么时候才取它呢?&emsp;&emsp;根据题目要求,我们从左上角到右下角,只能向右或者向下走,只要选过的数在要选的数左上方或右下方的时候,这个数才是可选的,或者说是可到达的.&emsp;&emsp;假设当我们要选$9$时,我们已经选了$1,2,6,8,12$,我们看$9$能否到达呢?&emsp;&emsp;显然,左侧离它最近的数要$\ge$它的行,右侧离它最近的数要$\leq$它的行.这样我们就可以选它.&emsp;&emsp;当然,选完后更新$L[],R[]$. 即代码: 123456789101112//x为行,y为列//n行,m列for (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;理解了这个贪心,题目就很水了.&emsp;&emsp;据说要注意空间,时间…..全程cin好像没啥事. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我搭博客所踩的坑]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一.博文插入图片在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image --save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 二.修改博客标题背景如果你使用的是pisces模式的话,可以参考下列教程在\blog\themes\next\source\css\_schemes\Pisces中的_brand.styl文件内.在.site-meta 下的background后面修改为url(图片链接); 三.插入音乐在网易云音乐生成外链后插入到你想放的地方即可.注意:不要打开”阻止第三方 Cookie”这个选项一旦打开,iframe就加载不出来,插入音乐那一块全白.网上也没有多少人经历过估计(逼着我学会了看F12…) 四.npm下载超慢的问题使用cnpm,这是国内的一个镜像,速度很快,但无法使用publish链接:https://npm.taobao.org/ 五.Algolia搜索搭建的问题next的使用文档已经比较全面了 这个地方要加一句 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 其次用export,最好不要用set 12export HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API Key$ hexo algolia 这些都选上 六.头像旋转以及点击头像回到主页 回到主页:在123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; 就是在代码上下分别加了href1232. 旋转~~这个我也不懂~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl 内添加: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 搭建评论区 多说 网易云跟帖 畅言 来必力（LiveRe） Disqus Hypercomments valinevaline YES!( •̀ ω •́ )y虽然国内版需要备案,但是我们可以使用国际版的🔗 注册 验证邮箱和手机号 创建一个应用，名字可以随便起 进入应用-&gt;设置-&gt;应用$key$ 复制 $appid$ 和 $appkey$ 进入主题配置文件搜索 $valine$ 12345678910valine: enable: 由false改成true app_id: 要填 app_key: 要填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 可改 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去$d$一下完成. 先这些,持续更新]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-划分树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[引如题:POJ2014给定一$n$个元素的数组,每次查询$[l,r]$区间内从小到大第k个数.朴素解法为将数组$[l,r]$内的数排序,然后选择第$k$个即可.最坏情况$O(m*n)$.这个时候,就需要更好的数据结构,划分树/归并树. 定义原数组为${4,2,5,7,1,8,3,6}$,在每次划分左右子树时的中值,都用红色表明.小于中值的进入左子树,大于中值的进入右子树.观察我们发现,每一层都是数组$n$,只不过顺序有了变化.而对于$log2(1e9)$这个数,也不过$20$.所以我们定义一个$tree[20][n]$的数组,用来存树. 12//toleft稍后再讲int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; 建树我们定义一个数组$toleft[20][MAXN]$,其指在某数的左边所有进入左子树的数的个数.toleft数组 123456789101112第一次划分[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] 看i-th前面有多少个数进入左子树.第二次划分[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]第三次划分[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]第四次划分[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //same值指相同的中值 if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //将[l,r]内的数划分 if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //记下当前数的toleft值 &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; 查询类似于线段树的单点查询只需要考虑一个不等式$toleft[dep][r] - toleft[dep][l - 1]\leq k$如果成立,说明这个数被划进了左子树.那么大区间$[L,(L+R)&gt;&gt;1]$,小区间$[l,r]$变为$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$如果$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$那么,这个数就被划进了右子树,那么大区间变为$[(L+R)&gt;&gt;1+1,R]$,小区间变为$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.这样不断递归,当小区间$l==r$时,便确定了从小到大第$k$个数是几. 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; 完整代码当想查询从大到小第$k$个数,则将(tree[dep][i] < sorted[mid])```改为```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```改为从大到小排序即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2048]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>划分树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线段树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助 本篇很多地方借鉴英雄哪里出来的博客%%% 一、基本概念 线段树是一棵二叉搜索树，它储存的是一个区间的信息。 每个节点以结构体的方式存储，结构体包含以下几个信息：每个节点以结构体的方式存储，结构体包含以下几个信息： (1). 区间左端点、右端点 (2). 区间所代表的值 (3). 该节点的子节点 线段树的基本思想：二分。 线段树一般结构如图所示：假设数据为4个数，则树应是这样 由上图可知，每个节点的 每个节点的左孩子区间范围为[left，mid]，右孩子为[mid+1,right] 二、代码实现与基本操作0.基础数据结构123456789#ifndef NULL //防报错#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.建树 built函数12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,c用法 //申请一个新内存，并令p指向该处 p-&gt;left = left; //储存区间信息 p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,皆可，及储存数据 p-&gt;lson = NULL; //令左儿子和右儿子指向NULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //二分 p-&gt;lson = built(left, mid); //左儿子 p-&gt;rson = built(mid + 1, right); //右儿子 p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //存储左儿子和右儿子的和 &#125; return p; //返回指向该处的指针&#125; &emsp;&emsp;除了建树，相应关闭树的函数为： 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; &emsp;非常需要注意的一件事，每次用指针建立树的时候，请务必写一个关闭清理申请的内存的函数 2. 单点查询&emsp;&emsp;(1).查找k位置的数据 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.单点修改&emsp;&emsp;(1).知道点所在位置，修改该点处值 123456789int update(Node p, int x,int k) //对x位置的值，进行k值的变动&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //如过找到了k位置 return p-&gt;d +=k; //对该点值进行操作，可以为+-*/等 int mid = (p-&gt;left + p-&gt;right) / 2; //判断该点在左区间还是右区间 if (x &lt;= mid) //如果是左区间，只对左区间进行递归查询 return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //查找完后对父节点存储值进行修改 return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //不是该点，也不在左区间，只能是右区间&#125; 4.区间查询&emsp;&emsp;所给区间仅可能为上图四种情况。&emsp;&emsp;通过一定操作，我们都可以将上三种，全部转换为最后一种直接输出。&emsp;&emsp;闲话少说，代码实现 12345678910111213int find(Node p, int x,int y) //注，这里假设任意x,y，都有x&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //如果是第四种情况，直接返回 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //求中间值 if (y &lt;= mid) //如果查询区间在mid左边，因为x&lt;y&lt;=mid return find(p-&gt;lson, x, y); //那么直接递归左儿子 if (x &gt; mid) //如果查询区间在mid右边，因为mid&lt;x&lt;y return find(p-&gt;rson, x, y); //那么直接递归右儿子 return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //两式都不符合，及x&lt;=mid&lt;y //则从mid为中间值分开 //左儿子查询[x,mid],右儿子查询[mid+1,y]&#125; 5.区间修改1234567891011int update(Node p, int x, int y, int k) //设区间为[x,y]，修改的值为k&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //如果是这个区间内的元素，就让它+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //二分 if (y &lt;= mid) //如果区间在中值的左侧 return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //仅需更新左儿子的值，并更新父亲的值 if (x &gt; mid) //如果区间在中值的左侧 return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //同上 return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //如果区间被中值分开&#125; 三.优化（一）. Lazy-Tag懒标记&emsp;&emsp;我们考虑一下区间改值的过程：当更改某个区间的值的时候，子区间也跟着更改。显然，在大数据下，这样操作会导致TLE。&emsp;&emsp;怎么办？&emsp;&emsp;这时我们就引入一个优化方法，叫做Lazy-Tag懒标记。&emsp;&emsp;何为懒标记呢？顾名思义，就是用来偷懒的减少修改时消耗时间的。即：&emsp;&emsp;当我想要对某一区间的所有元素都+k时，在修改该区间节点时，对其打上标记lazy，并记lazy为k，修改该节点的值为+区间长度*k，立刻return，而不将该节点下面的所有子节点一一修改。 思想实现&emsp;&emsp;如图示：1~4的值分别为1，2，3，4&emsp;&emsp;我们选择对[1,2]区间进行修改，要求改区间所有值+2，则：在区间[1,2]，打上标记lazy=2，并修改其值为3+(2-1+1)2，直接返回，并不对其子节点进行修改&emsp;&emsp;当我们再次对[1,2]区间修改时，并要求区间内所有的值+1，则：由于[1,2]有标记lazy=2，于是我们将lazy标记向其子节点传导，并修改其子节点的值。再在[1,2]区间打上lazy=1，修改值为(2-1+1)1，返回。 代码实现0.核心代码 pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //如果该节点还有后续节点 p-&gt;lson-&gt;lazy += p-&gt;lazy; //令子节点lazy继承父节点lazy，下同 p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //修改子节点的值，下同 p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //令该节点的lazy清零&#125; 1.树本体123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //仅仅多了一个lazy标记 int left, right; Node lson, rson;&#125;*root; 2.建树12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //只是对lazy标记进行初始化 if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; 3.单点查询和单点修改无改变4.区间查询12345678910111213long long find(Node p, int x, int y) //区间查询&#123; if (p-&gt;lazy != 0) //解决一下历史遗留问题再查询 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //其他未变 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.区间修改123456789101112131415int update(Node p, int x, int y, int k) //区间修改&#123; if (p-&gt;lazy!=0) //如果该节点的lazy不为零，就处理一下 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //如果是要进行修改的节点，便让该节点的lazy为k，并修改值 p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; （二）. 离散化&emsp;&emsp;离散化是一个听起来很高大上的方法.&emsp;&emsp;其实做起来很简单.当然如果想高深的话,自然也拦不住&emsp;&emsp;其实就是将一串数据储存到数组中,不将数据本身作为键值,而是选择使用数组的下标作为键值.&emsp;&emsp;形象的,$1,2,3,10000000$这四个数,保存在数组$a[]$中,相对应的下标为$1,2,3,4$就可以减少空间的开支. 数组实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 1e5 + 10;typedef long long ll;struct Segment_Tree &#123; ll d, lazy; int left, right; int lson, rson;&#125;root[4 * MAXN];int n;void built(int p, int left, int right)&#123; root[p].left = left; root[p].right = right; root[p].lazy = 0; if (left == right) &#123; cin &gt;&gt; root[p].d; root[p].lson = root[p].rson = null; &#125; else &#123; int mid = (left + right) &gt;&gt; 1; built(root[p].lson = (p &lt;&lt; 1), left, mid); built(root[p].rson = (p &lt;&lt; 1 | 1), mid + 1, right); root[p].d = root[root[p].lson].d + root[root[p].rson].d; &#125;&#125;void pushdown(int p)&#123; if (root[p].lson != null) &#123; root[root[p].lson].lazy += root[p].lazy; root[root[p].lson].d += (root[root[p].lson].right - root[root[p].lson].left + 1)*root[p].lazy; root[root[p].rson].lazy += root[p].lazy; root[root[p].rson].d += (root[root[p].rson].right - root[root[p].rson].left + 1)*root[p].lazy; &#125; root[p].lazy = 0;&#125;ll find(int p, int x, int y)&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) return root[p].d; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return find(root[p].lson, x, y); if (x &gt; mid) return find(root[p].rson, x, y); return find(root[p].lson, x, mid) + find(root[p].rson, mid + 1, y);&#125;long long update(int p, int x, int y, int k) //区间&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) &#123; root[p].lazy = k; return root[p].d += k * (y - x + 1); &#125; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return root[p].d = root[root[p].rson].d + update(root[p].lson, x, y, k); if (x &gt; mid) return root[p].d = root[root[p].lson].d + update(root[p].rson, x, y, k); return root[p].d = update(root[p].lson, x, mid, k) +update(root[p].rson, mid+1, y, k);&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; built(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int t, x, y, k; cin &gt;&gt; t; if (t == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1, x, y, k); &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; find(1, x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2251裸的RMQ问题,数据量小.洛谷P3372洛谷P3373洛谷线段树模板题]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法模板]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蒟蒻学识浅陋,欢迎各位大牛指正 KMP从入门到放弃请观左神为什么想要杀人%%%%njb7着重听1h12m20s$KMP$分为两个部分,一部分为两个字符串间的比较,另一部分为自己与自己的比较.简单的划分为下面两个图,详细理解请见左神不稳定情绪讲解.不过我$jiao$的在$1:21:04$时,将例子换为$”ababcababak”$更好理解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; 例题G.OulipoHDU 1686The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $’T’$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${‘A’, ‘B’, ‘C’, …, ‘Z’}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $1 ≤ |W| ≤ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $|W| ≤ |T| ≤ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 解析$kmp$模板,读入不能用$cin$,否则超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]动物园]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[序言&emsp;&emsp;这个题写的我好迷啊== 题目简述&emsp;&emsp;园长想让你求一个字符串的”不互相重叠的公共前后缀个数”然后再乘起来.一大骡子的字,总结一下就是这个意思. 解析&emsp;&emsp;如果你不会$KMP$….那我也没办法(笑)&emsp;&emsp;我们知道,$next$保存的是有重叠部分的最大长度.那么我们在它计算的过程中,把当前$next[i]$的位置,存一个长度$cnt[i]$,啥意思?&emsp;&emsp;我$next[i]$从头扫到尾,相当于一个递推得到最大长度.同时进行$cnt[i]$从头扫到尾,相当于递推得到最大个数.&emsp;&emsp;然后再用$next[]$数组,找到不重复的位置,也就是$j\leq{i/2}$这样的位置,计算$cnt$,完成. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]魔法森林]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[序言$UOJ$果然是神仙$OJ$啊里面个个都是人才,说话还好听题目的$hack$数据还可以$hack$掉网上一大片的题解….. 题目描述为了得到书法大家的真传，小$E$同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个$N$节点$M$条边的无向图，节点标号为$1…n$，边标号为$1…m$。初始时小$E$同学在$1$ 号节点，隐士则住在 $n$ 号节点。小$E$需要通过这一片魔法森林，才能够拜访到隐士。魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：$A$型守护精灵与$B$型守护精灵。小$E$可以借助它们的力量，达到自己的目的。只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$。若身上携带的$A$型守护精灵个数不少于 $a_i$，且$B$型守护精灵个数不少于 $b_i$，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小$E$发起攻击，他才能成功找到隐士。由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为$A$型守护精灵的个数与$B$型守护精灵的个数之和。 题目大意:从$1$走到$n$,$m$条边,如何走能使$a$和$b$的和最大值最小. 解析首先,这是一个最小生成树的题目.其次,这应该是一个动态最小生成树的题目.(如果你学过用LCT做最小生成树,这个题就非常的水)我们将$a_i$排序后,按边取,可以保证$a_i$是最小的.在按$a_i$大小取边的时候,同时更新路上$b_i$的最大值.当我们取到一个环的时候怎么办?列如这样:我们就要对新加入的边上$b_i$的值,和维护的链上$b_i$的最大值进行比较. 如果链上的值大,那么我们把链上最大的那条边$cut$,如何把新边连上. 如果新边大,我们便直接跳过. 如此往复,直到$1$$n$这条路连通.连通后,我们加入另一个操作:判断,加入的这条边对于答案的影响.$a$大并不代表$b$也大,因为问的是$a+b$的和.直到遍历完所有边.~过了最小生成树的代码居然只有97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]起床困难综合症]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[描述 链接:http://uoj.ac/problem/2 21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙. 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算$op$ 和一个参数$t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x$ $op$ $t$。最终drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$扇防御门后转变得到的攻击力。 由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 解析很有意思的题目,想到二进制拆位的话,思路就很清晰了. 虽然我由于不知名的原因一直50分 我们按位运算,因为每一位的运算是独立的,而每一位只可能是$0$或$1$. 只需要注意几点即可 原数第$k$位如果是$0$,出来的结果是$1$,我们就存下来 原数的第$k$位如果是$1$,出来的结果是$1$,且原数小于m,我们就存下来. ==97分代码== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; 不知道是哪位带佬出的hack数据, 123452 13983XOR 12XOR 12答案是13983 同样的思路,不同的做法,我们可以将$11111…$和$0$分别扔进去,那么分别将出来的非$0$的位加起来,就是我们的答案.同样,优先级$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; 这里$i$如果从$30$开始算,额外数据就是错的,$29$开始算,额外数据就能过. $emmmm$]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>二级制拆位</tag>
      </tags>
  </entry>
</search>
