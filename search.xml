<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前向星]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助 一.基本概念&emsp;&emsp;前向星是什么??&emsp;&emsp;前向星是一个边集数组.啥玩意啊,拽什么专业词汇啊.也就是说,与邻接矩阵相比,前向星更像是用vector储存的邻接链表,是储存边的数组.&emsp;&emsp;这个数组储存的是图里的每一条边.(下面上图)&emsp;&emsp;下面是一组图的数据&emsp;&emsp;$4$个顶点,$6$条边,起点,终点,这条边的长度4 61 2 22 3 22 4 11 3 53 4 31 4 4 &emsp;&emsp;前向星储存什么呢,存的是 第i条边 起点 终点 长度 1 1 2 2 2 2 3 2 3 2 4 1 4 1 3 5 5 3 4 3 6 1 4 4 二.代码实现&emsp;&emsp;看了一下存储方式是不是感觉so~~easy,确实如此.&emsp;&emsp;但是依然改变不了这是一个很优秀的数据结构(雾) 1.核心代码123struct edge &#123; int star, end, cost;&#125;p[100000]; 2.保存和输出123456789101112131415bool operator &lt;(edge a, edge b)&#123; return a.star &lt; b.star;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i].star &gt;&gt; p[i].end&gt;&gt;p[i].cost; sort(p, p + m); for (int i = 0; i &lt; m; i++) printf("%d %d %d\n",p[i].star,p[i].end,p[i].cost); return 0;&#125; &emsp;&emsp;当一个巨大的图却只有几个边的时候,这种保存方式的优势就大大的体现了出来.但是储存后需要按照起点排序.才能进行搜索或者求最短路.&emsp;&emsp;于是复杂度就要加上了排序的耗时. 三.优化–链式前向星1.基本概念&emsp;&emsp;没错,就是优化,让我们来考虑如何去掉这个鬼畜的排序$呢^呢$??&emsp;&emsp;只需要稍微改变一点点储存方式,再加入一个next就可以了.于是就像是从一个点发出去的链子一样.所以称为链式前向星(雾).&emsp;&emsp;怎么弄呢?&emsp;&emsp;$head[i]$保存的是第i个点的始边的位置,edge保存的是第i点的一条边的终点与长度,以及第i个点的下一条边的位置.分别用$end$,$cost$,$next$表示.&emsp;&emsp;于是就这样子了&emsp;&emsp;还是这个数据,会变成什么样子呢?? 第i条边 起点 终点 长度 1 1 2 2 2 2 3 2 3 2 4 1 4 1 3 5 5 3 4 3 6 1 4 4 &emsp;&emsp;使$next=0$表示木有出边 为什么边序号是倒着的??(这里先卖个关子,后面会说) 2.代码实现(边的储存以及输出)(1).数组实现123456789101112131415161718192021222324struct edge &#123; int end, cost,next;&#125;p[500001];int head[10001];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int s,e, c; cin &gt;&gt; s &gt;&gt; e &gt;&gt; c; p[i].end = e, p[i].cost = c; p[i].next=head[s]; head[s] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; int f = head[i]; while (f) &#123; printf("%d %d %d\n", i, p[f].end, p[f].cost); f = p[f].next; &#125; &#125; return 0;&#125; &emsp;&emsp;为什么边的位置是倒着的,木措,就是因为这两行,保存方式为下图演示. 12p[i].next=head[s];head[s] = i; &emsp;&emsp;让$head[i]$储存输入的边的位置,再让这条边的指向变为$head[i]$储存的位置.那么就意味着,越晚输入的边,它越靠近$head[i]$. (2).指针实现&emsp;&emsp;作为一个忠于指针写数据结构的人,怎么可能不用指针写一下这个家伙呢(雾).&emsp;&emsp;看懂上面的,这个应该没什么问题吧(逃) 1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct edge* nd;struct edge &#123; int end, cost; nd next;&#125;;nd head[10001];void close(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; nd p = head[i]; while (p != NULL) &#123; nd f = p-&gt;next; delete(p); //free(p); p = f; &#125; &#125;&#125; int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; memset(head, NULL, sizeof(head)); for (int i = 1; i &lt;= m; i++) &#123; int s, e, c; cin &gt;&gt; s &gt;&gt; e &gt;&gt; c; nd p = new(edge); //nd p=(nd) malloc(sizeof(edge)); p-&gt;end = e, p-&gt;cost = c; p-&gt;next = head[s]; head[s] = p; &#125; for (int i = 1; i &lt;= n; i++) &#123; nd f = head[i]; while (f!=NULL) &#123; printf("%d %d %d\n", i, f-&gt;end, f-&gt;cost); f = f-&gt;next; &#125; &#125; close(n); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F08%2F09%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[定义即使线性代数课结束,依然逃不过线性代数线性基,类似于线代里面的矩阵求最大线性无关组.看一下大佬的说法:锵锵,传送门%%%% 首先来看一个问题： 给出N个数,要从中选出一个最大的子集,使得子集中的任意个元素异或值不为0.这个和极大线性无关组有些类似。异或可以看出是模2域下的加法运算,如果把一个数转化为二进制,对应成一个由01构成的向量,所有这些向量就构成了一个线性空间。 原问题就转化为求这个向量组的极大线性无关组,把这样一个极大线性无关组成为线性基。可以用$O(60*60*n)$的高斯消元来解决。 但是还有更加快速的构造线性基的方法： 复杂度是$O(60*n)$ 思想&emsp;&emsp;可以这么看,我们有n多个数.这些数x相互xor(异或)得到的一些数y,我们称y是他们x的值域.但是n多个数可能都太大,不好维护或者储存.于是我们想用尽量小的数,假使有k个比较小的数,相互xor同样能求出值域y.而这些k个数,我们就称之为线性基.又有xor是在(0,1)为基底的空间里的运算.所以我们要把n多个数,解成二进制.举个栗子:我们有集合{x}={2,9,10,17}他们相互异或可以得到值域{y}.但是这4个数,太大了夸张一下.我们就要想办法缩小x得到集合{k}.于是,我们把这四个数写成矩阵,就成了矩阵A..我们考虑把这个变成上三角形,那么可以r3-r2+r4,然后r3和r4互换.就可以得到一个行阶梯型的矩阵.于是集合{x}-&gt;{k}={1,2,10,17}.嗯,没错,{k}就是我们要求得的线性基.当然,我们也可以处理掉10,保留9如果计算一下的话,会发现,得到的值域{y}是相同的.于是,我们就可以称{k}为线性基. 求解线性筛由图3,很明显我们知道了一个求线性基的方法,是高斯消元.但是太麻烦,繁琐,耗时.常用的是另一种.一句话介绍就是: 将x转换为二进制,从高位向低位扫,如果第一个1是第p位,如果$k_p=0$,就令$k_p=x$;如果$k_p!=0$,就令$x$XOR$k_p$后,重复上述阶段. 12345678for(int i = Bit ; i &gt;= 0 ; i-- ) //Bit是二进制的位数,常见题目大多为62. if( 1 &lt;&lt; i &amp; Num ) if( !Base[i] ) &#123; Base[i] = Num ; break ; &#125; else Num ^= Base[i] ; 常用操作一.查询最值贪心,从高位向低位贪心,可知,从高到底,后面的无法改变高位,只要高位变为最大的即可 12for (int i = 62; i &gt;= 0; i--) ans = max(ans, ans^p[i]); 二.查询最小值贪心,从高位向低位贪心,可知,从高到底,后面的无法改变高位,只要高位变为最小的即可 12for (int i = 62; i &gt;= 0; i--) ans = min(ans, ans^p[i]); 常见题目一.P3812 【模板】线性基这是一道模板题。 题目描述给定n个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。 输入输出格式输入格式:第一行一个数n，表示元素个数接下来一行n个数输出格式：仅一行，表示答案。 输入输出样例输入样例#1:21 1输出样例#1:1 说明$1≤n≤50,0≤S_i≤2^{50}$ 解析模板题目 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std; typedef long long ll;const int maxn = 1e5 + 10;ll a[maxn], p[maxn], dp[maxn];int main()&#123; int n; ll ans=0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt;n ; i++) for (int j = 62; j &gt;= 0; j--) if (1ll &lt;&lt; j &amp; a[i]) if (!p[j]) &#123; p[j] = a[i]; break; &#125; else a[i] ^= p[j]; for (int i = 62; i &gt;= 0; i--) ans = max(ans, ans^p[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二.小a与星际探索链接：https://ac.nowcoder.com/acm/contest/317/C 来源：牛客网题目描述&emsp;&emsp;小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数p。星球i能到达星球j当且仅当$p_i&gt;p_j$。&emsp;&emsp;同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为$t$⊕$p_j$(即$t$异或$p_j$，关于其定义请自行百度)&emsp;&emsp;小a想知道到达n号星球时耐久度最大为多少.注意：对于每个位置来说，从它出发可以到达的位置仅与两者的p有关，与下标无关 输入描述:&emsp;&emsp;第一行一个整数n，表示星球数&emsp;&emsp;接下来一行有n个整数，第i个整数表示pi 输出描述:&emsp;&emsp;一个整数表示到达n号星球时最大的耐久度&emsp;&emsp;若不能到达n号星球或到达时的最大耐久度为0则输出−1 示例输入3457 456 23输出478说明&emsp;&emsp;小a有两种方法到达3号星球&emsp;&emsp;第一种：1→2→3，最终耐久度为457⊕456⊕23=22&emsp;&emsp;第二种：1→3，最终耐久度为457⊕23=478输入42 4 4 2输出-1输入5234 233 123 2333 23输出253备注:1⩽n,∀pi⩽3000 解析&emsp;&emsp;求从$p_1$到$p_n$的异或和最大值,套板子….然后注意的是$p_i$到$p_j$的话需要$p_i&gt;p_j$.所以不符合的数直接扔掉就可以了.&emsp;&emsp;最后再判断一下$p_1$和$p_n$之间的大小关系就好了. 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;const int maxn = 1e5 + 10;int a[maxn], p[maxn];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; p[i]; for (int i = 0; i &lt;n ; i++) for (int j = 12; j &gt;= 0; j--) if (1ll &lt;&lt; j &amp; p[i]&amp;&amp;p[0]&gt;p[i]&amp;&amp;p[i]&gt;p[n]) if (!a[j]) &#123; a[j] = p[i]; break; &#125; else p[i] ^= a[j]; int ans = p[0] ^ p[n - 1]; for (int i = 12; i &gt;= 0; i--) ans = max(ans, ans^a[i]); cout &lt;&lt; (p[0]&gt;p[n-1]?ans:-1) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匈牙利算法]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参拜大佬%%% 二分图定义&emsp;&emsp;严格的定义请参加百度百科什么的.这里简单讲一下我的理解.就是给你一个图,有n个点.你可以按照边的关系,将这n个点分成两部分,而且这两部分之间有边相连.但是每一部分里面的点互不相连.&emsp;&emsp;如图1,左右两部分的点随意相连,但是每部分里的每一个点互不相连. 匹配&emsp;&emsp;首先是极大匹配(Maximal Matching),是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。&emsp;&emsp;而最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。&emsp;&emsp;如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。&emsp;&emsp;求二分图匹配可以用最大流(Maximal Flow)或者匈牙利算法(Hungarian Algorithm).&emsp;&emsp;当然本蒟蒻还没有学最大流 匈牙利算法&emsp;&emsp;我们来看图二,可以知道了这个二分图各点之间的联系.那么该算法如何实现最大匹配呢.&emsp;&emsp;根据字典序,显然易见,我们可以知道,A-&gt;E.&emsp;&emsp;随后,我们看B点,它要连E,但是E被占用了,我们该怎么办?我们把A-&gt;E之间的边暂时去掉,变成黄色,然后让B-&gt;E链接,但是A不能没有,于是这里从A再走,E不行,但是有个F.所以A-&gt;F.&emsp;&emsp;于是C-&gt;G也按此法加上,轮到D,我们发现G已经被连了.怎么办?将C-&gt;G的边暂时去掉.再从C走,看是否可以找别的边.但是我们发现,C只有到G的一条边.所以C-&gt;G保留,D只能孤立一人,我们无能为力. 核心代码12345678910bool find(int x)&#123; for (int i = 1; i &lt;= ny; i++) if (!used[i] &amp;&amp; m[x][i]) &#123; //used[]指的是,这个点是否被处理过.m[][]是指两者之间是否相连 used[i] = 1; if (!y[i] || find(y[i])) //如果这个点没有被链接,或者可以调整 return y[i] = x; &#125; return 0;&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endif#define maxn 10000using namespace std;typedef long long ll;int m[maxn][maxn], used[maxn],y[maxn],nx, ny;bool find(int x)&#123; for (int i = 1; i &lt;= ny; i++) if (!used[i] &amp;&amp; m[x][i]) &#123; used[i] = 1; if (!y[i] || find(y[i])) return y[i] = x; &#125; return 0;&#125;int main()&#123; int ans = 0,d; cin &gt;&gt; nx &gt;&gt; ny&gt;&gt;d; for (int i = 0; i &lt; d; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; m[x][y] = 1; &#125; for (int i = 1; i &lt;= nx; i++) &#123; memset(used, 0, sizeof(used)); if (find(i)) ans++; &#125; for (int i = 1; i &lt;= ny; i++) cout &lt;&lt; y[i] &lt;&lt; ':' &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、何为字典树&emsp;&emsp;简单讲，就是把一串字符，将每个字符当做一个节点，建立成一棵树&emsp;&emsp;举个栗子，我们有：a,ahat,hat,hatword,hziee,word。这么一撮单词，建成什么样子呢？&emsp;&emsp;如下图： 二、代码实现（一）树本体1234567typedef struct TreeNode* tn;struct TreeNode&#123; int cnt; tn next[54]; bool exist;&#125;;tn root; &emsp;&emsp;root是根，next指向下一个字母。cnt指该字母出现的个数，exist指在这里是否可以形成一个单词。&emsp;&emsp;像这样： （二）建树1234567891011121314151617181920212223tn New(tn p)&#123; p = new(TreeNode); memset(p-&gt;next, NULL, sizeof(p-&gt;next)); return p;&#125;void CreatTree(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) p-&gt;next[x]=New(p-&gt;next[x]); p=p-&gt;next[x]; p-&gt;cnt++; &#125; p-&gt;exist=1;&#125; &emsp;&emsp;简单粗暴，直接把一个字符串从头到尾撸进去即可，递归都不用写。 （三）查找123456789101112131415int Query(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) return 0; p=p-&gt;next[x]; &#125; return p-&gt;exist&amp;1; //return p-&gt;cnt;&#125; &emsp;&emsp;从上往下找，如果没有直接返回，有相应字符则继续。直到找到字符串的末尾，返回字符串末尾的exist，判断这个单词是否出现过。 （四）删除树==必写==1234567void close(tn p)&#123; for(int i=0;i&lt;54;i++) if(p-&gt;next[i]!=NULL&amp;&amp;p-&gt;next[i]-&gt;cnt) close(p-&gt;next[i]); delete(p);&#125; 三、例题Hat’s Words&emsp;&emsp;A hat’s word is a word in the dictionary that is the concatenation of exactly two other words in the dictionary.&emsp;&emsp;You are to find all the hat’s words in a dictionary. Input&emsp;&emsp;Standard input consists of a number of lowercase words, one per line, in alphabetical order. There will be no more than 50,000 words.&emsp;&emsp;Only one case. Output&emsp;&emsp;Your output should contain all the hat’s words, one per line, in alphabetical order. Sample Inputaahathathatwordhzieeword Sample Outputahathatword 解析&emsp;&emsp;字符串数组开太小是罪&emsp;&emsp;比较典型的题，问你能不能找到两个词，组成一个词。字典树储存，然后暴力拆一遍所有字符串来判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;typedef struct TreeNode* tn;struct TreeNode&#123; int cnt; tn next[54]; bool exist;&#125;;tn root;string s[50000];tn New(tn p)&#123; p=new(TreeNode); memset(p-&gt;next,NULL,sizeof(p-&gt;next)); return p;&#125;void CreatTree(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) p-&gt;next[x]=New(p-&gt;next[x]); p=p-&gt;next[x]; p-&gt;cnt++; &#125; p-&gt;exist=1;&#125;int Query(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) return 0; p=p-&gt;next[x]; &#125; return p-&gt;exist&amp;1; //return p-&gt;cnt;&#125;void find(string s)&#123; int len=s.length(); for(int i=1;i&lt;len-1;i++) if(Query(root,s.substr(0,i))&amp;&amp;Query(root,s.substr(i,len-i)))&#123; cout&lt;&lt;s&lt;&lt;endl; break; &#125;&#125;void close(tn p)&#123; for(int i=0;i&lt;54;i++) if(p-&gt;next[i]!=NULL&amp;&amp;p-&gt;next[i]-&gt;cnt) close(p-&gt;next[i]); delete(p);&#125;int main()&#123; int tot=0; root=New(root); while(cin&gt;&gt;s[tot])&#123; CreatTree(root,s[tot]); tot++; &#125; for(int i=0;i&lt;tot;i++) find(s[i]); close(root);&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列和单调栈]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[一.概念目的是:维持数据结构内的一组线性数据并保证其按照单调递减或单调递增.单调队列/栈的实现很简单,只用一个数组即可,多用于与其他算法等搭配,产生非常好的效果. 二.实现123456789101112int q[MAX],head,tail; //队列或者栈,头,尾void built(int &amp;head,int &amp;tail,int *q) //初始化&#123; memset(q,0,sizeof(q)); head=1,tail=0;&#125;void update(int x,int &amp;head,int &amp;tail,int *q) //插入数据&#123; while(tail&gt;=head&amp;&amp;x ? q[tail]) //维护队列/栈的单调性 tail--; q[++tail] = x;&#125; 三.题目单调队列洛谷P1886 滑动窗口https://www.luogu.org/problemnew/show/P1886现在有一堆数字共$N$个数字（$N&lt;=10^6$），以及一个大小为$k$的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。例如：The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$.输入输出格式输入格式：输入一共有两行，第一行为$n$,$k$。第二行为$n$个数($&lt;MAX$).输出格式：输出共两行，第一行为每次窗口滑动的最小值第二行为每次窗口滑动的最大值输入输出样例输入样例#1：8 31 3 -1 -3 5 3 6 7输出样例#1：-1 -3 -3 -3 3 33 3 5 5 6 7说明50%的数据，$n&lt;=10^5$100%的数据，$n&lt;=10^6$ 解析给你一组数据,和一个$k$大小的框子,框数,问框里的最大值和最小值各是多少.可以用dp做我们可以假装有一个单调队列来装这$k$个数.然后如果保证这个队列是单增的话,那么队首这个数在这$k$个数里,一定是最小的.同理可以得到最大的数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAXN = 1e6 + 1;using namespace std;int n, a[MAXN], q[MAXN], p[MAXN], MAX[MAXN], MIN[MAXN];int read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x*f;&#125;int maxx(int n, int k)&#123; int head = 1, tail = 0, tot = 0; //初始化队列 for (int i = 1; i &lt;= n; i++) &#123; while (tail &gt;= head &amp;&amp; a[i] &gt; q[tail]) //维持队列单调性 tail--; q[++tail] = a[i]; //入队 p[tail] = i; //同时存下数的下标 if (p[head] &lt;= i-k) //保证队里的数是最新的 head++; if(i&gt;=k) //在满足往框里扔进k个数后,再取最值 MAX[++tot] = q[head]; &#125; return tot;&#125;int minn(int n, int k)&#123; int head = 1, tail = 0, ans = 0; for (int i = 1; i &lt;= n; i++) &#123; while (tail &gt;= head&amp;&amp;a[i] &lt; q[tail]) tail--; q[++tail] = a[i]; p[tail] = i; if (p[head] &lt;= i - k) head++; if(i&gt;=k) MIN[++ans] = q[head]; &#125; return ans;&#125;int main()&#123; int n = read(), k = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); int tot = maxx(n, k); int ans = minn(n, k); for (int i = 1; i &lt;= ans; i++) cout &lt;&lt; MIN[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for (int i = 1; i &lt;= tot; i++) cout &lt;&lt; MAX[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; return 0;&#125; 单调栈[GXOI/GZOI2019]与或和https://www.luogu.org/problemnew/show/P5300题目描述Freda 学习了位运算和矩阵以后，决定对这种简洁而优美的运算，以及蕴含深邃空间的结构进行更加深入的研究。对于一个由非负整数构成的矩阵，她定义矩阵的AND 值为矩阵中所有数二进制AND(&amp;) 的运算结果；定义矩阵的OR 值为矩阵中所有数二进制OR(|) 的运算结果。 给定一个N×N 的矩阵，她希望求出： 该矩阵的所有子矩阵的 AND 值之和（所有子矩阵 AND 值相加的结果）。该矩阵的所有子矩阵的OR 值之和（所有子矩阵 OR 值相加的结果）。接下来的剧情你应该已经猜到——Freda 并不想花费时间解决如此简单的问题，所以这个问题就交给你了。 由于答案可能非常的大，你只需要输出答案对 ($10^9 + 7$)$1000000007$取模后的结果。 输入输出格式输入格式：输入文件的第一行是一个正整数 $N$，表示矩阵的尺寸。 接下来 $N$ 行，每行 $N$ 个自然数，代表矩阵的一行。相邻两个自然数之间由一个或多个空格隔开。 输出格式：输出只有一行，包含两个用空格隔开的整数，第一个应为所有子矩阵 AND 值之和除以 $10^9+7$的余数，第二个应为所有子矩阵 OR 值之和除以 $10^9+7$的余数。 输入输出样例输入样例#1：31 0 00 0 00 0 0输出样例#1：1 9输入样例#2：31 2 34 5 67 8 9输出样例#2：73 314说明样例1解释该 $3×3$ 矩阵共有 $9$个 $1×1$ 子矩阵、$6$ 个 $1×2$ 子矩阵、$6$ 个 $2×1$ 子矩阵、$4$ 个$2×2$ 子矩阵、$3$ 个 $1×3$ 子矩阵、$3$ 个 $3×1$ 子矩阵、$2$ 个 $2×3$ 子矩阵、$2$ 个 $3×2$ 子矩阵和 $1$ 个 $3×3$ 子矩阵。只有一个子矩阵（仅由第一行第一列的那个元素构成的 $1×1$ 矩阵）AND 值为 $1$，其余子矩阵的AND 值均为 $0$，总和为 $1$。包含第一行第一列那个元素的子矩阵有 $9$ 个，它们的 OR 值为 $1$，其余子矩阵的 OR 值为 $0$，总和为 $9$。数据范围 测试点编号$n$ 的规模矩阵中的自然数 $10$$1≤n≤1000$$≤2^{31} - 1$ 解析&emsp;&emsp;1.对于两个数a,b进行位运算,每一位的位运算是单独的.所以我们可以按照位将整个矩阵分层为多个0,1矩阵.每一位的0,1矩阵的位运算和按二进制的方式加起来,便是a,b的矩阵位运算和.&emsp;&emsp;2.于是,题目变成只有0,1两个数的问题.&emsp;&emsp;对于位运算和,只有当一个子矩阵中所有数为1时,该子矩阵的&amp;和为1,否则为0,也就是说,我们求一个矩阵中子矩阵的&amp;和的和,只需要统计共有多少个全是1的矩阵即可.&emsp;&emsp;当一个子矩阵中的所有数为0时,该子矩阵的|和为0.当我们求一个矩阵中子矩阵的|和,只需要在总|和中减去全为0的矩阵个数即可.&emsp;&emsp;3.于是问题变为求符合条件的子矩阵的个数.&emsp;&emsp;引入一个结论: 在一个 N×M 的矩阵中，以(n,m)为右下角的子矩阵共有 N×M 个 &emsp;&emsp;4.所以答案就变成了,以(n,m)为右下角的符合条件的子矩阵有多少个.&emsp;&emsp;那么,如何得到以(n,m)为右下角的子矩阵最大的个数呢?&emsp;&emsp;我们转换一下思维,问题便可以变为:在i-th处以高为h-i的矩阵向左的最大扩展长度为多少.也就是单调栈.&emsp;&emsp;于是问题就解决啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int mod = 1e9 + 7;ll ans1, ans2, n, sum;int a[1010][1010], mx[1010];bool b[1010][1010];struct vec &#123; int h, len;&#125;q[1000 + 10];ll f1(int f)&#123; memset(mx, 0, sizeof(mx)); ll res = 0; for (int i = 1; i &lt;= n; i++) &#123; ll num = 0, tail = 0, head = 1; for (int j = 1; j &lt;= n; j++) &#123; mx[j] = f^(!b[i][j])?mx[j]+1:0; int len = 1; while (tail &gt;= head &amp;&amp; q[tail].h &gt;= mx[j]) &#123; num -= q[tail].h*q[tail].len; len += q[tail].len; tail--; &#125; num += mx[j] * len; res = (res%mod + num % mod) % mod; tail++; q[tail].h = mx[j]; q[tail].len = len; &#125; &#125; return res;&#125;int main()&#123; scanf("%lld", &amp;n); sum = (n*(n + 1) / 2 * n*(n + 1) / 2) % mod; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf("%d", &amp;a[i][j]); for (int k = 0; k &lt;= 31; k++) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i][j] &amp; (1 &lt;&lt; k)) b[i][j] = 1; else b[i][j] = 0; ans1 = (ans1%mod + (1LL &lt;&lt; k) % mod*f1(1) % mod) % mod; ans2 = (ans2%mod + (1LL &lt;&lt; k) % mod*(sum - f1(0) + mod) % mod) % mod; &#125; printf("%lld %lld", ans1, ans2);&#125;` POJ3250 Bad Hair DayDescriptionSome of Farmer John’s N cows (1 ≤ N ≤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cows’ heads.Each cow i has a specified height hi (1 ≤ $h_i$ ≤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow i can see the tops of the heads of cows in front of her (namely cows i+1, i+2, and so on), for as long as these cows are strictly shorter than cow i.Consider this example: = = = = - = Cows facing right --&gt; = = = = - = = = = = = = = = 1 2 3 4 5 6 Cow#1 can see the hairstyle of cows #2, 3, 4Cow#2 can see no cow’s hairstyleCow#3 can see the hairstyle of cow #4Cow#4 can see no cow’s hairstyleCow#5 can see the hairstyle of cow 6Cow#6 can see no cows at all!Let ci denote the number of cows whose hairstyle is visible from cow i; please compute the sum of c1 through cN.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5.InputLine 1: The number of cows, N.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i.Output Line 1: A single integer that is the sum of c1 through cN.Sample Input610374122Sample Output5SourceUSACO 2006 November Silver 解析维护一个单调递减的栈,比ta矮的都能看到,而进去的牛除了队尾的都会加一,所以直接ans+=tail 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;const int INF = 0x3f3f3f3f;const int MAX = 80000 + 10;using namespace std;long long p[MAX];long long read()&#123; long long x = 0, f = 1; char c = getchar(); while (c&lt;'0'&amp;&amp;c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x;&#125;int main()&#123; int n = read(), head = 1, tail = 0; long long ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x = read(); while (head &lt;= tail &amp;&amp; x &gt;= p[tail]) tail--; ans += tail; p[++tail] = x; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; POJ 2559 Largest Rectangle in a HistogramDescriptionA histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles: Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.InputThe input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1&lt;=n&lt;=100000. Then follow n integers h1,…,hn, where 0&lt;=$h_i$&lt;=1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case.OutputFor each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.Sample Input7 2 1 4 5 1 3 34 1000 1000 1000 10000Sample Output84000HintHuge input, scanf is recommended.SourceUlm Local 2003 解析私以为不如该博主讲得好:https://www.cnblogs.com/violet-acmer/p/9780638.html#commentform 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAX = 1e6 + 1;using namespace std;long long n, q[MAX], l[MAX], r[MAX], a[MAX];long long read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x;&#125;int main()&#123; while (n = read(), n) &#123; int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); while (tail &gt;= head&amp;&amp;a[i] &lt;= a[q[tail]]) //维持单调性,注意保存的是下标 tail--; l[i] = tail &lt; head ? 1 : q[tail] + 1; //如果它不是栈首,我们就认为它左边有矩形 q[++tail] = i; &#125; head =1, tail = 0; for (int i = n; i &gt; 0; i--) &#123; while (tail &gt;= head&amp;&amp;a[i] &lt;= a[q[tail]]) tail--; r[i] = tail &lt; head ? n : q[tail] - 1; q[++tail] = i; &#125; long long res = 0; for (int i = 1; i &lt;= n; i++) res = max(res, a[i] * (r[i] - l[i] + 1)); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; POJ2796 Feel GoodDescriptionBill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people’s memories about some period of life.A new idea Bill has recently developed assigns a non-negative integer value to each day of human life.Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it. This schema reflects that good on average period can be greatly spoiled by one very bad day.Now Bill is planning to investigate his own life and find the period of his life that had the greatest value. Help him to do so.InputThe first line of the input contains n - the number of days of Bill’s life he is planning to investigate(1 &lt;= n &lt;= 100000). The rest of the file contains n integer numbers a1, a2, … an ranging from 0 to 106 - the emotional values of the days. Numbers are separated by spaces and/or line breaks.OutputPrint the greatest value of some period of Bill’s life in the first line. And on the second line print two numbers l and r such that the period from $l_{th}$ to $r_{th}$ day of Bill’s life(inclusive) has the greatest possible value. If there are multiple periods with the greatest possible value,then print any one of them.Sample Input63 1 6 4 5 2Sample Output603 5SourceNortheastern Europe 2005 解析谜一样的wa点…..左边扫一遍,右边扫一遍.我还是不知道咋wa的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;stack&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define MAX 100010using namespace std;typedef long long LL;LL a[MAX], sum[MAX];int le[MAX], ri[MAX],p[MAX];int main() &#123; int n; cin &gt;&gt; n; memset(le, -1, sizeof(le)); memset(ri, -1, sizeof(ri)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); sum[i] = sum[i - 1] + a[i]; &#125; int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; while (head&lt;=tail &amp;&amp; a[p[tail]] &gt; a[i]) &#123; ri[p[tail]] = i; tail--; &#125; p[++tail] = i; &#125; head = 1, tail = 0; for (int i = n; i &gt;= 1; i--) &#123; while (head &lt;= tail &amp;&amp; a[p[tail]] &gt; a[i]) &#123; le[p[tail]] = i; tail--; &#125; p[++tail] = i; &#125; LL ans = -1; int ans_l = -1, ans_r = -1; for (int i = 1; i &lt;= n; i++) &#123; int l = le[i] == -1 ? 0 : le[i],r = ri[i] == -1 ? n : ri[i] - 1; LL cur = (sum[r] - sum[l]) * a[i]; if (cur &gt; ans) &#123; ans_l = l + 1; ans_r = r; ans = cur; &#125; &#125; printf("%lld\n%d %d\n", ans, ans_l, ans_r); return 0;&#125; 计蒜客 Max answerhttps://nanti.jisuanke.com/t/38228Alice has a magic array. She suggests that the value of a interval is equal to the sum of the values in the interval, multiplied by the smallest value in the interval.Now she is planning to find the max value of the intervals in her array. Can you help her? InputFirst line contains an integer $n$($1≤n≤5×10^5$).Second line contains nn integers represent the array $a(−10 ^5 ≤a_i ≤10^5)$. OutputOne line contains an integer represent the answer of the array.样例输入51 2 3 4 5样例输出36 解析求区间$(l,r)*min(l,r)$,在$(l,r)$区间内取一个最小值,乘该区间内值的和,问怎样取才能取到最大值.首先,因为数据过大,要用单调栈.如果单套模板,会wa,因为会有负数.故要对负数进行特判.如果是负数…就按$o(n^2)$的算法做一遍… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAX = 1e6 + 1;using namespace std;long long n, q[MAX], l[MAX], r[MAX], a[MAX], num[MAX],maxl[MAX];long long read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int main()&#123; n = read(); int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); num[i] = num[i - 1] + a[i]; while (tail &gt;= head &amp;&amp; a[i] &lt;= a[q[tail]]) tail--; l[i] = tail &lt; head ? 1 : q[tail] + 1; q[++tail] = i; &#125; head = 1, tail = 0; for (int i = n; i &gt; 0; i--) &#123; while (tail &gt;= head &amp;&amp; a[i] &lt;= a[q[tail]]) tail--; r[i] = tail &lt; head ? n : q[tail] - 1; q[++tail] = i; &#125; long long ans = 0; for (int i = 1; i &lt;= n; i++) if (a[i] &lt; 0) &#123; long long set = 0; for (int j = l[i]; j &lt;= i; j++) maxl[i]= min(maxl[i],num[i] - num[j-1]); set=max(set,maxl[i]*a[i]); for (int j = i + 1; j &lt;= r[i]; j++) set = max(set, a[i] * (maxl[i] + num[j] - num[i])); ans = max(ans, set); &#125; else ans = max(ans, a[i] * (num[r[i]] - num[l[i] - 1])); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*5-8 -7 1 -7 -8*/]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调队列</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左偏堆]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B7%A6%E5%81%8F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[一.序强烈安利&lt;数据结构与算法分析-c语言描述&gt;这本书!!!更好的讲解可阅读该书.或者看这位大佬的博客%% 二.用处这个左式堆啊~直接当作可以合并的二叉堆来理解,这是再最好不过的了,其他和堆没啥区别. 三.基本概念 零路径长（$null\ pathength$）$Npl(X)$：结点$X$到一个没有两个儿子的结点的最短路径的长度。这里我们定义没有两个儿子的结点的$Npl(x)=1$；$Npl(NULL) = 0$。 左堆和堆一样，也具有结构性质和堆序性质。左堆的结构性质是指：对于堆中的每一个结点$X$，它的左儿子的零路径长要不小于其右儿子的零路径长。堆序信息与堆的一样，即：最小的结点应该是根节点，鉴于我们希望子树也是堆，那么每个子树的根节点也应该是最小的这一性质必然会导致左堆是一个极其不平衡的树。书上原话 四.合并每次合并都从右子树开始合并.这图我也看不大懂,大致理解就好了.反正代码写出来,感觉和图的方法没大关系 五.代码实现(一).结构12345typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root; 1234567891011121314151617181920### (二).合并```cppnd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆,小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) //保证性质不变 swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; //合并后,根节点的npl距离取右儿子的距离+1 &#125; return p;&#125; (三).插入插入这个命令,可以理解为,一个单个数的堆,与大堆合并.即把要插入的数当作一个堆,与要插入的堆合并即可. 1234567891011nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; (四).删除删除堆首的值,可以理解为,将堆根节点的左右儿子分成两个堆,然后再合并成一个新的堆. 12345678910nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125; (五).样例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson),close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆的小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; 例题(hdu 1512) Monkey Kinghttp://acm.hdu.edu.cn/showproblem.php?pid=1512 Problem DescriptionOnce in a forest, there lived $N$ aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can’t avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, $10$ will be reduced to $5$ and $5$ will be reduced to $2$).And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel. InputThere are several test cases, and each case consists of two parts.First part: The first line contains an integer $N$($N\leq100000$), which indicates the number of monkeys. And then $N$ lines follows. There is one number on each line, indicating the strongness value of ith monkey($\leq32768$).Second part: The first line contains an integer $M$($M\leq100000$), which indicates there are $M$ conflicts happened. And then $M$ lines follows, each line of which contains two integers $x$ and $y$, indicating that there is a conflict between the $X_{th}$ monkey and $Y_{th}$. OutputFor each of the conflict, output $-1$ if the two monkeys know each other, otherwise output the strongness value of the strongest monkey in all friends of them after the duel. Sample Input520161010452 33 43 54 51 5Sample Output855-110AuthorJIANG, YanyanSourceZOJ 3rd Anniversary ContestRecommendlinle 解析 一开始有$n$只孤独的猴子，然后他们要打$m$次架，每次打架呢，都会拉上自己朋友最牛叉的出来跟别人打，打完之后战斗力就会减半，每次打完架就会成为朋友（正所谓不打不相识o(∩_∩)o）。问每次打完架之后那俩猴子最牛叉的朋友战斗力还有多少，若朋友打架就输出$-1$. 并查集+可并堆每次猴子和猴子打架做朋友,就并在一起.每次要打架就查一下是不是在一起的朋友,不是就打架,是就输出$-1$. 在经历了无数次$re$和$mle$后,我把$close$函数删了==,遗留的指针遗留就遗留吧.就$ac$了…….$wtf$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;cstdio&gt;#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;struct vec &#123; int d,fa; nd p; vec() &#123; d = 0, p = NULL; &#125;&#125;a[101000];void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson); close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //堆的小根&lt;,大根&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125;int top(nd p)&#123; return p-&gt;d;&#125;int ffa(int x)&#123; if (x == a[x].fa) return x; return a[x].fa=ffa(a[x].fa);&#125;int read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int main()&#123; int n, m; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; a[i].d=read(); a[i].fa = i; a[i].p = insert(a[i].p, a[i].d); &#125; m=read(); for (int i = 1; i &lt;= m; i++) &#123; int x, y, fx, fy; x=read(),y=read(); fx = ffa(x), fy = ffa(y); if (fx != fy) &#123; a[fy].fa = fx; int num1 = top(a[fx].p) / 2, num2 = top(a[fy].p) / 2; a[fx].p = pop(a[fx].p); a[fy].p = pop(a[fy].p); a[fx].p = a[fy].p = merge(a[fx].p, a[fy].p); a[fx].p = a[fy].p = insert(a[fx].p, num1); a[fx].p = a[fy].p = insert(a[fx].p, num2); cout &lt;&lt; top(a[fx].p) &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; for (int i = 1; i &lt;= n; i++) a[i].p = NULL; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>左偏堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F08%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[引例洛谷P3865$RMQ$的中文翻译为:静态区间最值查询.英文我不知道所以不写给你$n$个数,$m$次查询,查询的内容为区间$[l,r]$中的最大值.$RMQ$有解法蛮多的,$st$表,线段树,树状数组,划分树都可以做.$st$表的复杂度为预处理$O(n*{\log_2} n)$+查询$O(m)$而线段树则需要预处理$O(n*{\log_2} n)$+查询$O(m*{\log_2} n)$树状数组没学,不清楚线段树可以看我之前的博客. 定义这个算法就是基于$DP$和位运算符，我们用$dp[i][j]$表示从第 $i$ 位开始，到第 $i + 2^j -1$ 位的最大值或者最小值。 那么我求$dp[i][j]$的时候可以把它分成两部分，第一部分从 $i$ 到 $i + 2 ^{(j-1)} - 1$ ，第二部分从 $i + 2 ^{(j-1)}$ 到$i + 2^j- 1$,那么可以得到$$dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1])$$当$j=0$时,求的是长度为1的区间的最小值,$j=1$时,求的是长度为2的区间最小值$j=2$时,求的是长度为4的区间最小值以此类推,故可在$O(n\log_2 n)$的复杂度处理完.如图所示查询的话,只需要反过来就阔以了. 完整代码这里mm[i] = mm[i - 1] +((i&(i - 1)) == 0);123456789101112131415161718192021222324252627282930313233343536373839```cppconst int MAXN = 1e5 + 10;int dp[MAXN][31],a[MAXN],mm[MAXN];void initRMQ(int n)&#123; mm[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; mm[i] = mm[i - 1] +((i&amp;(i - 1)) == 0); dp[i][0] = a[i]; &#125; for (int j = 1; j &lt;= mm[n]; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int x, int y)&#123; int k = mm[y - x + 1]; return max(dp[x][k], dp[y - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m;//scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initRMQ(n); while (m--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; rmq(x, y) &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; 二维st表暂存https://blog.csdn.net/VictoryCzt/article/details/83684082 约束RMQhttps://www.cnblogs.com/ghostcai/p/9280720.htmlhttps://blog.csdn.net/VictoryCzt/article/details/83348579 练习题目洛谷P2251裸的$RMQ$问题洛谷P3865$st$表模板题目洛谷P2048$st$表+前缀和+贪心+堆优化]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2F2019%2F08%2F09%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[不得不说&emsp;&emsp;本来标题想写分治,但是想了想发现自己分治能说的不多,主要的内容就是$CDQ$分治.便取了这个标题. 预备知识 关于什么是分治&emsp;&emsp;分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。在计算机科学中，分治法就是运用分治思想的一种很重要的算法。分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。 一般步骤 划分步：把输入的问题划分为$k$个子问题，并尽量使这$k$个子问题的规模大致相同。 治理步：当问题的规模大于某个预定的阈值$n_0$时，治理步由$k$个递归调用组成。 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。 时间复杂度 直观估计 分治由以上三部分构成，整体时间复杂度则由这三部分的时间复杂度之和构成. 由于递归，最终的子问题变得极为简单，以至于其时间复杂度在整个分治策略上的比重微乎其微. 经典例题 归并排序,快排等 求逆序对等经典例题$Atcoder\ A\ -\ Colorful\ Subsequence$https://atcoder.jp/contests/agc031/tasks/agc031_a 题目简析: 问多少种子序列,子序列中的字母不同. 列如$baa$,包括:$b,a,a,$两个不同位置$a$的$ba$,总计$5$个,$baa$排除是因为$a$是重复的. 解法 先将每个字母的个数统计下来,然后分治计算,一个字母的时候,答案是该字母出现的次数. 只有两个字母的时候,如$ab$,包含的排列有$a,b,ab$,相当于’$a$的个数,$b$的个数,$a$和$b$组合个数’的加和,而$a$和$b$组合个数,则是$a$的个数$\times b$的个数 同理可得,$ans$即为$ansL+ansR+ansL\times ansR$.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e5 + 10;const int MOD = 1e9 + 7;typedef long long ll;char s[INF];int num[27];string s1="0";ll solve(int L, int R)&#123; if (L == R) return num[s1[L] - 'a']; int mid = (L + R) &gt;&gt; 1; ll nL = solve(L, mid), nR = solve(mid + 1, R); return (nL%MOD + nR%MOD + (nL%MOD * nR%MOD)%MOD)%MOD;&#125;int main()&#123; int n; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (!num[s[i] - 'a']) s1 = s1 + s[i]; num[s[i] - 'a']++; &#125; cout &lt;&lt; solve(1, s1.length() - 1)&lt;&lt;endl; return 0;&#125; CDQ分治前面絮絮叨叨的简单介绍了下分治,想必各位对分治有了一定认识.下面是重头戏:$CDQ$分治.这个算法,是由陈丹琦大牛在论文中提出的%%%.首先,我们需要知道一些事情: 优势在于可以顶替复杂的高级数据结构，而且常数比较小 缺点在于必须离线操作 用来解决什么问题呢? 首先,分治问题2333 分治后的答案,不仅单单考虑子问题${L,mid}$和子问题${mid+1,R}$. 还需要考虑子问题${L,mid}$对子问题${mid+1,R}$的影响$/$联系产生的答案. 列如: 二维偏序问题 给定一个二元组${x,y}$,要求问有多少对${x_i,y_i},{x_j,y_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$ 解法为: 先将二元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的二元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得左区间相对于右区间的点的个数. 三维偏序问题 和二维偏序问题类似,但有一定不同 给定一个三元组${x,y,z}$,要求问有多少对${x_i,y_i,z_i},{x_j,y_j,z_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$&&$z_i&gt;z_j$ 解法为: 先将三元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的三元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得满足$y$条件的点. 再建立一个权值树状数组$/$线段树,再将上面符合的${x,y,z}$对应中满足不等式的$z$的点求出. 例题 BZOJ3262: 陌上花开 BZOJ4237: 稻草人或者这个LibreOJ稻草人 伪代码123456789101112void cdq(int left,int right)&#123; if(left==right) return ; int mid=(left+right)&gt;&gt;1; cdq(left,mid),cdq(mid+1,right); sort(a+l,a+mid+1,cmp); sort(a+mid+1,a+right+1,cmp); /** *处理左区间对于右区间影响的代码 */ 例题:稻草人问题简述链接https://loj.ac/problem/2880 &emsp;&emsp;给定$n$个稻草人（横纵坐标是不大于$10^9$的非负整数且两两$x,y$都不相同）求有多少个矩形满足： 边平行于横、纵轴 左下角、右上角都是给定的稻草人 内部不包含其它稻草人解析&emsp;&emsp;$Step\ 1.{\ }$&emsp;&emsp;首先考虑,如果无视第三条,那么,该题变为了什么?&emsp;&emsp;给定二元组集合,$A={x,y}$,那么对于任何${x_i,y_i}$,${x_j,y_j}$,问有多少对点满足:$y_j&gt;y_i$&&$x_j&gt;x_i$&emsp;&emsp;对于这样的一个式子,我们很容易得到两种解法,第一种:树状数组/万能的线段树.第二种:$cdq$分治.当然,本蒟蒻选择第二种.(为什么?树状数组咱还没学,线段树不会使)&emsp;&emsp;然后呢,$cdq$分治的标准操作为?12345678910void solve(int left, int right)&#123; if (left == right) return; int mid = (left + right) &gt;&gt; 1; solve(left, mid), solve(mid+1 , right);//分治处理左半边和右半边 /** *处理两边关系的代码 */&#125; 好的,本题完结 &emsp;&emsp;$Step\ 2.{\ }$&emsp;&emsp;于是,我们加上条件三.&emsp;&emsp;如何处理两边点之间的关系?&emsp;&emsp;对于左半边,我们假设右半边的点都是符合条件的. 我们可以知道,如果左半边的一个点$A$是符合条件的,那么答案$ans+=$右半边对于$A$符合条件的点. 我们在左半边加入$B$点,若$B$点的存在是与$A$点不冲突的,那么答案$ans+=$右半边对于$B$符合条件的点. 若,$B$点与$A$点的存在有矛盾,即不符合条件三,列如$x_b&lt;x_a,y_b&gt;y_a$这种情况,我们应:将$A$点对应的值删去,加入右半边对于$B$符合条件的点 &emsp;&emsp;$Step\ 3.{\ }$&emsp;&emsp;结合$Step\ 1$和$Step\ 2$.我们已知的有:&emsp;&emsp;假设我们是对$x$按照从小到大排序的,即对点按照$x$离散化后. 我们知道,左边的$x$必定小于右边的$x$. 我们要按照y的大小对左右分别排序. 对于右边,我们要维护一个按照$x$单调递增的单调栈.(即按照$y$递减) 对于左边,我们要维护一个按照$x$单调递减的单调栈.(即按照$y$递增) 每次左边新增一个$i$点,我们都要让答案$ans+=$右边维护的单调栈长度.答案$ans-=$右边比$y_i$小的点. 我们知道单调栈是单调的….嗯,所以对于寻点,我们可以二分查找. &emsp;&emsp;分析结束,综上,细节请参阅分治的代码来理解,手动模拟一遍就非常明了了. 来自LibreOJ的数据,非常适合模拟输入102 13 06 310 216 40 88 1211 1414 1118 10输出15示例图: 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e9 + 10;typedef long long ll;struct vec &#123; int x, y,len;&#125;tp[MAXN];int q_R[MAXN], q_L[MAXN], n,tail_L, tail_R;ll ans = 0;bool cmpx(vec a, vec b)&#123; return a.x &lt; b.x;&#125;bool cmpy(vec a, vec b)&#123; return a.y &gt; b.y;&#125;int find(int y)&#123; int left= 1, right= tail_R, mid=(left + right) &gt;&gt; 1; while(left &lt; right)&#123; if (tp[q_R[mid]].y &lt; y) right = mid; else left = mid + 1; mid = (left + right) &gt;&gt; 1; &#125; if (!tail_R || tp[q_R[left]].y &lt; y) left--; return left;&#125; void solve(int left, int right)&#123; if (left == right) return; int mid = (left + right) &gt;&gt; 1; solve(left, mid), solve(mid+1 , right); sort(tp+left, tp + mid+1, cmpy); sort(tp + mid + 1, tp + right + 1, cmpy); int i = left, j = mid + 1; tail_L = tail_R = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) if (tp[i].y &gt; tp[j].y) &#123; while(tail_L &gt; 0 &amp;&amp; tp[q_L[tail_L]].x &lt; tp[i].x) tail_L--; ans += tail_R; if (tail_L &gt; 0) ans -= find(tp[q_L[tail_L]].y); q_L[++tail_L] = i; i++; &#125; else &#123; while(tail_R &gt; 0 &amp;&amp; tp[q_R[tail_R]].x &gt; tp[j].x) tail_R--; q_R[++tail_R] = j; j++; &#125; for (; i &lt;= mid; i++) &#123; while(tail_L &gt; 0 &amp;&amp; tp[q_L[tail_L]].x &lt; tp[i].x) tail_L--; ans += tail_R; if (tail_L &gt; 0) ans -= find(tp[q_L[tail_L]].y); q_L[++tail_L] = i; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; tp[i].x &gt;&gt; tp[i].y; sort(tp+1, tp + n+1, cmpx); solve(1, n); cout&lt;&lt; ans &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[我好羡慕会用java的人为什么要用到高精度呢?我们知道,$int$的范围是$\pm2^{31}-1$,$long,long$的范围是$\pm2^{63}-1$,那么当我们想要表示更往上的数字,应该怎么做?虽然,我已经学会了 我上小学很计算机的一种方式,将每一位放在一个$a[i]$中,这样,一个数字就变成一个数组,对数字的四则运算,也就变成了对数组的操作. 高精度加法问:$1234+5678$答案是多少?答:$我不知道$咳咳,按照小学的教法,我们知道,要列个竖式,对齐数位,一位一位相加,满$10$进$1$.于是:$$\quad\quad1234\\underline{,\quad+5678}\\quad\quad6912$$分析一下计算过程,我们发现,当我们用数组$a$,数组$b$,分别存下$1234$和$5678$后,从数组的最后一位开始$for$循环,用数组$S$保存和,$temp$保存进位可以得到再将这个过程转化为代码,高精度加法就写出来了 123456789101112131415BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125; 高精度减法众所周知,减法是加法的逆运算.所以,我们将加法的过程反过来就是减法. 从头往后处理 $temp$保存向后一位的借位 处理负数的偷懒方式为,将第一位前加个符号,输出的时候就加上了符号1234567891011121314151617181920212223242526272829303132333435363738BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度乘法我们现在还是小学提问:$1234\times5678$答案是多少我们来列个式杂$\quad\quad\quad1234$$;\quad\underline{\quad\times5678}$$\quad\quad\quad9872$$\quad\quad8638$$\quad;;7404$$\underline{\quad6170\quad;}$$\quad7006652$那么分析一下这个过程.设一个空的$s$数组,$b$数组的个位$\times a$从个位开始和$s$的每一位相加,$b$数组的十位$\times a$从十位开始和$s$的每一位相加,以此类推,一直到$b$的千位计算结束,得到的便是答案 1234567891011121314151617181920212223242526BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 高精度除法好的,我们现在还是小学生 高精度除低精度好的,首先,除法是乘法的逆元,所以我们~倒着做回去 从头往后处理 $down$储存余数 当余数+该位小于低精度的数时,我们向后延续一位12345678910111213BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret, len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#define MAXN 9999 //MAXN控制每个a[i]内大小#define DLEN 4 //DLEN控制a[i]中有几位#define MAXSIZE 5010 //控制数字位数class BigNum &#123;private: int a[MAXSIZE]; int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator +(const BigNum &amp;)const; BigNum operator -(const BigNum &amp;)const; BigNum operator *(const BigNum &amp;)const; BigNum operator /(const int &amp;)const; BigNum operator ^(const int &amp;)const; long long operator %(const long long &amp;)const; bool operator &gt;(const BigNum&amp;i_T)const; bool operator &gt;(const int &amp;i_T)const; void print();&#125;;//int-&gt;BigNumBigNum::BigNum(const int i_b)&#123; int c, d = i_b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1))*(MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;//char-&gt;BigNumBigNum::BigNum(const char *i_s)&#123; int t, k, index, L; memset(a, 0, sizeof(a)); L = strlen(i_s); len = L / DLEN; if (L%DLEN) len++; index = 0; for (int i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + i_s[j] - '0'; a[index++] = t; &#125;&#125;//copyBigNum::BigNum(const BigNum &amp;i_T) :len(i_T.len)&#123; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_T.a[i];&#125;//BigNum复制BigNumBigNum&amp;BigNum::operator=(const BigNum&amp;i_n)&#123; len = i_n.len; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_n.a[i]; return *this;&#125;//cin&gt;&gt; BigNumistream&amp; operator &gt;&gt;(istream &amp;in, BigNum &amp;i_b)&#123; char ch[MAXSIZE * DLEN]; in &gt;&gt; ch; int L = strlen(ch), count = 0, sum = 0; for (int i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; DLEN &amp;&amp; i &gt;= 0; j++, i--, t *= 10) sum += (ch[i] - '0')*t; i_b.a[count] = sum; count++; &#125; i_b.len = count++; return in;&#125;//cout&lt;&lt;BigNumostream&amp; operator &lt;&lt;(ostream&amp; out, BigNum&amp; i_b)&#123; cout &lt;&lt; i_b.a[i_b.len - 1]; for (int i = i_b.len - 2; i &gt;= 0; i--) printf("%04d", i_b.a[i]); return out;&#125;//高精度除低精度BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;//高精度%低精度long long BigNum::operator%(const long long &amp;i_b)const&#123; long long d = 0; for (int i = len - 1; i &gt;= 0; i--) d = ((d*MAXN + 1) % i_b + a[i] * 1LL) % i_b; return d;&#125;//高精度求幂BigNum BigNum::operator^(const int &amp;n)const&#123; int i; BigNum t, ret(1); if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;//高精与高精比较bool BigNum::operator&gt;(const BigNum &amp;i_T)const&#123; int ln; if (len &gt; i_T.len) return true; else if (len &lt; i_T.len) return false; else &#123; ln = len - 1; while (a[ln] == i_T.a[ln] &amp;&amp; ln &gt; 0) ln--; return (ln &gt;= 0 &amp;&amp; a[ln] &gt; i_T.a[ln]); &#125;&#125;//高精与低精度bool BigNum::operator&gt;(const int &amp;i_T)const&#123; BigNum b(i_T); return *this &gt; b;&#125;//打印高精度void BigNum::print()&#123; printf("%d", a[len - 1]); for (int i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;//高精度相乘BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度除高精度好的,我们现在不做小学生了考虑用除低精度的做法,太麻烦了.那么我们再回到那句话,除法是乘法的逆元.考虑:$a/b=c\ldots d$,那么也就意味着$d+c\times b=a$,那么只要找到一个数$c$,使得$c\times b+d=a$即可于是,问题变为了加法和乘法的组合.对于加法,一个个试的话,必定超时.考虑两种方式:二分法和牛顿法.高精度用不了牛顿法况且我也不会,使用二分法,复杂度为$O(logN)$.对于乘法 普通的模拟$O(N^2)$. 分治乘法：最简单的是$Karatsuba$乘法，一般化以后有$Toom-Cook$乘法； 快速傅里叶变换$FFT$：（为了避免精度问题，可以改用快速数论变换$FNTT$），时间复杂度$O(N lgN lglgN)$。参照$Schönhage–Strassen algorithm$和$Fürer’s algorithm$ 中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行 两者结合即可解决问题.$fft$的话可以看一下$hdu1402$$java$$AC$后,$c/c++$还在敲代码.]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块1-9(未完)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%88%86%E5%9D%971-9-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[序感谢@hzwer大佬出的练习题题目链接LOJ本蒟过弱,实在不知道怎么压缩代码量了-&gt;_-&gt; 数列分块入门 1给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，单点查值。 将$n$个数,按照每$\sqrt{n}$为一个块标记. 123belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; 每次对所给的$[l,r]$区间进行讨论,分为”单蹦”和”块”,对于不满块的数,直接暴力修改.对于满足块的数,直接打一个标记,当访问的时候再进行修改即可,类似于线段树$lazy$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/const int MAXN = 1e5 + 10;int belong[MAXN], tot = 1, a[MAXN], n, cnt;struct block &#123; int lazy; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // cin &gt;&gt; a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); // cin &gt;&gt; opt&gt;&gt; l &gt;&gt; r &gt;&gt; c; if (opt) cout &lt;&lt; p[belong[r]].lazy + a[r] &lt;&lt; endl; else &#123; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) a[j] += c; &#125; &#125; return 0;&#125; 数列分块入门 2给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的元素个数。 区间加法仿照$1$即可.对于每一个块内的数据,为了方便查询,我们分便对每一个块内的数据进行排序.对于不满足块的数据,我们暴力处理,再将这个块内的数据排序,满足块的区间,我们依然是打标记即可.查询的时候,二分查找即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN],b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for(int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[i]=a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = 0; c *= c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans += lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; if (p[belong[r]].end == r) ans += lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans += lowerbound(b + p[j].start, p[j].end - p[j].start + 1, c, p[j].lazy); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans += lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 3给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的前驱（比其小的最大元素）。 和$2$类似. 出题人的想法:可以在块内维护其它结构使其更具有拓展性，比如放一个 set ，这样如果还有插入、删除元素的操作，会更加的方便。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN], b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; //cin &gt;&gt; a[i];//scanf("%d", &amp;a[i]); belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = -1; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) &#123; int t = lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[p[belong[l]].start+t-1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); if (p[belong[r]].end == r) &#123; int t = lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); if (t) ans = max(ans, b[p[belong[r]].start + t - 1] + p[belong[r]].lazy); &#125; else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); for (int j = belong[l] + 1; j &lt; belong[r]; j++) &#123; int t = lowerbound(b + p[j].start, p[j].end- p[j].start + 1, c, p[j].lazy); if (t) ans = max(ans, b[p[j].start + t - 1] + p[j].lazy); &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) &#123; int t = lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[l + t - 1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 4给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，区间求和。 求和预处理一下就阔以了,打标记的时候是长度$*$加法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef long long ll;const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/ll cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; ll lazy; ll sum; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; //scanf("%d", &amp;a[i]); belong[i] = tot; p[tot].sum += a[i]; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; ll c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; ll ans = 0; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= p[belong[l]].end; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); if (p[belong[r]].end == r) ans = (ans + (p[belong[r]].lazy*(p[belong[r]].end - p[belong[r]].start + 1)) % (c + 1) + p[belong[r]].sum % (c + 1)) % (c + 1); else for (int j = p[belong[r]].start; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans = (ans + (p[j].lazy*(p[j].end - p[j].start + 1)) % (c + 1) + p[j].sum % (c + 1)) % (c + 1); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) &#123; p[belong[r]].sum += c; a[j] += c; &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; &#125; return 0;&#125; 数列分块入门 5给出一个长为 $n$ 的数列 ，以及 $n$ 个操作，操作涉及区间开方，区间求和。 这个题目其实比较搞人==对于一个数,其属于${-2^{31},2^{31}-1}$,最多开方不超过$4$次.还是和之前一样,单个暴力,整块标记.对于一个块,如果开方次数超过$4$次,或者整个块只有$1$或$0$,我们就可以认为不需要对其处理了,只记下和即可.自己代码实现的时候,注意细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200typedef long long ll;const int MAXN = 1e5 + 10;/* belong[x]:元素x所在的块的编号，样例代码中为bl[x]; start[x]:编号为x的块的最左边的点，样例代码中为st[x]; end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; */int cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; int lazy; ll sum; int start, end; bool f; block() &#123; lazy = start = end = sum = 0; f = false;&#125;&#125; p[MAXN];void built() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; // scanf("%d", &amp;a[i]); belong[i] = tot; if (a[i] != 0) p[tot].sum++; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125;&#125;void print(int l, int r) &#123; ll ans = 0, c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; if (p[belong[r]].end == r) if (p[belong[r]].lazy &gt; 4 || p[belong[r]].f) ans += p[belong[r]].sum; else &#123; p[belong[r]].f = true; for (int i = p[belong[r]].start; i &lt;= p[belong[r]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[r]].f = false; ans += x; &#125; &#125; else for (int i = p[belong[r]].start; i &lt;= r; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; for (int i = belong[l] + 1; i &lt; belong[r]; i++) if (p[i].lazy &gt; 4 || p[i].f) ans += p[i].sum; else &#123; p[i].f = true; for (int j = p[i].start; j &lt;= p[i].end; j++) &#123; int lazy = p[i].lazy, x = a[j]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[i].f = false; ans += x; &#125; &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= r; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125;void update(int l, int r) &#123; ll c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy++; else for (int i = l; i &lt;= p[belong[l]].end; i++) a[i] = sqrt(a[i]); if (p[belong[r]].end == r) p[belong[r]].lazy++; else for (int i = p[belong[r]].start; i &lt;= r; i++) a[i] = sqrt(a[i]); for (int i = belong[l] + 1; i &lt; belong[r]; i++) p[i].lazy++; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy++; else for (int i = l; i &lt;= r; i++) a[i] = sqrt(a[i]);&#125;int main() &#123; built(); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; // scanf("%d %d %d %d", // &amp;opt, // &amp;l, &amp;r, &amp;c); if (opt) print(l, r); else update(l, r); &#125; return 0;&#125; 数列分块入门 6给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及单点插入，单点询问，数据随机生成. 到了喜闻乐见的动态分块了$23333$.$c++$的$vector$大法好,我是不会用指针写链表的,拒绝每次插入一个数,就找到对应的块,扔进去就行.将插入的次数记下来,当次数超过$\sqrt n$的时候就进行重构,也就是重新分块.然后就没有然后了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int MAXN = 1e6 + 10;const int INF = 1e8 + 10;const int MOD = 998244353;const int ans = 11;typedef long long ll;int a[MAXN];vector&lt;int&gt;p[MAXN];int n, tot = 0, m, optt;void find(int k)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; cout &lt;&lt; p[i][k] &lt;&lt; '\n'; break; &#125; &#125;&#125;void rebuild()&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; for (int j = 0; j &lt; p[i].size(); j++) a[++num] = p[i][j]; p[i].clear(); &#125; n = num, m = sqrt(n), tot = 0; for (int i = 1; i &lt;= n; i++) &#123; p[tot].push_back(a[i]); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++;&#125;void insert(int k, int x)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; p[i].insert(p[i].begin() + k, x); optt++; break; &#125; &#125; if (optt == m) &#123; rebuild(); optt = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); p[tot].push_back(x); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++; int opt, l, r, c, q = n; for (int i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d%d",&amp;opt,&amp;l,&amp;r,&amp;c); if (opt) find(r); else insert(l, r); &#125; return 0;&#125; 未完待续]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]随机数生成器]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[序这个题,难在阅读. 题目大意跳过!链接:🔗 解析 首先根据题目得到一个随机数列$\lbrace x_i=(a×x_{i−1}^2+b×x_{i−1}+c)$mod$d\rbrace$其中$i\in{1…n×m}$ 搞一个数列$T$,其中$T_i=i$,$i\in{1….n×m}$ 对每一项$T_i$,我们$swap(T_i,$$T_{x_imodi+1})$ 以上$3$步结束后,得到的就是棋盘要填的数$T_i$ 样例一数据生成的棋盘如下: 12917 51162 41038 &emsp;&emsp;路线便是$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;一个有技巧的贪心来选数.&emsp;&emsp;首先,$map[1][1]$必定选.&emsp;&emsp;如果我们不考虑棋盘顺序,若要序列最小,显然是选最小数的放进去,那么我们便从$1$这个数开始贪心.那么,这个数我们什么时候才取它呢?&emsp;&emsp;根据题目要求,我们从左上角到右下角,只能向右或者向下走,只要选过的数在要选的数左上方或右下方的时候,这个数才是可选的,或者说是可到达的.&emsp;&emsp;假设当我们要选$9$时,我们已经选了$1,2,6,8,12$,我们看$9$能否到达呢?&emsp;&emsp;显然,左侧离它最近的数要$\ge$它的行,右侧离它最近的数要$\leq$它的行.这样我们就可以选它.&emsp;&emsp;当然,选完后更新$L[],R[]$. 即代码: 123456789101112//x为行,y为列//n行,m列for (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;理解了这个贪心,题目就很水了.&emsp;&emsp;据说要注意空间,时间…..全程cin好像没啥事. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我搭博客所踩的坑]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一.博文插入图片在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image --save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 二.修改博客标题背景如果你使用的是pisces模式的话,可以参考下列教程在\blog\themes\next\source\css\_schemes\Pisces中的_brand.styl文件内.在.site-meta 下的background后面修改为url(图片链接); 三.插入音乐在网易云音乐生成外链后插入到你想放的地方即可.注意:不要打开”阻止第三方 Cookie”这个选项一旦打开,iframe就加载不出来,插入音乐那一块全白.网上也没有多少人经历过估计(逼着我学会了看F12…) 四.npm下载超慢的问题使用cnpm,这是国内的一个镜像,速度很快,但无法使用publish链接:https://npm.taobao.org/ 五.Algolia搜索搭建的问题next的使用文档已经比较全面了 这个地方要加一句 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 其次用export,最好不要用set 12export HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API Key$ hexo algolia 这些都选上 六.头像旋转以及点击头像回到主页 回到主页:在123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; 就是在代码上下分别加了href1232. 旋转~~这个我也不懂~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl 内添加: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 搭建评论区 多说 网易云跟帖 畅言 来必力（LiveRe） Disqus Hypercomments valinevaline YES!( •̀ ω •́ )y虽然国内版需要备案,但是我们可以使用国际版的🔗 注册 验证邮箱和手机号 创建一个应用，名字可以随便起 进入应用-&gt;设置-&gt;应用$key$ 复制 $appid$ 和 $appkey$ 进入主题配置文件搜索 $valine$ 12345678910valine: enable: 由false改成true app_id: 要填 app_key: 要填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 可改 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去$d$一下完成. 先这些,持续更新]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法模板]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蒟蒻学识浅陋,欢迎各位大牛指正 KMP从入门到放弃请观左神为什么想要杀人%%%%njb7着重听1h12m20s$KMP$分为两个部分,一部分为两个字符串间的比较,另一部分为自己与自己的比较.简单的划分为下面两个图,详细理解请见左神不稳定情绪讲解.不过我$jiao$的在$1:21:04$时,将例子换为$”ababcababak”$更好理解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; 例题G.OulipoHDU 1686The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $’T’$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${‘A’, ‘B’, ‘C’, …, ‘Z’}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $1 ≤ |W| ≤ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $|W| ≤ |T| ≤ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 解析$kmp$模板,读入不能用$cin$,否则超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线段树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助 本篇很多地方借鉴英雄哪里出来的博客%%% 一、基本概念 线段树是一棵二叉搜索树，它储存的是一个区间的信息。 每个节点以结构体的方式存储，结构体包含以下几个信息：每个节点以结构体的方式存储，结构体包含以下几个信息： (1). 区间左端点、右端点 (2). 区间所代表的值 (3). 该节点的子节点 线段树的基本思想：二分。 线段树一般结构如图所示：假设数据为4个数，则树应是这样 由上图可知，每个节点的 每个节点的左孩子区间范围为[left，mid]，右孩子为[mid+1,right] 二、代码实现与基本操作0.基础数据结构123456789#ifndef NULL //防报错#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.建树 built函数12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,c用法 //申请一个新内存，并令p指向该处 p-&gt;left = left; //储存区间信息 p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,皆可，及储存数据 p-&gt;lson = NULL; //令左儿子和右儿子指向NULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //二分 p-&gt;lson = built(left, mid); //左儿子 p-&gt;rson = built(mid + 1, right); //右儿子 p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //存储左儿子和右儿子的和 &#125; return p; //返回指向该处的指针&#125; &emsp;&emsp;除了建树，相应关闭树的函数为： 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; &emsp;非常需要注意的一件事，每次用指针建立树的时候，请务必写一个关闭清理申请的内存的函数 2. 单点查询&emsp;&emsp;(1).查找k位置的数据 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.单点修改&emsp;&emsp;(1).知道点所在位置，修改该点处值 123456789int update(Node p, int x,int k) //对x位置的值，进行k值的变动&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //如过找到了k位置 return p-&gt;d +=k; //对该点值进行操作，可以为+-*/等 int mid = (p-&gt;left + p-&gt;right) / 2; //判断该点在左区间还是右区间 if (x &lt;= mid) //如果是左区间，只对左区间进行递归查询 return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //查找完后对父节点存储值进行修改 return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //不是该点，也不在左区间，只能是右区间&#125; 4.区间查询&emsp;&emsp;所给区间仅可能为上图四种情况。&emsp;&emsp;通过一定操作，我们都可以将上三种，全部转换为最后一种直接输出。&emsp;&emsp;闲话少说，代码实现 12345678910111213int find(Node p, int x,int y) //注，这里假设任意x,y，都有x&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //如果是第四种情况，直接返回 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //求中间值 if (y &lt;= mid) //如果查询区间在mid左边，因为x&lt;y&lt;=mid return find(p-&gt;lson, x, y); //那么直接递归左儿子 if (x &gt; mid) //如果查询区间在mid右边，因为mid&lt;x&lt;y return find(p-&gt;rson, x, y); //那么直接递归右儿子 return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //两式都不符合，及x&lt;=mid&lt;y //则从mid为中间值分开 //左儿子查询[x,mid],右儿子查询[mid+1,y]&#125; 5.区间修改1234567891011int update(Node p, int x, int y, int k) //设区间为[x,y]，修改的值为k&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //如果是这个区间内的元素，就让它+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //二分 if (y &lt;= mid) //如果区间在中值的左侧 return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //仅需更新左儿子的值，并更新父亲的值 if (x &gt; mid) //如果区间在中值的左侧 return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //同上 return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //如果区间被中值分开&#125; 三.优化（一）. Lazy-Tag懒标记&emsp;&emsp;我们考虑一下区间改值的过程：当更改某个区间的值的时候，子区间也跟着更改。显然，在大数据下，这样操作会导致TLE。&emsp;&emsp;怎么办？&emsp;&emsp;这时我们就引入一个优化方法，叫做Lazy-Tag懒标记。&emsp;&emsp;何为懒标记呢？顾名思义，就是用来偷懒的减少修改时消耗时间的。即：&emsp;&emsp;当我想要对某一区间的所有元素都+k时，在修改该区间节点时，对其打上标记lazy，并记lazy为k，修改该节点的值为+区间长度*k，立刻return，而不将该节点下面的所有子节点一一修改。 思想实现&emsp;&emsp;如图示：1~4的值分别为1，2，3，4&emsp;&emsp;我们选择对[1,2]区间进行修改，要求改区间所有值+2，则：在区间[1,2]，打上标记lazy=2，并修改其值为3+(2-1+1)2，直接返回，并不对其子节点进行修改&emsp;&emsp;当我们再次对[1,2]区间修改时，并要求区间内所有的值+1，则：由于[1,2]有标记lazy=2，于是我们将lazy标记向其子节点传导，并修改其子节点的值。再在[1,2]区间打上lazy=1，修改值为(2-1+1)1，返回。 代码实现0.核心代码 pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //如果该节点还有后续节点 p-&gt;lson-&gt;lazy += p-&gt;lazy; //令子节点lazy继承父节点lazy，下同 p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //修改子节点的值，下同 p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //令该节点的lazy清零&#125; 1.树本体123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //仅仅多了一个lazy标记 int left, right; Node lson, rson;&#125;*root; 2.建树12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //只是对lazy标记进行初始化 if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; 3.单点查询和单点修改无改变4.区间查询12345678910111213long long find(Node p, int x, int y) //区间查询&#123; if (p-&gt;lazy != 0) //解决一下历史遗留问题再查询 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //其他未变 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.区间修改123456789101112131415int update(Node p, int x, int y, int k) //区间修改&#123; if (p-&gt;lazy!=0) //如果该节点的lazy不为零，就处理一下 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //如果是要进行修改的节点，便让该节点的lazy为k，并修改值 p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; （二）. 离散化&emsp;&emsp;离散化是一个听起来很高大上的方法.&emsp;&emsp;其实做起来很简单.当然如果想高深的话,自然也拦不住&emsp;&emsp;其实就是将一串数据储存到数组中,不将数据本身作为键值,而是选择使用数组的下标作为键值.&emsp;&emsp;形象的,$1,2,3,10000000$这四个数,保存在数组$a[]$中,相对应的下标为$1,2,3,4$就可以减少空间的开支. 数组实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 1e5 + 10;typedef long long ll;struct Segment_Tree &#123; ll d, lazy; int left, right; int lson, rson;&#125;root[4 * MAXN];int n;void built(int p, int left, int right)&#123; root[p].left = left; root[p].right = right; root[p].lazy = 0; if (left == right) &#123; cin &gt;&gt; root[p].d; root[p].lson = root[p].rson = null; &#125; else &#123; int mid = (left + right) &gt;&gt; 1; built(root[p].lson = (p &lt;&lt; 1), left, mid); built(root[p].rson = (p &lt;&lt; 1 | 1), mid + 1, right); root[p].d = root[root[p].lson].d + root[root[p].rson].d; &#125;&#125;void pushdown(int p)&#123; if (root[p].lson != null) &#123; root[root[p].lson].lazy += root[p].lazy; root[root[p].lson].d += (root[root[p].lson].right - root[root[p].lson].left + 1)*root[p].lazy; root[root[p].rson].lazy += root[p].lazy; root[root[p].rson].d += (root[root[p].rson].right - root[root[p].rson].left + 1)*root[p].lazy; &#125; root[p].lazy = 0;&#125;ll find(int p, int x, int y)&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) return root[p].d; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return find(root[p].lson, x, y); if (x &gt; mid) return find(root[p].rson, x, y); return find(root[p].lson, x, mid) + find(root[p].rson, mid + 1, y);&#125;long long update(int p, int x, int y, int k) //区间&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) &#123; root[p].lazy = k; return root[p].d += k * (y - x + 1); &#125; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return root[p].d = root[root[p].rson].d + update(root[p].lson, x, y, k); if (x &gt; mid) return root[p].d = root[root[p].lson].d + update(root[p].rson, x, y, k); return root[p].d = update(root[p].lson, x, mid, k) +update(root[p].rson, mid+1, y, k);&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; built(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int t, x, y, k; cin &gt;&gt; t; if (t == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1, x, y, k); &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; find(1, x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2251裸的RMQ问题,数据量小.洛谷P3372洛谷P3373洛谷线段树模板题]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]动物园]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[序言&emsp;&emsp;这个题写的我好迷啊== 题目简述&emsp;&emsp;园长想让你求一个字符串的”不互相重叠的公共前后缀个数”然后再乘起来.一大骡子的字,总结一下就是这个意思. 解析&emsp;&emsp;如果你不会$KMP$….那我也没办法(笑)&emsp;&emsp;我们知道,$next$保存的是有重叠部分的最大长度.那么我们在它计算的过程中,把当前$next[i]$的位置,存一个长度$cnt[i]$,啥意思?&emsp;&emsp;我$next[i]$从头扫到尾,相当于一个递推得到最大长度.同时进行$cnt[i]$从头扫到尾,相当于递推得到最大个数.&emsp;&emsp;然后再用$next[]$数组,找到不重复的位置,也就是$j\leq{i/2}$这样的位置,计算$cnt$,完成. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-划分树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[引如题:POJ2014给定一$n$个元素的数组,每次查询$[l,r]$区间内从小到大第k个数.朴素解法为将数组$[l,r]$内的数排序,然后选择第$k$个即可.最坏情况$O(m*n)$.这个时候,就需要更好的数据结构,划分树/归并树. 定义原数组为${4,2,5,7,1,8,3,6}$,在每次划分左右子树时的中值,都用红色表明.小于中值的进入左子树,大于中值的进入右子树.观察我们发现,每一层都是数组$n$,只不过顺序有了变化.而对于$log2(1e9)$这个数,也不过$20$.所以我们定义一个$tree[20][n]$的数组,用来存树. 12//toleft稍后再讲int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; 建树我们定义一个数组$toleft[20][MAXN]$,其指在某数的左边所有进入左子树的数的个数.toleft数组 123456789101112第一次划分[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] 看i-th前面有多少个数进入左子树.第二次划分[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]第三次划分[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]第四次划分[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //same值指相同的中值 if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //将[l,r]内的数划分 if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //记下当前数的toleft值 &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; 查询类似于线段树的单点查询只需要考虑一个不等式$toleft[dep][r] - toleft[dep][l - 1]\leq k$如果成立,说明这个数被划进了左子树.那么大区间$[L,(L+R)&gt;&gt;1]$,小区间$[l,r]$变为$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$如果$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$那么,这个数就被划进了右子树,那么大区间变为$[(L+R)&gt;&gt;1+1,R]$,小区间变为$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.这样不断递归,当小区间$l==r$时,便确定了从小到大第$k$个数是几. 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; 完整代码当想查询从大到小第$k$个数,则将(tree[dep][i] < sorted[mid])```改为```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```改为从大到小排序即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2048]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>数据结构</tag>
        <tag>划分树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]魔法森林]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[序言$UOJ$果然是神仙$OJ$啊里面个个都是人才,说话还好听题目的$hack$数据还可以$hack$掉网上一大片的题解….. 题目描述为了得到书法大家的真传，小$E$同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个$N$节点$M$条边的无向图，节点标号为$1…n$，边标号为$1…m$。初始时小$E$同学在$1$ 号节点，隐士则住在 $n$ 号节点。小$E$需要通过这一片魔法森林，才能够拜访到隐士。魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：$A$型守护精灵与$B$型守护精灵。小$E$可以借助它们的力量，达到自己的目的。只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$。若身上携带的$A$型守护精灵个数不少于 $a_i$，且$B$型守护精灵个数不少于 $b_i$，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小$E$发起攻击，他才能成功找到隐士。由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为$A$型守护精灵的个数与$B$型守护精灵的个数之和。 题目大意:从$1$走到$n$,$m$条边,如何走能使$a$和$b$的和最大值最小. 解析首先,这是一个最小生成树的题目.其次,这应该是一个动态最小生成树的题目.(如果你学过用LCT做最小生成树,这个题就非常的水)我们将$a_i$排序后,按边取,可以保证$a_i$是最小的.在按$a_i$大小取边的时候,同时更新路上$b_i$的最大值.当我们取到一个环的时候怎么办?列如这样:我们就要对新加入的边上$b_i$的值,和维护的链上$b_i$的最大值进行比较. 如果链上的值大,那么我们把链上最大的那条边$cut$,如何把新边连上. 如果新边大,我们便直接跳过. 如此往复,直到$1$$n$这条路连通.连通后,我们加入另一个操作:判断,加入的这条边对于答案的影响.$a$大并不代表$b$也大,因为问的是$a+b$的和.直到遍历完所有边.~过了最小生成树的代码居然只有97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]起床困难综合症]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[描述 链接:http://uoj.ac/problem/2 21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙. 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算$op$ 和一个参数$t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x$ $op$ $t$。最终drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$扇防御门后转变得到的攻击力。 由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 解析很有意思的题目,想到二进制拆位的话,思路就很清晰了. 虽然我由于不知名的原因一直50分 我们按位运算,因为每一位的运算是独立的,而每一位只可能是$0$或$1$. 只需要注意几点即可 原数第$k$位如果是$0$,出来的结果是$1$,我们就存下来 原数的第$k$位如果是$1$,出来的结果是$1$,且原数小于m,我们就存下来. ==97分代码== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; 不知道是哪位带佬出的hack数据, 123452 13983XOR 12XOR 12答案是13983 同样的思路,不同的做法,我们可以将$11111…$和$0$分别扔进去,那么分别将出来的非$0$的位加起来,就是我们的答案.同样,优先级$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; 这里$i$如果从$30$开始算,额外数据就是错的,$29$开始算,额外数据就能过. $emmmm$]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>二级制</tag>
      </tags>
  </entry>
</search>
