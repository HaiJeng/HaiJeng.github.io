<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]ÈöèÊú∫Êï∞ÁîüÊàêÂô®]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[Â∫èËøô‰∏™È¢ò,ÈöæÂú®ÈòÖËØª. È¢òÁõÆÂ§ßÊÑèË∑≥Ëøá!ÈìæÊé•:üîó Ëß£Êûê È¶ñÂÖàÊ†πÊçÆÈ¢òÁõÆÂæóÂà∞‰∏Ä‰∏™ÈöèÊú∫Êï∞Âàó$\lbrace x_i=(a√óx_{i‚àí1}^2+b√óx_{i‚àí1}+c)$mod$d\rbrace$ÂÖ∂‰∏≠$i\in{1‚Ä¶n√óm}$ Êêû‰∏Ä‰∏™Êï∞Âàó$T$,ÂÖ∂‰∏≠$T_i=i$,$i\in{1‚Ä¶.n√óm}$ ÂØπÊØè‰∏ÄÈ°π$T_i$,Êàë‰ª¨$swap(T_i,$$T_{x_imodi+1})$ ‰ª•‰∏ä$3$Ê≠•ÁªìÊùüÂêé,ÂæóÂà∞ÁöÑÂ∞±ÊòØÊ£ãÁõòË¶ÅÂ°´ÁöÑÊï∞$T_i$ Ê†∑‰æã‰∏ÄÊï∞ÊçÆÁîüÊàêÁöÑÊ£ãÁõòÂ¶Ç‰∏ã: 12917 51162 41038 &emsp;&emsp;Ë∑ØÁ∫ø‰æøÊòØ$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;‰∏Ä‰∏™ÊúâÊäÄÂ∑ßÁöÑË¥™ÂøÉÊù•ÈÄâÊï∞.&emsp;&emsp;È¶ñÂÖà,$map[1][1]$ÂøÖÂÆöÈÄâ.&emsp;&emsp;Â¶ÇÊûúÊàë‰ª¨‰∏çËÄÉËôëÊ£ãÁõòÈ°∫Â∫è,Ëã•Ë¶ÅÂ∫èÂàóÊúÄÂ∞è,ÊòæÁÑ∂ÊòØÈÄâÊúÄÂ∞èÊï∞ÁöÑÊîæËøõÂéª,ÈÇ£‰πàÊàë‰ª¨‰æø‰ªé$1$Ëøô‰∏™Êï∞ÂºÄÂßãË¥™ÂøÉ.ÈÇ£‰πà,Ëøô‰∏™Êï∞Êàë‰ª¨‰ªÄ‰πàÊó∂ÂÄôÊâçÂèñÂÆÉÂë¢?&emsp;&emsp;Ê†πÊçÆÈ¢òÁõÆË¶ÅÊ±Ç,Êàë‰ª¨‰ªéÂ∑¶‰∏äËßíÂà∞Âè≥‰∏ãËßí,Âè™ËÉΩÂêëÂè≥ÊàñËÄÖÂêë‰∏ãËµ∞,Âè™Ë¶ÅÈÄâËøáÁöÑÊï∞Âú®Ë¶ÅÈÄâÁöÑÊï∞Â∑¶‰∏äÊñπÊàñÂè≥‰∏ãÊñπÁöÑÊó∂ÂÄô,Ëøô‰∏™Êï∞ÊâçÊòØÂèØÈÄâÁöÑ,ÊàñËÄÖËØ¥ÊòØÂèØÂà∞ËææÁöÑ.&emsp;&emsp;ÂÅáËÆæÂΩìÊàë‰ª¨Ë¶ÅÈÄâ$9$Êó∂,Êàë‰ª¨Â∑≤ÁªèÈÄâ‰∫Ü$1,2,6,8,12$,Êàë‰ª¨Áúã$9$ËÉΩÂê¶Âà∞ËææÂë¢?&emsp;&emsp;ÊòæÁÑ∂,Â∑¶‰æßÁ¶ªÂÆÉÊúÄËøëÁöÑÊï∞Ë¶Å$\ge$ÂÆÉÁöÑË°å,Âè≥‰æßÁ¶ªÂÆÉÊúÄËøëÁöÑÊï∞Ë¶Å$\leq$ÂÆÉÁöÑË°å.ËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•ÈÄâÂÆÉ.&emsp;&emsp;ÂΩìÁÑ∂,ÈÄâÂÆåÂêéÊõ¥Êñ∞$L[],R[]$. Âç≥‰ª£Á†Å: 123456789101112//x‰∏∫Ë°å,y‰∏∫Âàó//nË°å,mÂàófor (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;ÁêÜËß£‰∫ÜËøô‰∏™Ë¥™ÂøÉ,È¢òÁõÆÂ∞±ÂæàÊ∞¥‰∫Ü.&emsp;&emsp;ÊçÆËØ¥Ë¶ÅÊ≥®ÊÑèÁ©∫Èó¥,Êó∂Èó¥‚Ä¶..ÂÖ®Á®ãcinÂ•ΩÂÉèÊ≤°Âï•‰∫ã. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>Ê®°Êãü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈÇ£‰∫õÂπ¥ÊàëÊê≠ÂçöÂÆ¢ÊâÄË∏©ÁöÑÂùë]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[‰∏Ä.ÂçöÊñáÊèíÂÖ•ÂõæÁâáÂú® Hexo‰∏≠ ÊèíÂÖ•ÂõæÁâáÊó∂ÔºåËØ∑ÊåâÁÖß‰ª•‰∏ãÁöÑÊ≠•È™§ËøõË°åËÆæÁΩÆ Â∞Ü Á´ôÁÇπÈÖçÁΩÆÊñá‰ª∂ ‰∏≠ÁöÑ post_asset_folde ÈÄâÈ°πÁöÑÂÄºËÆæÁΩÆ‰∏∫ true Âú®Á´ôÁÇπÊñá‰ª∂Â§π‰∏≠ÊâìÂºÄ git bashÔºåËæìÂÖ•ÂëΩ‰ª§ npm install hexo-asset-image --save ÂÆâË£ÖÊèí‰ª∂ ËøôÊ†∑ÔºåÂΩì‰ΩøÁî® hexo new title ÂàõÂª∫ÊñáÁ´†Êó∂ÔºåÂ∞ÜÂêåÊó∂Âú® source/_post Êñá‰ª∂Â§π‰∏≠ÁîüÊàê‰∏Ä‰∏™‰∏é title ÂêåÂêçÁöÑÊñá‰ª∂Â§πÔºåÊàë‰ª¨Âè™ÈúÄÂ∞ÜÂõæÁâáÊîæËøõÊ≠§Êñá‰ª∂Â§π‰∏≠ÔºåÁÑ∂ÂêéÂú®ÊñáÁ´†‰∏≠ÈÄöËøá Markdown ËØ≠Ê≥ïËøõË°åÂºïÁî®Âç≥ÂèØ ‰æãÂ¶ÇÔºåÂú®ËµÑÊ∫êÊñá‰ª∂Â§πÔºàÂ∞±ÊòØÈÇ£‰∏™‰∏é title ÂêåÂêçÁöÑÊñá‰ª∂Â§πÔºâ‰∏≠Ê∑ªÂä†ÂõæÁâá example.PNGÔºåÂàôÂèØ‰ª•Âú®ÂØπÂ∫îÁöÑÊñáÁ´†‰∏≠‰ΩøÁî®ËØ≠Âè• ![Á§∫‰æãÂõæÁâá](title/example.PNG &quot;Á§∫‰æãÂõæÁâá&quot;) Ê∑ªÂä†ÂõæÁâá ‰∫å.‰øÆÊîπÂçöÂÆ¢Ê†áÈ¢òËÉåÊôØÂ¶ÇÊûú‰Ω†‰ΩøÁî®ÁöÑÊòØpiscesÊ®°ÂºèÁöÑËØù,ÂèØ‰ª•ÂèÇËÄÉ‰∏ãÂàóÊïôÁ®ãÂú®\blog\themes\next\source\css\_schemes\Pisces‰∏≠ÁöÑ_brand.stylÊñá‰ª∂ÂÜÖ.Âú®.site-meta ‰∏ãÁöÑbackgroundÂêéÈù¢‰øÆÊîπ‰∏∫url(ÂõæÁâáÈìæÊé•); ‰∏â.ÊèíÂÖ•Èü≥‰πêÂú®ÁΩëÊòì‰∫ëÈü≥‰πêÁîüÊàêÂ§ñÈìæÂêéÊèíÂÖ•Âà∞‰Ω†ÊÉ≥ÊîæÁöÑÂú∞ÊñπÂç≥ÂèØ.Ê≥®ÊÑè:‰∏çË¶ÅÊâìÂºÄ‚ÄùÈòªÊ≠¢Á¨¨‰∏âÊñπ Cookie‚ÄùËøô‰∏™ÈÄâÈ°π‰∏ÄÊó¶ÊâìÂºÄ,iframeÂ∞±Âä†ËΩΩ‰∏çÂá∫Êù•,ÊèíÂÖ•Èü≥‰πêÈÇ£‰∏ÄÂùóÂÖ®ÁôΩ.ÁΩë‰∏ä‰πüÊ≤°ÊúâÂ§öÂ∞ë‰∫∫ÁªèÂéÜËøá‰º∞ËÆ°(ÈÄºÁùÄÊàëÂ≠¶‰ºö‰∫ÜÁúãF12‚Ä¶) Âõõ.npm‰∏ãËΩΩË∂ÖÊÖ¢ÁöÑÈóÆÈ¢ò‰ΩøÁî®cnpm,ËøôÊòØÂõΩÂÜÖÁöÑ‰∏Ä‰∏™ÈïúÂÉè,ÈÄüÂ∫¶ÂæàÂø´,‰ΩÜÊó†Ê≥ï‰ΩøÁî®publishÈìæÊé•:https://npm.taobao.org/ ‰∫î.AlgoliaÊêúÁ¥¢Êê≠Âª∫ÁöÑÈóÆÈ¢ònextÁöÑ‰ΩøÁî®ÊñáÊ°£Â∑≤ÁªèÊØîËæÉÂÖ®Èù¢‰∫Ü Ëøô‰∏™Âú∞ÊñπË¶ÅÂä†‰∏ÄÂè• 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 ÂÖ∂Ê¨°Áî®export,ÊúÄÂ•Ω‰∏çË¶ÅÁî®set 12export HEXO_ALGOLIA_INDEXING_KEY=‰Ω†ÁöÑSearch-Only API Key$ hexo algolia Ëøô‰∫õÈÉΩÈÄâ‰∏ä ÂÖ≠.Â§¥ÂÉèÊóãËΩ¨‰ª•ÂèäÁÇπÂáªÂ§¥ÂÉèÂõûÂà∞‰∏ªÈ°µ ÂõûÂà∞‰∏ªÈ°µ:Âú®123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; Â∞±ÊòØÂú®‰ª£Á†Å‰∏ä‰∏ãÂàÜÂà´Âä†‰∫Ühref1232. ÊóãËΩ¨~~Ëøô‰∏™Êàë‰πü‰∏çÊáÇ~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl ÂÜÖÊ∑ªÂä†: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* Â§¥ÂÉèÂúÜÂΩ¢ */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* ËÆæÁΩÆÂæ™ÁéØÂä®Áîª [animation: (play)Âä®ÁîªÂêçÁß∞ (2s)Âä®ÁîªÊí≠ÊîæÊó∂ÈïøÂçï‰ΩçÁßíÊàñÂæÆÁßí (ase-out)Âä®ÁîªÊí≠ÊîæÁöÑÈÄüÂ∫¶Êõ≤Á∫ø‰∏∫‰ª•‰ΩéÈÄüÁªìÊùü (1s)Á≠âÂæÖ1ÁßíÁÑ∂ÂêéÂºÄÂßãÂä®Áîª (1)Âä®ÁîªÊí≠ÊîæÊ¨°Êï∞(infinite‰∏∫Âæ™ÁéØÊí≠Êîæ) ]*/ /* Èº†Ê†áÁªèËøáÂ§¥ÂÉèÊóãËΩ¨360Â∫¶ */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* Èº†Ê†áÁªèËøáÂÅúÊ≠¢Â§¥ÂÉèÊóãËΩ¨ -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* Èº†Ê†áÁªèËøáÂ§¥ÂÉèÊóãËΩ¨360Â∫¶ */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z ËΩ¥ÊóãËΩ¨Âä®Áîª */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; ÂÖàËøô‰∫õ,ÊåÅÁª≠Êõ¥Êñ∞]]></content>
      <categories>
        <category>ÊùÇÊñá</category>
      </categories>
      <tags>
        <tag>ÂçöÂÆ¢Êê≠Âª∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMPÁÆóÊ≥ïÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ËíüËíªÂ≠¶ËØÜÊµÖÈôã,Ê¨¢ËøéÂêÑ‰ΩçÂ§ßÁâõÊåáÊ≠£ KMP‰ªéÂÖ•Èó®Âà∞ÊîæÂºÉËØ∑ËßÇÂ∑¶Á•û‰∏∫‰ªÄ‰πàÊÉ≥Ë¶ÅÊùÄ‰∫∫%%%%njb7ÁùÄÈáçÂê¨1h12m20s$KMP$ÂàÜ‰∏∫‰∏§‰∏™ÈÉ®ÂàÜ,‰∏ÄÈÉ®ÂàÜ‰∏∫‰∏§‰∏™Â≠óÁ¨¶‰∏≤Èó¥ÁöÑÊØîËæÉ,Âè¶‰∏ÄÈÉ®ÂàÜ‰∏∫Ëá™Â∑±‰∏éËá™Â∑±ÁöÑÊØîËæÉ.ÁÆÄÂçïÁöÑÂàíÂàÜ‰∏∫‰∏ãÈù¢‰∏§‰∏™Âõæ,ËØ¶ÁªÜÁêÜËß£ËØ∑ËßÅÂ∑¶Á•û‰∏çÁ®≥ÂÆöÊÉÖÁª™ËÆ≤Ëß£.‰∏çËøáÊàë$jiao$ÁöÑÂú®$1:21:04$Êó∂,Â∞Ü‰æãÂ≠êÊç¢‰∏∫$‚Äùababcababak‚Äù$Êõ¥Â•ΩÁêÜËß£ ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; ‰æãÈ¢òG.OulipoHDU 1686The French author Georges Perec (1936‚Äì1982) once wrote a book, La disparition, without the letter ‚Äòe‚Äô. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s‚Äôaffirmait faux. Tout avait Fair normal, d‚Äôabord, puis surgissait l‚Äôinhumain, l‚Äôaffolant. Il aurait voulu savoir o√π s‚Äôarticulait l‚Äôassociation qui l‚Äôunissait au roman : stir son tapis, assaillant √† tout instant son imagination, l‚Äôintuition d‚Äôun tabou, la vision d‚Äôun mal obscur, d‚Äôun quoi vacant, d‚Äôun non-dit : la vision, l‚Äôavision d‚Äôun oubli commandant tout, o√π s‚Äôabolissait la raison : tout avait l‚Äôair normal mais‚Ä¶ Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given ‚Äúword‚Äù as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $‚ÄôT‚Äô$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$, with $1 ‚â§ |W| ‚â§ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$, with $|W| ‚â§ |T| ‚â§ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 Ëß£Êûê$kmp$Ê®°Êùø,ËØªÂÖ•‰∏çËÉΩÁî®$cin$,Âê¶ÂàôË∂ÖÊó∂ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]Âä®Áâ©Âõ≠]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[Â∫èË®Ä&emsp;&emsp;Ëøô‰∏™È¢òÂÜôÁöÑÊàëÂ•ΩËø∑Âïä== È¢òÁõÆÁÆÄËø∞&emsp;&emsp;Âõ≠ÈïøÊÉ≥ËÆ©‰Ω†Ê±Ç‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑ‚Äù‰∏ç‰∫íÁõ∏ÈáçÂè†ÁöÑÂÖ¨ÂÖ±ÂâçÂêéÁºÄ‰∏™Êï∞‚ÄùÁÑ∂ÂêéÂÜç‰πòËµ∑Êù•.‰∏ÄÂ§ßÈ™°Â≠êÁöÑÂ≠ó,ÊÄªÁªì‰∏Ä‰∏ãÂ∞±ÊòØËøô‰∏™ÊÑèÊÄù. Ëß£Êûê&emsp;&emsp;Â¶ÇÊûú‰Ω†‰∏ç‰ºö$KMP$‚Ä¶.ÈÇ£Êàë‰πüÊ≤°ÂäûÊ≥ï(Á¨ë)&emsp;&emsp;Êàë‰ª¨Áü•ÈÅì,$next$‰øùÂ≠òÁöÑÊòØÊúâÈáçÂè†ÈÉ®ÂàÜÁöÑÊúÄÂ§ßÈïøÂ∫¶.ÈÇ£‰πàÊàë‰ª¨Âú®ÂÆÉËÆ°ÁÆóÁöÑËøáÁ®ã‰∏≠,ÊääÂΩìÂâç$next[i]$ÁöÑ‰ΩçÁΩÆ,Â≠ò‰∏Ä‰∏™ÈïøÂ∫¶$cnt[i]$,Âï•ÊÑèÊÄù?&emsp;&emsp;Êàë$next[i]$‰ªéÂ§¥Êâ´Âà∞Â∞æ,Áõ∏ÂΩì‰∫é‰∏Ä‰∏™ÈÄíÊé®ÂæóÂà∞ÊúÄÂ§ßÈïøÂ∫¶.ÂêåÊó∂ËøõË°å$cnt[i]$‰ªéÂ§¥Êâ´Âà∞Â∞æ,Áõ∏ÂΩì‰∫éÈÄíÊé®ÂæóÂà∞ÊúÄÂ§ß‰∏™Êï∞.&emsp;&emsp;ÁÑ∂ÂêéÂÜçÁî®$next[]$Êï∞ÁªÑ,ÊâæÂà∞‰∏çÈáçÂ§çÁöÑ‰ΩçÁΩÆ,‰πüÂ∞±ÊòØ$j\leq{i/2}$ËøôÊ†∑ÁöÑ‰ΩçÁΩÆ,ËÆ°ÁÆó$cnt$,ÂÆåÊàê. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ÊçÆÁªìÊûÑ-ÂàíÂàÜÊ†ëÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÂºïÂ¶ÇÈ¢ò:POJ2014ÁªôÂÆö‰∏Ä$n$‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÁªÑ,ÊØèÊ¨°Êü•ËØ¢$[l,r]$Âå∫Èó¥ÂÜÖ‰ªéÂ∞èÂà∞Â§ßÁ¨¨k‰∏™Êï∞.Êú¥Á¥†Ëß£Ê≥ï‰∏∫Â∞ÜÊï∞ÁªÑ$[l,r]$ÂÜÖÁöÑÊï∞ÊéíÂ∫è,ÁÑ∂ÂêéÈÄâÊã©Á¨¨$k$‰∏™Âç≥ÂèØ.ÊúÄÂùèÊÉÖÂÜµ$O(m*n)$.Ëøô‰∏™Êó∂ÂÄô,Â∞±ÈúÄË¶ÅÊõ¥Â•ΩÁöÑÊï∞ÊçÆÁªìÊûÑ,ÂàíÂàÜÊ†ë/ÂΩíÂπ∂Ê†ë. ÂÆö‰πâÂéüÊï∞ÁªÑ‰∏∫${4,2,5,7,1,8,3,6}$,Âú®ÊØèÊ¨°ÂàíÂàÜÂ∑¶Âè≥Â≠êÊ†ëÊó∂ÁöÑ‰∏≠ÂÄº,ÈÉΩÁî®Á∫¢Ëâ≤Ë°®Êòé.Â∞è‰∫é‰∏≠ÂÄºÁöÑËøõÂÖ•Â∑¶Â≠êÊ†ë,Â§ß‰∫é‰∏≠ÂÄºÁöÑËøõÂÖ•Âè≥Â≠êÊ†ë.ËßÇÂØüÊàë‰ª¨ÂèëÁé∞,ÊØè‰∏ÄÂ±ÇÈÉΩÊòØÊï∞ÁªÑ$n$,Âè™‰∏çËøáÈ°∫Â∫èÊúâ‰∫ÜÂèòÂåñ.ËÄåÂØπ‰∫é$log2(1e9)$Ëøô‰∏™Êï∞,‰πü‰∏çËøá$20$.ÊâÄ‰ª•Êàë‰ª¨ÂÆö‰πâ‰∏Ä‰∏™$tree[20][n]$ÁöÑÊï∞ÁªÑ,Áî®Êù•Â≠òÊ†ë. 12//toleftÁ®çÂêéÂÜçËÆ≤int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; Âª∫Ê†ëÊàë‰ª¨ÂÆö‰πâ‰∏Ä‰∏™Êï∞ÁªÑ$toleft[20][MAXN]$,ÂÖ∂ÊåáÂú®ÊüêÊï∞ÁöÑÂ∑¶ËæπÊâÄÊúâËøõÂÖ•Â∑¶Â≠êÊ†ëÁöÑÊï∞ÁöÑ‰∏™Êï∞.toleftÊï∞ÁªÑ 123456789101112Á¨¨‰∏ÄÊ¨°ÂàíÂàÜ[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] Áúãi-thÂâçÈù¢ÊúâÂ§öÂ∞ë‰∏™Êï∞ËøõÂÖ•Â∑¶Â≠êÊ†ë.Á¨¨‰∫åÊ¨°ÂàíÂàÜ[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]Á¨¨‰∏âÊ¨°ÂàíÂàÜ[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]Á¨¨ÂõõÊ¨°ÂàíÂàÜ[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //sameÂÄºÊåáÁõ∏ÂêåÁöÑ‰∏≠ÂÄº if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //Â∞Ü[l,r]ÂÜÖÁöÑÊï∞ÂàíÂàÜ if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //ËÆ∞‰∏ãÂΩìÂâçÊï∞ÁöÑtoleftÂÄº &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; Êü•ËØ¢Á±ª‰ºº‰∫éÁ∫øÊÆµÊ†ëÁöÑÂçïÁÇπÊü•ËØ¢Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™‰∏çÁ≠âÂºè$toleft[dep][r] - toleft[dep][l - 1]\leq k$Â¶ÇÊûúÊàêÁ´ã,ËØ¥ÊòéËøô‰∏™Êï∞Ë¢´ÂàíËøõ‰∫ÜÂ∑¶Â≠êÊ†ë.ÈÇ£‰πàÂ§ßÂå∫Èó¥$[L,(L+R)&gt;&gt;1]$,Â∞èÂå∫Èó¥$[l,r]$Âèò‰∏∫$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$Â¶ÇÊûú$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$ÈÇ£‰πà,Ëøô‰∏™Êï∞Â∞±Ë¢´ÂàíËøõ‰∫ÜÂè≥Â≠êÊ†ë,ÈÇ£‰πàÂ§ßÂå∫Èó¥Âèò‰∏∫$[(L+R)&gt;&gt;1+1,R]$,Â∞èÂå∫Èó¥Âèò‰∏∫$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.ËøôÊ†∑‰∏çÊñ≠ÈÄíÂΩí,ÂΩìÂ∞èÂå∫Èó¥$l==r$Êó∂,‰æøÁ°ÆÂÆö‰∫Ü‰ªéÂ∞èÂà∞Â§ßÁ¨¨$k$‰∏™Êï∞ÊòØÂá†. 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; ÂÆåÊï¥‰ª£Á†ÅÂΩìÊÉ≥Êü•ËØ¢‰ªéÂ§ßÂà∞Â∞èÁ¨¨$k$‰∏™Êï∞,ÂàôÂ∞Ü(tree[dep][i] < sorted[mid])```Êîπ‰∏∫```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```Êîπ‰∏∫‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÂç≥ÂèØ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; ÁªÉ‰π†È¢òÁõÆÊ¥õË∞∑P2048]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÂàíÂàÜÊ†ë</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ÊçÆÁªìÊûÑ-Á∫øÊÆµÊ†ëÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Ê¨¢ËøéÂêÑÂ§ß‰Ω¨ÔºåÂ§ßÁâõÂØπÊú¨ÊñáÊåáÊ≠£Ôºå‰πüÂ∏åÊúõÊú¨ÊñáËÉΩÂØπÂêÑ‰ΩçÊúâÊâÄÂ∏ÆÂä© Êú¨ÁØáÂæàÂ§öÂú∞ÊñπÂÄüÈâ¥Ëã±ÈõÑÂì™ÈáåÂá∫Êù•ÁöÑÂçöÂÆ¢%%% ‰∏Ä„ÄÅÂü∫Êú¨Ê¶ÇÂøµ Á∫øÊÆµÊ†ëÊòØ‰∏ÄÊ£µ‰∫åÂèâÊêúÁ¥¢Ê†ëÔºåÂÆÉÂÇ®Â≠òÁöÑÊòØ‰∏Ä‰∏™Âå∫Èó¥ÁöÑ‰ø°ÊÅØ„ÄÇ ÊØè‰∏™ËäÇÁÇπ‰ª•ÁªìÊûÑ‰ΩìÁöÑÊñπÂºèÂ≠òÂÇ®ÔºåÁªìÊûÑ‰ΩìÂåÖÂê´‰ª•‰∏ãÂá†‰∏™‰ø°ÊÅØÔºöÊØè‰∏™ËäÇÁÇπ‰ª•ÁªìÊûÑ‰ΩìÁöÑÊñπÂºèÂ≠òÂÇ®ÔºåÁªìÊûÑ‰ΩìÂåÖÂê´‰ª•‰∏ãÂá†‰∏™‰ø°ÊÅØÔºö (1). Âå∫Èó¥Â∑¶Á´ØÁÇπ„ÄÅÂè≥Á´ØÁÇπ (2). Âå∫Èó¥ÊâÄ‰ª£Ë°®ÁöÑÂÄº (3). ËØ•ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ Á∫øÊÆµÊ†ëÁöÑÂü∫Êú¨ÊÄùÊÉ≥Ôºö‰∫åÂàÜ„ÄÇ Á∫øÊÆµÊ†ë‰∏ÄËà¨ÁªìÊûÑÂ¶ÇÂõæÊâÄÁ§∫ÔºöÂÅáËÆæÊï∞ÊçÆ‰∏∫4‰∏™Êï∞ÔºåÂàôÊ†ëÂ∫îÊòØËøôÊ†∑ Áî±‰∏äÂõæÂèØÁü•ÔºåÊØè‰∏™ËäÇÁÇπÁöÑ ÊØè‰∏™ËäÇÁÇπÁöÑÂ∑¶Â≠©Â≠êÂå∫Èó¥ËåÉÂõ¥‰∏∫[leftÔºåmid]ÔºåÂè≥Â≠©Â≠ê‰∏∫[mid+1,right] ‰∫å„ÄÅ‰ª£Á†ÅÂÆûÁé∞‰∏éÂü∫Êú¨Êìç‰Ωú0.Âü∫Á°ÄÊï∞ÊçÆÁªìÊûÑ123456789#ifndef NULL //Èò≤Êä•Èîô#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.Âª∫Ê†ë builtÂáΩÊï∞12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,cÁî®Ê≥ï //Áî≥ËØ∑‰∏Ä‰∏™Êñ∞ÂÜÖÂ≠òÔºåÂπ∂‰ª§pÊåáÂêëËØ•Â§Ñ p-&gt;left = left; //ÂÇ®Â≠òÂå∫Èó¥‰ø°ÊÅØ p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,ÁöÜÂèØÔºåÂèäÂÇ®Â≠òÊï∞ÊçÆ p-&gt;lson = NULL; //‰ª§Â∑¶ÂÑøÂ≠êÂíåÂè≥ÂÑøÂ≠êÊåáÂêëNULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //‰∫åÂàÜ p-&gt;lson = built(left, mid); //Â∑¶ÂÑøÂ≠ê p-&gt;rson = built(mid + 1, right); //Âè≥ÂÑøÂ≠ê p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //Â≠òÂÇ®Â∑¶ÂÑøÂ≠êÂíåÂè≥ÂÑøÂ≠êÁöÑÂíå &#125; return p; //ËøîÂõûÊåáÂêëËØ•Â§ÑÁöÑÊåáÈíà&#125; &emsp;&emsp;Èô§‰∫ÜÂª∫Ê†ëÔºåÁõ∏Â∫îÂÖ≥Èó≠Ê†ëÁöÑÂáΩÊï∞‰∏∫Ôºö 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cÁî®Ê≥ï &#125; return;&#125; &emsp;ÈùûÂ∏∏ÈúÄË¶ÅÊ≥®ÊÑèÁöÑ‰∏Ä‰ª∂‰∫ãÔºåÊØèÊ¨°Áî®ÊåáÈíàÂª∫Á´ãÊ†ëÁöÑÊó∂ÂÄôÔºåËØ∑Âä°ÂøÖÂÜô‰∏Ä‰∏™ÂÖ≥Èó≠Ê∏ÖÁêÜÁî≥ËØ∑ÁöÑÂÜÖÂ≠òÁöÑÂáΩÊï∞ 2. ÂçïÁÇπÊü•ËØ¢&emsp;&emsp;(1).Êü•Êâæk‰ΩçÁΩÆÁöÑÊï∞ÊçÆ 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.ÂçïÁÇπ‰øÆÊîπ&emsp;&emsp;(1).Áü•ÈÅìÁÇπÊâÄÂú®‰ΩçÁΩÆÔºå‰øÆÊîπËØ•ÁÇπÂ§ÑÂÄº 123456789int update(Node p, int x,int k) //ÂØπx‰ΩçÁΩÆÁöÑÂÄºÔºåËøõË°åkÂÄºÁöÑÂèòÂä®&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //Â¶ÇËøáÊâæÂà∞‰∫Ük‰ΩçÁΩÆ return p-&gt;d +=k; //ÂØπËØ•ÁÇπÂÄºËøõË°åÊìç‰ΩúÔºåÂèØ‰ª•‰∏∫+-*/Á≠â int mid = (p-&gt;left + p-&gt;right) / 2; //Âà§Êñ≠ËØ•ÁÇπÂú®Â∑¶Âå∫Èó¥ËøòÊòØÂè≥Âå∫Èó¥ if (x &lt;= mid) //Â¶ÇÊûúÊòØÂ∑¶Âå∫Èó¥ÔºåÂè™ÂØπÂ∑¶Âå∫Èó¥ËøõË°åÈÄíÂΩíÊü•ËØ¢ return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //Êü•ÊâæÂÆåÂêéÂØπÁà∂ËäÇÁÇπÂ≠òÂÇ®ÂÄºËøõË°å‰øÆÊîπ return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //‰∏çÊòØËØ•ÁÇπÔºå‰πü‰∏çÂú®Â∑¶Âå∫Èó¥ÔºåÂè™ËÉΩÊòØÂè≥Âå∫Èó¥&#125; 4.Âå∫Èó¥Êü•ËØ¢&emsp;&emsp;ÊâÄÁªôÂå∫Èó¥‰ªÖÂèØËÉΩ‰∏∫‰∏äÂõæÂõõÁßçÊÉÖÂÜµ„ÄÇ&emsp;&emsp;ÈÄöËøá‰∏ÄÂÆöÊìç‰ΩúÔºåÊàë‰ª¨ÈÉΩÂèØ‰ª•Â∞Ü‰∏ä‰∏âÁßçÔºåÂÖ®ÈÉ®ËΩ¨Êç¢‰∏∫ÊúÄÂêé‰∏ÄÁßçÁõ¥Êé•ËæìÂá∫„ÄÇ&emsp;&emsp;Èó≤ËØùÂ∞ëËØ¥Ôºå‰ª£Á†ÅÂÆûÁé∞ 12345678910111213int find(Node p, int x,int y) //Ê≥®ÔºåËøôÈáåÂÅáËÆæ‰ªªÊÑèx,yÔºåÈÉΩÊúâx&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //Â¶ÇÊûúÊòØÁ¨¨ÂõõÁßçÊÉÖÂÜµÔºåÁõ¥Êé•ËøîÂõû return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //Ê±Ç‰∏≠Èó¥ÂÄº if (y &lt;= mid) //Â¶ÇÊûúÊü•ËØ¢Âå∫Èó¥Âú®midÂ∑¶ËæπÔºåÂõ†‰∏∫x&lt;y&lt;=mid return find(p-&gt;lson, x, y); //ÈÇ£‰πàÁõ¥Êé•ÈÄíÂΩíÂ∑¶ÂÑøÂ≠ê if (x &gt; mid) //Â¶ÇÊûúÊü•ËØ¢Âå∫Èó¥Âú®midÂè≥ËæπÔºåÂõ†‰∏∫mid&lt;x&lt;y return find(p-&gt;rson, x, y); //ÈÇ£‰πàÁõ¥Êé•ÈÄíÂΩíÂè≥ÂÑøÂ≠ê return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //‰∏§ÂºèÈÉΩ‰∏çÁ¨¶ÂêàÔºåÂèäx&lt;=mid&lt;y //Âàô‰ªémid‰∏∫‰∏≠Èó¥ÂÄºÂàÜÂºÄ //Â∑¶ÂÑøÂ≠êÊü•ËØ¢[x,mid],Âè≥ÂÑøÂ≠êÊü•ËØ¢[mid+1,y]&#125; 5.Âå∫Èó¥‰øÆÊîπ1234567891011int update(Node p, int x, int y, int k) //ËÆæÂå∫Èó¥‰∏∫[x,y]Ôºå‰øÆÊîπÁöÑÂÄº‰∏∫k&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //Â¶ÇÊûúÊòØËøô‰∏™Âå∫Èó¥ÂÜÖÁöÑÂÖÉÁ¥†ÔºåÂ∞±ËÆ©ÂÆÉ+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //‰∫åÂàÜ if (y &lt;= mid) //Â¶ÇÊûúÂå∫Èó¥Âú®‰∏≠ÂÄºÁöÑÂ∑¶‰æß return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //‰ªÖÈúÄÊõ¥Êñ∞Â∑¶ÂÑøÂ≠êÁöÑÂÄºÔºåÂπ∂Êõ¥Êñ∞Áà∂‰∫≤ÁöÑÂÄº if (x &gt; mid) //Â¶ÇÊûúÂå∫Èó¥Âú®‰∏≠ÂÄºÁöÑÂ∑¶‰æß return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //Âêå‰∏ä return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //Â¶ÇÊûúÂå∫Èó¥Ë¢´‰∏≠ÂÄºÂàÜÂºÄ&#125; ‰∏â.‰ºòÂåñÔºà‰∏ÄÔºâ. Lazy-TagÊáíÊ†áËÆ∞&emsp;&emsp;Êàë‰ª¨ËÄÉËôë‰∏Ä‰∏ãÂå∫Èó¥ÊîπÂÄºÁöÑËøáÁ®ãÔºöÂΩìÊõ¥ÊîπÊüê‰∏™Âå∫Èó¥ÁöÑÂÄºÁöÑÊó∂ÂÄôÔºåÂ≠êÂå∫Èó¥‰πüË∑üÁùÄÊõ¥Êîπ„ÄÇÊòæÁÑ∂ÔºåÂú®Â§ßÊï∞ÊçÆ‰∏ãÔºåËøôÊ†∑Êìç‰Ωú‰ºöÂØºËá¥TLE„ÄÇ&emsp;&emsp;ÊÄé‰πàÂäûÔºü&emsp;&emsp;ËøôÊó∂Êàë‰ª¨Â∞±ÂºïÂÖ•‰∏Ä‰∏™‰ºòÂåñÊñπÊ≥ïÔºåÂè´ÂÅöLazy-TagÊáíÊ†áËÆ∞„ÄÇ&emsp;&emsp;‰Ωï‰∏∫ÊáíÊ†áËÆ∞Âë¢ÔºüÈ°æÂêçÊÄù‰πâÔºåÂ∞±ÊòØÁî®Êù•ÂÅ∑ÊáíÁöÑÂáèÂ∞ë‰øÆÊîπÊó∂Ê∂àËÄóÊó∂Èó¥ÁöÑ„ÄÇÂç≥Ôºö&emsp;&emsp;ÂΩìÊàëÊÉ≥Ë¶ÅÂØπÊüê‰∏ÄÂå∫Èó¥ÁöÑÊâÄÊúâÂÖÉÁ¥†ÈÉΩ+kÊó∂ÔºåÂú®‰øÆÊîπËØ•Âå∫Èó¥ËäÇÁÇπÊó∂ÔºåÂØπÂÖ∂Êâì‰∏äÊ†áËÆ∞lazyÔºåÂπ∂ËÆ∞lazy‰∏∫kÔºå‰øÆÊîπËØ•ËäÇÁÇπÁöÑÂÄº‰∏∫+Âå∫Èó¥ÈïøÂ∫¶*kÔºåÁ´ãÂàªreturnÔºåËÄå‰∏çÂ∞ÜËØ•ËäÇÁÇπ‰∏ãÈù¢ÁöÑÊâÄÊúâÂ≠êËäÇÁÇπ‰∏Ä‰∏Ä‰øÆÊîπ„ÄÇ ÊÄùÊÉ≥ÂÆûÁé∞&emsp;&emsp;Â¶ÇÂõæÁ§∫Ôºö1~4ÁöÑÂÄºÂàÜÂà´‰∏∫1Ôºå2Ôºå3Ôºå4&emsp;&emsp;Êàë‰ª¨ÈÄâÊã©ÂØπ[1,2]Âå∫Èó¥ËøõË°å‰øÆÊîπÔºåË¶ÅÊ±ÇÊîπÂå∫Èó¥ÊâÄÊúâÂÄº+2ÔºåÂàôÔºöÂú®Âå∫Èó¥[1,2]ÔºåÊâì‰∏äÊ†áËÆ∞lazy=2ÔºåÂπ∂‰øÆÊîπÂÖ∂ÂÄº‰∏∫3+(2-1+1)2ÔºåÁõ¥Êé•ËøîÂõûÔºåÂπ∂‰∏çÂØπÂÖ∂Â≠êËäÇÁÇπËøõË°å‰øÆÊîπ&emsp;&emsp;ÂΩìÊàë‰ª¨ÂÜçÊ¨°ÂØπ[1,2]Âå∫Èó¥‰øÆÊîπÊó∂ÔºåÂπ∂Ë¶ÅÊ±ÇÂå∫Èó¥ÂÜÖÊâÄÊúâÁöÑÂÄº+1ÔºåÂàôÔºöÁî±‰∫é[1,2]ÊúâÊ†áËÆ∞lazy=2Ôºå‰∫éÊòØÊàë‰ª¨Â∞ÜlazyÊ†áËÆ∞ÂêëÂÖ∂Â≠êËäÇÁÇπ‰º†ÂØºÔºåÂπ∂‰øÆÊîπÂÖ∂Â≠êËäÇÁÇπÁöÑÂÄº„ÄÇÂÜçÂú®[1,2]Âå∫Èó¥Êâì‰∏älazy=1Ôºå‰øÆÊîπÂÄº‰∏∫(2-1+1)1ÔºåËøîÂõû„ÄÇ ‰ª£Á†ÅÂÆûÁé∞0.Ê†∏ÂøÉ‰ª£Á†Å pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //Â¶ÇÊûúËØ•ËäÇÁÇπËøòÊúâÂêéÁª≠ËäÇÁÇπ p-&gt;lson-&gt;lazy += p-&gt;lazy; //‰ª§Â≠êËäÇÁÇπlazyÁªßÊâøÁà∂ËäÇÁÇπlazyÔºå‰∏ãÂêå p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //‰øÆÊîπÂ≠êËäÇÁÇπÁöÑÂÄºÔºå‰∏ãÂêå p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //‰ª§ËØ•ËäÇÁÇπÁöÑlazyÊ∏ÖÈõ∂&#125; 1.Ê†ëÊú¨‰Ωì123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //‰ªÖ‰ªÖÂ§ö‰∫Ü‰∏Ä‰∏™lazyÊ†áËÆ∞ int left, right; Node lson, rson;&#125;*root; 2.Âª∫Ê†ë12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //Âè™ÊòØÂØπlazyÊ†áËÆ∞ËøõË°åÂàùÂßãÂåñ if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cÁî®Ê≥ï &#125; return;&#125; 3.ÂçïÁÇπÊü•ËØ¢ÂíåÂçïÁÇπ‰øÆÊîπÊó†ÊîπÂèò4.Âå∫Èó¥Êü•ËØ¢12345678910111213long long find(Node p, int x, int y) //Âå∫Èó¥Êü•ËØ¢&#123; if (p-&gt;lazy != 0) //Ëß£ÂÜ≥‰∏Ä‰∏ãÂéÜÂè≤ÈÅóÁïôÈóÆÈ¢òÂÜçÊü•ËØ¢ pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //ÂÖ∂‰ªñÊú™Âèò return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.Âå∫Èó¥‰øÆÊîπ123456789101112131415int update(Node p, int x, int y, int k) //Âå∫Èó¥‰øÆÊîπ&#123; if (p-&gt;lazy!=0) //Â¶ÇÊûúËØ•ËäÇÁÇπÁöÑlazy‰∏ç‰∏∫Èõ∂ÔºåÂ∞±Â§ÑÁêÜ‰∏Ä‰∏ã pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //Â¶ÇÊûúÊòØË¶ÅËøõË°å‰øÆÊîπÁöÑËäÇÁÇπÔºå‰æøËÆ©ËØ•ËäÇÁÇπÁöÑlazy‰∏∫kÔºåÂπ∂‰øÆÊîπÂÄº p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; Ôºà‰∫åÔºâ. Á¶ªÊï£Âåñ&emsp;&emsp;Á¶ªÊï£ÂåñÊòØ‰∏Ä‰∏™Âê¨Ëµ∑Êù•ÂæàÈ´òÂ§ß‰∏äÁöÑÊñπÊ≥ï.&emsp;&emsp;ÂÖ∂ÂÆûÂÅöËµ∑Êù•ÂæàÁÆÄÂçï.ÂΩìÁÑ∂Â¶ÇÊûúÊÉ≥È´òÊ∑±ÁöÑËØù,Ëá™ÁÑ∂‰πüÊã¶‰∏ç‰Ωè&emsp;&emsp;ÂÖ∂ÂÆûÂ∞±ÊòØÂ∞Ü‰∏Ä‰∏≤Êï∞ÊçÆÂÇ®Â≠òÂà∞Êï∞ÁªÑ‰∏≠,‰∏çÂ∞ÜÊï∞ÊçÆÊú¨Ë∫´‰Ωú‰∏∫ÈîÆÂÄº,ËÄåÊòØÈÄâÊã©‰ΩøÁî®Êï∞ÁªÑÁöÑ‰∏ãÊ†á‰Ωú‰∏∫ÈîÆÂÄº.&emsp;&emsp;ÂΩ¢Ë±°ÁöÑ,$1,2,3,10000000$ËøôÂõõ‰∏™Êï∞,‰øùÂ≠òÂú®Êï∞ÁªÑ$a[]$‰∏≠,Áõ∏ÂØπÂ∫îÁöÑ‰∏ãÊ†á‰∏∫$1,2,3,4$Â∞±ÂèØ‰ª•ÂáèÂ∞ëÁ©∫Èó¥ÁöÑÂºÄÊîØ. Êï∞ÁªÑÂÆûÁé∞1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 1e5 + 10;typedef long long ll;struct Segment_Tree &#123; ll d, lazy; int left, right; int lson, rson;&#125;root[4 * MAXN];int n;void built(int p, int left, int right)&#123; root[p].left = left; root[p].right = right; root[p].lazy = 0; if (left == right) &#123; cin &gt;&gt; root[p].d; root[p].lson = root[p].rson = null; &#125; else &#123; int mid = (left + right) &gt;&gt; 1; built(root[p].lson = (p &lt;&lt; 1), left, mid); built(root[p].rson = (p &lt;&lt; 1 | 1), mid + 1, right); root[p].d = root[root[p].lson].d + root[root[p].rson].d; &#125;&#125;void pushdown(int p)&#123; if (root[p].lson != null) &#123; root[root[p].lson].lazy += root[p].lazy; root[root[p].lson].d += (root[root[p].lson].right - root[root[p].lson].left + 1)*root[p].lazy; root[root[p].rson].lazy += root[p].lazy; root[root[p].rson].d += (root[root[p].rson].right - root[root[p].rson].left + 1)*root[p].lazy; &#125; root[p].lazy = 0;&#125;ll find(int p, int x, int y)&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) return root[p].d; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return find(root[p].lson, x, y); if (x &gt; mid) return find(root[p].rson, x, y); return find(root[p].lson, x, mid) + find(root[p].rson, mid + 1, y);&#125;long long update(int p, int x, int y, int k) //Âå∫Èó¥&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) &#123; root[p].lazy = k; return root[p].d += k * (y - x + 1); &#125; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return root[p].d = root[root[p].rson].d + update(root[p].lson, x, y, k); if (x &gt; mid) return root[p].d = root[root[p].lson].d + update(root[p].rson, x, y, k); return root[p].d = update(root[p].lson, x, mid, k) +update(root[p].rson, mid+1, y, k);&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; built(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int t, x, y, k; cin &gt;&gt; t; if (t == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1, x, y, k); &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; find(1, x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; ÁªÉ‰π†È¢òÁõÆÊ¥õË∞∑P2251Ë£∏ÁöÑRMQÈóÆÈ¢ò,Êï∞ÊçÆÈáèÂ∞è.Ê¥õË∞∑P3372Ê¥õË∞∑P3373Ê¥õË∞∑Á∫øÊÆµÊ†ëÊ®°ÊùøÈ¢ò]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]È≠îÊ≥ïÊ£ÆÊûó]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[Â∫èË®Ä$UOJ$ÊûúÁÑ∂ÊòØÁ•û‰ªô$OJ$ÂïäÈáåÈù¢‰∏™‰∏™ÈÉΩÊòØ‰∫∫Êâç,ËØ¥ËØùËøòÂ•ΩÂê¨È¢òÁõÆÁöÑ$hack$Êï∞ÊçÆËøòÂèØ‰ª•$hack$ÊéâÁΩë‰∏ä‰∏ÄÂ§ßÁâáÁöÑÈ¢òËß£‚Ä¶.. È¢òÁõÆÊèèËø∞‰∏∫‰∫ÜÂæóÂà∞‰π¶Ê≥ïÂ§ßÂÆ∂ÁöÑÁúü‰º†ÔºåÂ∞è$E$ÂêåÂ≠¶‰∏ãÂÆöÂÜ≥ÂøÉÂéªÊãúËÆø‰ΩèÂú®È≠îÊ≥ïÊ£ÆÊûó‰∏≠ÁöÑÈöêÂ£´„ÄÇÈ≠îÊ≥ïÊ£ÆÊûóÂèØ‰ª•Ë¢´ÁúãÊàê‰∏Ä‰∏™ÂåÖÂê´‰∏™$N$ËäÇÁÇπ$M$Êù°ËæπÁöÑÊó†ÂêëÂõæÔºåËäÇÁÇπÊ†áÂè∑‰∏∫$1‚Ä¶n$ÔºåËæπÊ†áÂè∑‰∏∫$1‚Ä¶m$„ÄÇÂàùÂßãÊó∂Â∞è$E$ÂêåÂ≠¶Âú®$1$ Âè∑ËäÇÁÇπÔºåÈöêÂ£´Âàô‰ΩèÂú® $n$ Âè∑ËäÇÁÇπ„ÄÇÂ∞è$E$ÈúÄË¶ÅÈÄöËøáËøô‰∏ÄÁâáÈ≠îÊ≥ïÊ£ÆÊûóÔºåÊâçËÉΩÂ§üÊãúËÆøÂà∞ÈöêÂ£´„ÄÇÈ≠îÊ≥ïÊ£ÆÊûó‰∏≠Â±Ö‰Ωè‰∫Ü‰∏Ä‰∫õÂ¶ñÊÄ™„ÄÇÊØèÂΩìÊúâ‰∫∫ÁªèËøá‰∏ÄÊù°ËæπÁöÑÊó∂ÂÄôÔºåËøôÊù°Ëæπ‰∏äÁöÑÂ¶ñÊÄ™Â∞±‰ºöÂØπÂÖ∂ÂèëËµ∑ÊîªÂáª„ÄÇÂπ∏ËøêÁöÑÊòØÔºåÂú® $1$ Âè∑ËäÇÁÇπ‰ΩèÁùÄ‰∏§ÁßçÂÆàÊä§Á≤æÁÅµÔºö$A$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏é$B$ÂûãÂÆàÊä§Á≤æÁÅµ„ÄÇÂ∞è$E$ÂèØ‰ª•ÂÄüÂä©ÂÆÉ‰ª¨ÁöÑÂäõÈáèÔºåËææÂà∞Ëá™Â∑±ÁöÑÁõÆÁöÑ„ÄÇÂè™Ë¶ÅÂ∞èEÂ∏¶‰∏äË∂≥Â§üÂ§öÁöÑÂÆàÊä§Á≤æÁÅµÔºåÂ¶ñÊÄ™‰ª¨Â∞±‰∏ç‰ºöÂèëËµ∑ÊîªÂáª‰∫Ü„ÄÇÂÖ∑‰ΩìÊù•ËØ¥ÔºåÊó†ÂêëÂõæ‰∏≠ÁöÑÊØè‰∏ÄÊù°Ëæπ $e_i$ ÂåÖÂê´‰∏§‰∏™ÊùÉÂÄº $a_i$ ‰∏é $b_i$„ÄÇËã•Ë∫´‰∏äÊê∫Â∏¶ÁöÑ$A$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏™Êï∞‰∏çÂ∞ë‰∫é $a_i$Ôºå‰∏î$B$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏™Êï∞‰∏çÂ∞ë‰∫é $b_i$ÔºåËøôÊù°Ëæπ‰∏äÁöÑÂ¶ñÊÄ™Â∞±‰∏ç‰ºöÂØπÈÄöËøáËøôÊù°ËæπÁöÑ‰∫∫ÂèëËµ∑ÊîªÂáª„ÄÇÂΩì‰∏î‰ªÖÂΩìÈÄöËøáËøôÁâáÈ≠îÊ≥ïÊ£ÆÊûóÁöÑËøáÁ®ã‰∏≠Ê≤°Êúâ‰ªªÊÑè‰∏ÄÊù°ËæπÁöÑÂ¶ñÊÄ™ÂêëÂ∞è$E$ÂèëËµ∑ÊîªÂáªÔºå‰ªñÊâçËÉΩÊàêÂäüÊâæÂà∞ÈöêÂ£´„ÄÇÁî±‰∫éÊê∫Â∏¶ÂÆàÊä§Á≤æÁÅµÊòØ‰∏Ä‰ª∂ÈùûÂ∏∏È∫ªÁÉ¶ÁöÑ‰∫ãÔºåÂ∞èEÊÉ≥Ë¶ÅÁü•ÈÅìÔºåË¶ÅËÉΩÂ§üÊàêÂäüÊãúËÆøÂà∞ÈöêÂ£´ÔºåÊúÄÂ∞ëÈúÄË¶ÅÊê∫Â∏¶ÂÆàÊä§Á≤æÁÅµÁöÑÊÄª‰∏™Êï∞„ÄÇÂÆàÊä§Á≤æÁÅµÁöÑÊÄª‰∏™Êï∞‰∏∫$A$ÂûãÂÆàÊä§Á≤æÁÅµÁöÑ‰∏™Êï∞‰∏é$B$ÂûãÂÆàÊä§Á≤æÁÅµÁöÑ‰∏™Êï∞‰πãÂíå„ÄÇ È¢òÁõÆÂ§ßÊÑè:‰ªé$1$Ëµ∞Âà∞$n$,$m$Êù°Ëæπ,Â¶Ç‰ΩïËµ∞ËÉΩ‰Ωø$a$Âíå$b$ÁöÑÂíåÊúÄÂ§ßÂÄºÊúÄÂ∞è. Ëß£ÊûêÈ¶ñÂÖà,ËøôÊòØ‰∏Ä‰∏™ÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑÈ¢òÁõÆ.ÂÖ∂Ê¨°,ËøôÂ∫îËØ•ÊòØ‰∏Ä‰∏™Âä®ÊÄÅÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑÈ¢òÁõÆ.(Â¶ÇÊûú‰Ω†Â≠¶ËøáÁî®LCTÂÅöÊúÄÂ∞èÁîüÊàêÊ†ë,Ëøô‰∏™È¢òÂ∞±ÈùûÂ∏∏ÁöÑÊ∞¥)Êàë‰ª¨Â∞Ü$a_i$ÊéíÂ∫èÂêé,ÊåâËæπÂèñ,ÂèØ‰ª•‰øùËØÅ$a_i$ÊòØÊúÄÂ∞èÁöÑ.Âú®Êåâ$a_i$Â§ßÂ∞èÂèñËæπÁöÑÊó∂ÂÄô,ÂêåÊó∂Êõ¥Êñ∞Ë∑Ø‰∏ä$b_i$ÁöÑÊúÄÂ§ßÂÄº.ÂΩìÊàë‰ª¨ÂèñÂà∞‰∏Ä‰∏™ÁéØÁöÑÊó∂ÂÄôÊÄé‰πàÂäû?ÂàóÂ¶ÇËøôÊ†∑:Êàë‰ª¨Â∞±Ë¶ÅÂØπÊñ∞Âä†ÂÖ•ÁöÑËæπ‰∏ä$b_i$ÁöÑÂÄº,ÂíåÁª¥Êä§ÁöÑÈìæ‰∏ä$b_i$ÁöÑÊúÄÂ§ßÂÄºËøõË°åÊØîËæÉ. Â¶ÇÊûúÈìæ‰∏äÁöÑÂÄºÂ§ß,ÈÇ£‰πàÊàë‰ª¨ÊääÈìæ‰∏äÊúÄÂ§ßÁöÑÈÇ£Êù°Ëæπ$cut$,Â¶Ç‰ΩïÊääÊñ∞ËæπËøû‰∏ä. Â¶ÇÊûúÊñ∞ËæπÂ§ß,Êàë‰ª¨‰æøÁõ¥Êé•Ë∑≥Ëøá. Â¶ÇÊ≠§ÂæÄÂ§ç,Áõ¥Âà∞$1$$n$ËøôÊù°Ë∑ØËøûÈÄö.ËøûÈÄöÂêé,Êàë‰ª¨Âä†ÂÖ•Âè¶‰∏Ä‰∏™Êìç‰Ωú:Âà§Êñ≠,Âä†ÂÖ•ÁöÑËøôÊù°ËæπÂØπ‰∫éÁ≠îÊ°àÁöÑÂΩ±Âìç.$a$Â§ßÂπ∂‰∏ç‰ª£Ë°®$b$‰πüÂ§ß,Âõ†‰∏∫ÈóÆÁöÑÊòØ$a+b$ÁöÑÂíå.Áõ¥Âà∞ÈÅçÂéÜÂÆåÊâÄÊúâËæπ.~Ëøá‰∫ÜÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑ‰ª£Á†ÅÂ±ÖÁÑ∂Âè™Êúâ97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]Ëµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóá]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[ÊèèËø∞ ÈìæÊé•:http://uoj.ac/problem/2 21 ‰∏ñÁ∫™ÔºåËÆ∏Â§ö‰∫∫Âæó‰∫Ü‰∏ÄÁßçÂ•áÊÄ™ÁöÑÁóÖÔºöËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóáÔºåÂÖ∂‰∏¥Â∫äË°®Áé∞‰∏∫ÔºöËµ∑Â∫äÈöæÔºåËµ∑Â∫äÂêéÁ≤æÁ•û‰∏ç‰Ω≥„ÄÇ‰Ωú‰∏∫‰∏ÄÂêçÈùíÊò•Èò≥ÂÖâÂ•ΩÂ∞ëÂπ¥Ôºåatm ‰∏ÄÁõ¥ÂùöÊåÅ‰∏éËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóá‰ΩúÊñó‰∫â„ÄÇÈÄöËøáÁ†îÁ©∂Áõ∏ÂÖ≥ÊñáÁåÆÔºå‰ªñÊâæÂà∞‰∫ÜËØ•ÁóÖÁöÑÂèëÁóÖÂéüÂõ†ÔºöÂú®Ê∑±ÈÇÉÁöÑÂ§™Âπ≥Ê¥ãÊµ∑Â∫ï‰∏≠ÔºåÂá∫Áé∞‰∫Ü‰∏ÄÊù°Âêç‰∏∫ drd ÁöÑÂ∑®ÈæôÔºåÂÆÉÊéåÊè°ÁùÄÁù°Áú†‰πãÁ≤æÈ´ìÔºåËÉΩÈöèÊÑèÂª∂ÈïøÂ§ßÂÆ∂ÁöÑÁù°Áú†Êó∂Èó¥„ÄÇÊ≠£ÊòØÁî±‰∫é drd ÁöÑÊ¥ªÂä®ÔºåËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóáÊÑàÊºîÊÑàÁÉàÔºå‰ª•ÊÉä‰∫∫ÁöÑÈÄüÂ∫¶Âú®‰∏ñÁïå‰∏ä‰º†Êí≠„ÄÇ‰∏∫‰∫ÜÂΩªÂ∫ïÊ∂àÁÅ≠ËøôÁßçÁóÖÔºåatm ÂÜ≥ÂÆöÂâçÂæÄÊµ∑Â∫ïÔºåÊ∂àÁÅ≠ËøôÊù°ÊÅ∂Èæô. ÂéÜÁªèÂçÉËæõ‰∏áËã¶Ôºåatm Áªà‰∫éÊù•Âà∞‰∫Ü drd ÊâÄÂú®ÁöÑÂú∞ÊñπÔºåÂáÜÂ§á‰∏éÂÖ∂Â±ïÂºÄËâ∞Ëã¶ÂçìÁªùÁöÑÊàòÊñó„ÄÇdrd ÊúâÁùÄÂçÅÂàÜÁâπÊÆäÁöÑÊäÄËÉΩÔºå‰ªñÁöÑÈò≤Âæ°ÊàòÁ∫øËÉΩÂ§ü‰ΩøÁî®‰∏ÄÂÆöÁöÑËøêÁÆóÊù•ÊîπÂèò‰ªñÂèóÂà∞ÁöÑ‰º§ÂÆ≥„ÄÇÂÖ∑‰ΩìËØ¥Êù•Ôºådrd ÁöÑÈò≤Âæ°ÊàòÁ∫øÁî± $n$ ÊâáÈò≤Âæ°Èó®ÁªÑÊàê„ÄÇÊØèÊâáÈò≤Âæ°Èó®ÂåÖÊã¨‰∏Ä‰∏™ËøêÁÆó$op$ Âíå‰∏Ä‰∏™ÂèÇÊï∞$t$ÔºåÂÖ∂‰∏≠ËøêÁÆó‰∏ÄÂÆöÊòØ $OR,XOR,AND$ ‰∏≠ÁöÑ‰∏ÄÁßçÔºåÂèÇÊï∞Âàô‰∏ÄÂÆö‰∏∫ÈùûË¥üÊï¥Êï∞„ÄÇÂ¶ÇÊûúËøòÊú™ÈÄöËøáÈò≤Âæ°Èó®Êó∂ÊîªÂáªÂäõ‰∏∫ $x$ÔºåÂàôÂÖ∂ÈÄöËøáËøôÊâáÈò≤Âæ°Èó®ÂêéÊîªÂáªÂäõÂ∞ÜÂèò‰∏∫ $x$ $op$ $t$„ÄÇÊúÄÁªàdrd ÂèóÂà∞ÁöÑ‰º§ÂÆ≥‰∏∫ÂØπÊñπÂàùÂßãÊîªÂáªÂäõ $x$ ‰æùÊ¨°ÁªèËøáÊâÄÊúâ $n$ÊâáÈò≤Âæ°Èó®ÂêéËΩ¨ÂèòÂæóÂà∞ÁöÑÊîªÂáªÂäõ„ÄÇ Áî±‰∫é atm Ê∞¥Âπ≥ÊúâÈôêÔºå‰ªñÁöÑÂàùÂßãÊîªÂáªÂäõÂè™ËÉΩ‰∏∫ $0$ Âà∞ $m$ ‰πãÈó¥ÁöÑ‰∏Ä‰∏™Êï¥Êï∞ÔºàÂç≥‰ªñÁöÑÂàùÂßãÊîªÂáªÂäõÂè™ËÉΩÂú® $0,1,‚Ä¶,m$ ‰∏≠‰ªªÈÄâÔºå‰ΩÜÂú®ÈÄöËøáÈò≤Âæ°Èó®‰πãÂêéÁöÑÊîªÂáªÂäõ‰∏çÂèó $m$ ÁöÑÈôêÂà∂Ôºâ„ÄÇ‰∏∫‰∫ÜËäÇÁúÅ‰ΩìÂäõÔºå‰ªñÂ∏åÊúõÈÄöËøáÈÄâÊã©ÂêàÈÄÇÁöÑÂàùÂßãÊîªÂáªÂäõ‰ΩøÂæó‰ªñÁöÑÊîªÂáªËÉΩËÆ© drd ÂèóÂà∞ÊúÄÂ§ßÁöÑ‰º§ÂÆ≥ÔºåËØ∑‰Ω†Â∏Æ‰ªñËÆ°ÁÆó‰∏Ä‰∏ãÔºå‰ªñÁöÑ‰∏ÄÊ¨°ÊîªÂáªÊúÄÂ§öËÉΩ‰Ωø drd ÂèóÂà∞Â§öÂ∞ë‰º§ÂÆ≥„ÄÇ Ëß£ÊûêÂæàÊúâÊÑèÊÄùÁöÑÈ¢òÁõÆ,ÊÉ≥Âà∞‰∫åËøõÂà∂ÊãÜ‰ΩçÁöÑËØù,ÊÄùË∑ØÂ∞±ÂæàÊ∏ÖÊô∞‰∫Ü. ËôΩÁÑ∂ÊàëÁî±‰∫é‰∏çÁü•ÂêçÁöÑÂéüÂõ†‰∏ÄÁõ¥50ÂàÜ Êàë‰ª¨Êåâ‰ΩçËøêÁÆó,Âõ†‰∏∫ÊØè‰∏Ä‰ΩçÁöÑËøêÁÆóÊòØÁã¨Á´ãÁöÑ,ËÄåÊØè‰∏Ä‰ΩçÂè™ÂèØËÉΩÊòØ$0$Êàñ$1$. Âè™ÈúÄË¶ÅÊ≥®ÊÑèÂá†ÁÇπÂç≥ÂèØ ÂéüÊï∞Á¨¨$k$‰ΩçÂ¶ÇÊûúÊòØ$0$,Âá∫Êù•ÁöÑÁªìÊûúÊòØ$1$,Êàë‰ª¨Â∞±Â≠ò‰∏ãÊù• ÂéüÊï∞ÁöÑÁ¨¨$k$‰ΩçÂ¶ÇÊûúÊòØ$1$,Âá∫Êù•ÁöÑÁªìÊûúÊòØ$1$,‰∏îÂéüÊï∞Â∞è‰∫ém,Êàë‰ª¨Â∞±Â≠ò‰∏ãÊù•. ==97ÂàÜ‰ª£Á†Å== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; ‰∏çÁü•ÈÅìÊòØÂì™‰ΩçÂ∏¶‰Ω¨Âá∫ÁöÑhackÊï∞ÊçÆ, 123452 13983XOR 12XOR 12Á≠îÊ°àÊòØ13983 ÂêåÊ†∑ÁöÑÊÄùË∑Ø,‰∏çÂêåÁöÑÂÅöÊ≥ï,Êàë‰ª¨ÂèØ‰ª•Â∞Ü$11111‚Ä¶$Âíå$0$ÂàÜÂà´ÊâîËøõÂéª,ÈÇ£‰πàÂàÜÂà´Â∞ÜÂá∫Êù•ÁöÑÈùû$0$ÁöÑ‰ΩçÂä†Ëµ∑Êù•,Â∞±ÊòØÊàë‰ª¨ÁöÑÁ≠îÊ°à.ÂêåÊ†∑,‰ºòÂÖàÁ∫ß$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; ËøôÈáå$i$Â¶ÇÊûú‰ªé$30$ÂºÄÂßãÁÆó,È¢ùÂ§ñÊï∞ÊçÆÂ∞±ÊòØÈîôÁöÑ,$29$ÂºÄÂßãÁÆó,È¢ùÂ§ñÊï∞ÊçÆÂ∞±ËÉΩËøá. $emmmm$]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>‰∫åÁ∫ßÂà∂ÊãÜ‰Ωç</tag>
      </tags>
  </entry>
</search>
