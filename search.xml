<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STË°®]]></title>
    <url>%2F2019%2F08%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Âºï‰æãÊ¥õË∞∑P3865$RMQ$ÁöÑ‰∏≠ÊñáÁøªËØë‰∏∫:ÈùôÊÄÅÂå∫Èó¥ÊúÄÂÄºÊü•ËØ¢.Ëã±ÊñáÊàë‰∏çÁü•ÈÅìÊâÄ‰ª•‰∏çÂÜôÁªô‰Ω†$n$‰∏™Êï∞,$m$Ê¨°Êü•ËØ¢,Êü•ËØ¢ÁöÑÂÜÖÂÆπ‰∏∫Âå∫Èó¥$[l,r]$‰∏≠ÁöÑÊúÄÂ§ßÂÄº.$RMQ$ÊúâËß£Ê≥ïËõÆÂ§öÁöÑ,$st$Ë°®,Á∫øÊÆµÊ†ë,Ê†ëÁä∂Êï∞ÁªÑ,ÂàíÂàÜÊ†ëÈÉΩÂèØ‰ª•ÂÅö.$st$Ë°®ÁöÑÂ§çÊùÇÂ∫¶‰∏∫È¢ÑÂ§ÑÁêÜ$O(n*{\log_2} n)$+Êü•ËØ¢$O(m)$ËÄåÁ∫øÊÆµÊ†ëÂàôÈúÄË¶ÅÈ¢ÑÂ§ÑÁêÜ$O(n*{\log_2} n)$+Êü•ËØ¢$O(m*{\log_2} n)$Ê†ëÁä∂Êï∞ÁªÑÊ≤°Â≠¶,‰∏çÊ∏ÖÊ•öÁ∫øÊÆµÊ†ëÂèØ‰ª•ÁúãÊàë‰πãÂâçÁöÑÂçöÂÆ¢. ÂÆö‰πâËøô‰∏™ÁÆóÊ≥ïÂ∞±ÊòØÂü∫‰∫é$DP$Âíå‰ΩçËøêÁÆóÁ¨¶ÔºåÊàë‰ª¨Áî®$dp[i][j]$Ë°®Á§∫‰ªéÁ¨¨ $i$ ‰ΩçÂºÄÂßãÔºåÂà∞Á¨¨ $i + 2^j -1$ ‰ΩçÁöÑÊúÄÂ§ßÂÄºÊàñËÄÖÊúÄÂ∞èÂÄº„ÄÇ ÈÇ£‰πàÊàëÊ±Ç$dp[i][j]$ÁöÑÊó∂ÂÄôÂèØ‰ª•ÊääÂÆÉÂàÜÊàê‰∏§ÈÉ®ÂàÜÔºåÁ¨¨‰∏ÄÈÉ®ÂàÜ‰ªé $i$ Âà∞ $i + 2 ^{(j-1)} - 1$ ÔºåÁ¨¨‰∫åÈÉ®ÂàÜ‰ªé $i + 2 ^{(j-1)}$ Âà∞$i + 2^j- 1$,ÈÇ£‰πàÂèØ‰ª•ÂæóÂà∞$$dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1])$$ÂΩì$j=0$Êó∂,Ê±ÇÁöÑÊòØÈïøÂ∫¶‰∏∫1ÁöÑÂå∫Èó¥ÁöÑÊúÄÂ∞èÂÄº,$j=1$Êó∂,Ê±ÇÁöÑÊòØÈïøÂ∫¶‰∏∫2ÁöÑÂå∫Èó¥ÊúÄÂ∞èÂÄº$j=2$Êó∂,Ê±ÇÁöÑÊòØÈïøÂ∫¶‰∏∫4ÁöÑÂå∫Èó¥ÊúÄÂ∞èÂÄº‰ª•Ê≠§Á±ªÊé®,ÊïÖÂèØÂú®$O(n\log_2 n)$ÁöÑÂ§çÊùÇÂ∫¶Â§ÑÁêÜÂÆå.Â¶ÇÂõæÊâÄÁ§∫Êü•ËØ¢ÁöÑËØù,Âè™ÈúÄË¶ÅÂèçËøáÊù•Â∞±Èòî‰ª•‰∫Ü. ÂÆåÊï¥‰ª£Á†ÅËøôÈáåmm[i] = mm[i - 1] +((i&(i - 1)) == 0);123456789101112131415161718192021222324252627282930313233343536373839```cppconst int MAXN = 1e5 + 10;int dp[MAXN][31],a[MAXN],mm[MAXN];void initRMQ(int n)&#123; mm[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; mm[i] = mm[i - 1] +((i&amp;(i - 1)) == 0); dp[i][0] = a[i]; &#125; for (int j = 1; j &lt;= mm[n]; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int x, int y)&#123; int k = mm[y - x + 1]; return max(dp[x][k], dp[y - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m;//scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initRMQ(n); while (m--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; rmq(x, y) &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; ‰∫åÁª¥stË°®ÊöÇÂ≠òhttps://blog.csdn.net/VictoryCzt/article/details/83684082 Á∫¶ÊùüRMQhttps://www.cnblogs.com/ghostcai/p/9280720.htmlhttps://blog.csdn.net/VictoryCzt/article/details/83348579 ÁªÉ‰π†È¢òÁõÆÊ¥õË∞∑P2251Ë£∏ÁöÑ$RMQ$ÈóÆÈ¢òÊ¥õË∞∑P3865$st$Ë°®Ê®°ÊùøÈ¢òÁõÆÊ¥õË∞∑P2048$st$Ë°®+ÂâçÁºÄÂíå+Ë¥™ÂøÉ+Â†Ü‰ºòÂåñ]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>STË°®</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQÂàÜÊ≤ª]]></title>
    <url>%2F2019%2F08%2F09%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[‰∏çÂæó‰∏çËØ¥&emsp;&emsp;Êú¨Êù•Ê†áÈ¢òÊÉ≥ÂÜôÂàÜÊ≤ª,‰ΩÜÊòØÊÉ≥‰∫ÜÊÉ≥ÂèëÁé∞Ëá™Â∑±ÂàÜÊ≤ªËÉΩËØ¥ÁöÑ‰∏çÂ§ö,‰∏ªË¶ÅÁöÑÂÜÖÂÆπÂ∞±ÊòØ$CDQ$ÂàÜÊ≤ª.‰æøÂèñ‰∫ÜËøô‰∏™Ê†áÈ¢ò. È¢ÑÂ§áÁü•ËØÜ ÂÖ≥‰∫é‰ªÄ‰πàÊòØÂàÜÊ≤ª&emsp;&emsp;ÂàÜÊ≤ªÔºåÂ≠óÈù¢‰∏äÁöÑËß£ÈáäÊòØ‚ÄúÂàÜËÄåÊ≤ª‰πã‚ÄùÔºåÂ∞±ÊòØÊää‰∏Ä‰∏™Â§çÊùÇÁöÑÈóÆÈ¢òÂàÜÊàê‰∏§‰∏™ÊàñÊõ¥Â§öÁöÑÁõ∏ÂêåÊàñÁõ∏‰ººÁöÑÂ≠êÈóÆÈ¢òÔºåÂÜçÊääÂ≠êÈóÆÈ¢òÂàÜÊàêÊõ¥Â∞èÁöÑÂ≠êÈóÆÈ¢ò‚Ä¶‚Ä¶Áõ¥Âà∞ÊúÄÂêéÂ≠êÈóÆÈ¢òÂèØ‰ª•ÁÆÄÂçïÁöÑÁõ¥Êé•Ê±ÇËß£ÔºåÂéüÈóÆÈ¢òÁöÑËß£Âç≥Â≠êÈóÆÈ¢òÁöÑËß£ÁöÑÂêàÂπ∂„ÄÇÂú®ËÆ°ÁÆóÊú∫ÁßëÂ≠¶‰∏≠ÔºåÂàÜÊ≤ªÊ≥ïÂ∞±ÊòØËøêÁî®ÂàÜÊ≤ªÊÄùÊÉ≥ÁöÑ‰∏ÄÁßçÂæàÈáçË¶ÅÁöÑÁÆóÊ≥ï„ÄÇÂàÜÊ≤ªÊ≥ïÊòØÂæàÂ§öÈ´òÊïàÁÆóÊ≥ïÁöÑÂü∫Á°ÄÔºåÂ¶ÇÊéíÂ∫èÁÆóÊ≥ïÔºàÂø´ÈÄüÊéíÂ∫èÔºåÂΩíÂπ∂ÊéíÂ∫èÔºâÔºåÂÇÖÁ´ãÂè∂ÂèòÊç¢ÔºàÂø´ÈÄüÂÇÖÁ´ãÂè∂ÂèòÊç¢ÔºâÁ≠âÁ≠â„ÄÇ ‰∏ÄËà¨Ê≠•È™§ ÂàíÂàÜÊ≠•ÔºöÊääËæìÂÖ•ÁöÑÈóÆÈ¢òÂàíÂàÜ‰∏∫$k$‰∏™Â≠êÈóÆÈ¢òÔºåÂπ∂Â∞ΩÈáè‰ΩøËøô$k$‰∏™Â≠êÈóÆÈ¢òÁöÑËßÑÊ®°Â§ßËá¥Áõ∏Âêå„ÄÇ Ê≤ªÁêÜÊ≠•ÔºöÂΩìÈóÆÈ¢òÁöÑËßÑÊ®°Â§ß‰∫éÊüê‰∏™È¢ÑÂÆöÁöÑÈòàÂÄº$n_0$Êó∂ÔºåÊ≤ªÁêÜÊ≠•Áî±$k$‰∏™ÈÄíÂΩíË∞ÉÁî®ÁªÑÊàê„ÄÇ ÁªÑÂêàÊ≠•ÔºöÁªÑÂêàÊ≠•ÊääÂêÑ‰∏™Â≠êÈóÆÈ¢òÁöÑËß£ÁªÑÂêàËµ∑Êù•ÔºåÂÆÉÂØπÂàÜÊ≤ªÁÆóÊ≥ïÁöÑÂÆûÈôÖÊÄßËÉΩËá≥ÂÖ≥ÈáçË¶ÅÔºåÁÆóÊ≥ïÁöÑÊúâÊïàÊÄßÂæàÂ§ßÂú∞‰æùËµñ‰∫éÁªÑÂêàÊ≠•ÁöÑÂÆûÁé∞„ÄÇ Êó∂Èó¥Â§çÊùÇÂ∫¶ Áõ¥ËßÇ‰º∞ËÆ° ÂàÜÊ≤ªÁî±‰ª•‰∏ä‰∏âÈÉ®ÂàÜÊûÑÊàêÔºåÊï¥‰ΩìÊó∂Èó¥Â§çÊùÇÂ∫¶ÂàôÁî±Ëøô‰∏âÈÉ®ÂàÜÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰πãÂíåÊûÑÊàê. Áî±‰∫éÈÄíÂΩíÔºåÊúÄÁªàÁöÑÂ≠êÈóÆÈ¢òÂèòÂæóÊûÅ‰∏∫ÁÆÄÂçïÔºå‰ª•Ëá≥‰∫éÂÖ∂Êó∂Èó¥Â§çÊùÇÂ∫¶Âú®Êï¥‰∏™ÂàÜÊ≤ªÁ≠ñÁï•‰∏äÁöÑÊØîÈáçÂæÆ‰πéÂÖ∂ÂæÆ. ÁªèÂÖ∏‰æãÈ¢ò ÂΩíÂπ∂ÊéíÂ∫è,Âø´ÊéíÁ≠â Ê±ÇÈÄÜÂ∫èÂØπÁ≠âÁªèÂÖ∏‰æãÈ¢ò$Atcoder\ A\ -\ Colorful\ Subsequence$https://atcoder.jp/contests/agc031/tasks/agc031_a È¢òÁõÆÁÆÄÊûê: ÈóÆÂ§öÂ∞ëÁßçÂ≠êÂ∫èÂàó,Â≠êÂ∫èÂàó‰∏≠ÁöÑÂ≠óÊØç‰∏çÂêå. ÂàóÂ¶Ç$baa$,ÂåÖÊã¨:$b,a,a,$‰∏§‰∏™‰∏çÂêå‰ΩçÁΩÆ$a$ÁöÑ$ba$,ÊÄªËÆ°$5$‰∏™,$baa$ÊéíÈô§ÊòØÂõ†‰∏∫$a$ÊòØÈáçÂ§çÁöÑ. Ëß£Ê≥ï ÂÖàÂ∞ÜÊØè‰∏™Â≠óÊØçÁöÑ‰∏™Êï∞ÁªüËÆ°‰∏ãÊù•,ÁÑ∂ÂêéÂàÜÊ≤ªËÆ°ÁÆó,‰∏Ä‰∏™Â≠óÊØçÁöÑÊó∂ÂÄô,Á≠îÊ°àÊòØËØ•Â≠óÊØçÂá∫Áé∞ÁöÑÊ¨°Êï∞. Âè™Êúâ‰∏§‰∏™Â≠óÊØçÁöÑÊó∂ÂÄô,Â¶Ç$ab$,ÂåÖÂê´ÁöÑÊéíÂàóÊúâ$a,b,ab$,Áõ∏ÂΩì‰∫é‚Äô$a$ÁöÑ‰∏™Êï∞,$b$ÁöÑ‰∏™Êï∞,$a$Âíå$b$ÁªÑÂêà‰∏™Êï∞‚ÄôÁöÑÂä†Âíå,ËÄå$a$Âíå$b$ÁªÑÂêà‰∏™Êï∞,ÂàôÊòØ$a$ÁöÑ‰∏™Êï∞$\times b$ÁöÑ‰∏™Êï∞ ÂêåÁêÜÂèØÂæó,$ans$Âç≥‰∏∫$ansL+ansR+ansL\times ansR$.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e5 + 10;const int MOD = 1e9 + 7;typedef long long ll;char s[INF];int num[27];string s1="0";ll solve(int L, int R)&#123; if (L == R) return num[s1[L] - 'a']; int mid = (L + R) &gt;&gt; 1; ll nL = solve(L, mid), nR = solve(mid + 1, R); return (nL%MOD + nR%MOD + (nL%MOD * nR%MOD)%MOD)%MOD;&#125;int main()&#123; int n; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (!num[s[i] - 'a']) s1 = s1 + s[i]; num[s[i] - 'a']++; &#125; cout &lt;&lt; solve(1, s1.length() - 1)&lt;&lt;endl; return 0;&#125; CDQÂàÜÊ≤ªÂâçÈù¢ÁµÆÁµÆÂè®Âè®ÁöÑÁÆÄÂçï‰ªãÁªç‰∫Ü‰∏ãÂàÜÊ≤ª,ÊÉ≥ÂøÖÂêÑ‰ΩçÂØπÂàÜÊ≤ªÊúâ‰∫Ü‰∏ÄÂÆöËÆ§ËØÜ.‰∏ãÈù¢ÊòØÈáçÂ§¥Êàè:$CDQ$ÂàÜÊ≤ª.Ëøô‰∏™ÁÆóÊ≥ï,ÊòØÁî±Èôà‰∏πÁê¶Â§ßÁâõÂú®ËÆ∫Êñá‰∏≠ÊèêÂá∫ÁöÑ%%%.È¶ñÂÖà,Êàë‰ª¨ÈúÄË¶ÅÁü•ÈÅì‰∏Ä‰∫õ‰∫ãÊÉÖ: ‰ºòÂäøÂú®‰∫éÂèØ‰ª•È°∂ÊõøÂ§çÊùÇÁöÑÈ´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºåËÄå‰∏îÂ∏∏Êï∞ÊØîËæÉÂ∞è Áº∫ÁÇπÂú®‰∫éÂøÖÈ°ªÁ¶ªÁ∫øÊìç‰Ωú Áî®Êù•Ëß£ÂÜ≥‰ªÄ‰πàÈóÆÈ¢òÂë¢? È¶ñÂÖà,ÂàÜÊ≤ªÈóÆÈ¢ò2333 ÂàÜÊ≤ªÂêéÁöÑÁ≠îÊ°à,‰∏ç‰ªÖÂçïÂçïËÄÉËôëÂ≠êÈóÆÈ¢ò${L,mid}$ÂíåÂ≠êÈóÆÈ¢ò${mid+1,R}$. ËøòÈúÄË¶ÅËÄÉËôëÂ≠êÈóÆÈ¢ò${L,mid}$ÂØπÂ≠êÈóÆÈ¢ò${mid+1,R}$ÁöÑÂΩ±Âìç$/$ËÅîÁ≥ª‰∫ßÁîüÁöÑÁ≠îÊ°à. ÂàóÂ¶Ç: ‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢ò ÁªôÂÆö‰∏Ä‰∏™‰∫åÂÖÉÁªÑ${x,y}$,Ë¶ÅÊ±ÇÈóÆÊúâÂ§öÂ∞ëÂØπ${x_i,y_i},{x_j,y_j}$Êª°Ë∂≥$x_i&gt;x_j$&&$y_i&gt;y_j$ Ëß£Ê≥ï‰∏∫: ÂÖàÂ∞Ü‰∫åÂÖÉÁªÑÊåâÁÖß$x$ÁöÑÂ§ßÂ∞èÊéíÂàó. ÂàÜÊ≤ªÂêé,Êàë‰ª¨ÂàÜÂà´Áü•ÈÅì${L,mid}$Âå∫Èó¥Âíå${mid+1,R}$Âå∫Èó¥ÂÜÖÁöÑËß£ ÂÜçËÆ°ÁÆóË∑®Ëøá$mid$ÁöÑ‰∏§ÂØπÁÇπ,ÂØπ${L,mid}$Âíå${mid+1,R}$‰∏≠ÁöÑ‰∫åÂÖÉÁªÑÊåâÁÖß$y$ÁöÑÂ§ßÂ∞èÊéíÂ∫è Áî±‰∫éÂÖàÂâçÂàÜÁªÑ‰æøÂ∑≤ÁªèÂØπ$x$ËøõË°åÊéíÂ∫è,ÊâÄ‰ª•,Âè™ÈúÄË¶Å‰∫åÂàÜ‰æøÂèØ‰ª•Ê±ÇÂæóÂ∑¶Âå∫Èó¥Áõ∏ÂØπ‰∫éÂè≥Âå∫Èó¥ÁöÑÁÇπÁöÑ‰∏™Êï∞. ‰∏âÁª¥ÂÅèÂ∫èÈóÆÈ¢ò Âíå‰∫åÁª¥ÂÅèÂ∫èÈóÆÈ¢òÁ±ª‰ºº,‰ΩÜÊúâ‰∏ÄÂÆö‰∏çÂêå ÁªôÂÆö‰∏Ä‰∏™‰∏âÂÖÉÁªÑ${x,y,z}$,Ë¶ÅÊ±ÇÈóÆÊúâÂ§öÂ∞ëÂØπ${x_i,y_i,z_i},{x_j,y_j,z_j}$Êª°Ë∂≥$x_i&gt;x_j$&&$y_i&gt;y_j$&&$z_i&gt;z_j$ Ëß£Ê≥ï‰∏∫: ÂÖàÂ∞Ü‰∏âÂÖÉÁªÑÊåâÁÖß$x$ÁöÑÂ§ßÂ∞èÊéíÂàó. ÂàÜÊ≤ªÂêé,Êàë‰ª¨ÂàÜÂà´Áü•ÈÅì${L,mid}$Âå∫Èó¥Âíå${mid+1,R}$Âå∫Èó¥ÂÜÖÁöÑËß£ ÂÜçËÆ°ÁÆóË∑®Ëøá$mid$ÁöÑ‰∏§ÂØπÁÇπ,ÂØπ${L,mid}$Âíå${mid+1,R}$‰∏≠ÁöÑ‰∏âÂÖÉÁªÑÊåâÁÖß$y$ÁöÑÂ§ßÂ∞èÊéíÂ∫è Áî±‰∫éÂÖàÂâçÂàÜÁªÑ‰æøÂ∑≤ÁªèÂØπ$x$ËøõË°åÊéíÂ∫è,ÊâÄ‰ª•,Âè™ÈúÄË¶Å‰∫åÂàÜ‰æøÂèØ‰ª•Ê±ÇÂæóÊª°Ë∂≥$y$Êù°‰ª∂ÁöÑÁÇπ. ÂÜçÂª∫Á´ã‰∏Ä‰∏™ÊùÉÂÄºÊ†ëÁä∂Êï∞ÁªÑ$/$Á∫øÊÆµÊ†ë,ÂÜçÂ∞Ü‰∏äÈù¢Á¨¶ÂêàÁöÑ${x,y,z}$ÂØπÂ∫î‰∏≠Êª°Ë∂≥‰∏çÁ≠âÂºèÁöÑ$z$ÁöÑÁÇπÊ±ÇÂá∫. ‰æãÈ¢ò BZOJ3262: Èôå‰∏äËä±ÂºÄ BZOJ4237: Á®ªËçâ‰∫∫ÊàñËÄÖËøô‰∏™LibreOJÁ®ªËçâ‰∫∫ ‰º™‰ª£Á†Å123456789101112void cdq(int left,int right)&#123; if(left==right) return ; int mid=(left+right)&gt;&gt;1; cdq(left,mid),cdq(mid+1,right); sort(a+l,a+mid+1,cmp); sort(a+mid+1,a+right+1,cmp); /** *Â§ÑÁêÜÂ∑¶Âå∫Èó¥ÂØπ‰∫éÂè≥Âå∫Èó¥ÂΩ±ÂìçÁöÑ‰ª£Á†Å */]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>CDQÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[È´òÁ≤æÂ∫¶]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[ÊàëÂ•ΩÁæ°ÊÖï‰ºöÁî®javaÁöÑ‰∫∫‰∏∫‰ªÄ‰πàË¶ÅÁî®Âà∞È´òÁ≤æÂ∫¶Âë¢?Êàë‰ª¨Áü•ÈÅì,$int$ÁöÑËåÉÂõ¥ÊòØ$\pm2^{31}-1$,$long,long$ÁöÑËåÉÂõ¥ÊòØ$\pm2^{63}-1$,ÈÇ£‰πàÂΩìÊàë‰ª¨ÊÉ≥Ë¶ÅË°®Á§∫Êõ¥ÂæÄ‰∏äÁöÑÊï∞Â≠ó,Â∫îËØ•ÊÄé‰πàÂÅö?ËôΩÁÑ∂,ÊàëÂ∑≤ÁªèÂ≠¶‰ºö‰∫Ü Êàë‰∏äÂ∞èÂ≠¶ÂæàËÆ°ÁÆóÊú∫ÁöÑ‰∏ÄÁßçÊñπÂºè,Â∞ÜÊØè‰∏Ä‰ΩçÊîæÂú®‰∏Ä‰∏™$a[i]$‰∏≠,ËøôÊ†∑,‰∏Ä‰∏™Êï∞Â≠óÂ∞±ÂèòÊàê‰∏Ä‰∏™Êï∞ÁªÑ,ÂØπÊï∞Â≠óÁöÑÂõõÂàôËøêÁÆó,‰πüÂ∞±ÂèòÊàê‰∫ÜÂØπÊï∞ÁªÑÁöÑÊìç‰Ωú. È´òÁ≤æÂ∫¶Âä†Ê≥ïÈóÆ:$1234+5678$Á≠îÊ°àÊòØÂ§öÂ∞ë?Á≠î:$Êàë‰∏çÁü•ÈÅì$Âí≥Âí≥,ÊåâÁÖßÂ∞èÂ≠¶ÁöÑÊïôÊ≥ï,Êàë‰ª¨Áü•ÈÅì,Ë¶ÅÂàó‰∏™Á´ñÂºè,ÂØπÈΩêÊï∞‰Ωç,‰∏Ä‰Ωç‰∏Ä‰ΩçÁõ∏Âä†,Êª°$10$Ëøõ$1$.‰∫éÊòØ:$$\quad\quad1234\\underline{,\quad+5678}\\quad\quad6912$$ÂàÜÊûê‰∏Ä‰∏ãËÆ°ÁÆóËøáÁ®ã,Êàë‰ª¨ÂèëÁé∞,ÂΩìÊàë‰ª¨Áî®Êï∞ÁªÑ$a$,Êï∞ÁªÑ$b$,ÂàÜÂà´Â≠ò‰∏ã$1234$Âíå$5678$Âêé,‰ªéÊï∞ÁªÑÁöÑÊúÄÂêé‰∏Ä‰ΩçÂºÄÂßã$for$Âæ™ÁéØ,Áî®Êï∞ÁªÑ$S$‰øùÂ≠òÂíå,$temp$‰øùÂ≠òËøõ‰ΩçÂèØ‰ª•ÂæóÂà∞ÂÜçÂ∞ÜËøô‰∏™ËøáÁ®ãËΩ¨Âåñ‰∏∫‰ª£Á†Å,È´òÁ≤æÂ∫¶Âä†Ê≥ïÂ∞±ÂÜôÂá∫Êù•‰∫Ü 123456789101112131415BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125; È´òÁ≤æÂ∫¶ÂáèÊ≥ï‰ºóÊâÄÂë®Áü•,ÂáèÊ≥ïÊòØÂä†Ê≥ïÁöÑÈÄÜËøêÁÆó.ÊâÄ‰ª•,Êàë‰ª¨Â∞ÜÂä†Ê≥ïÁöÑËøáÁ®ãÂèçËøáÊù•Â∞±ÊòØÂáèÊ≥ï. ‰ªéÂ§¥ÂæÄÂêéÂ§ÑÁêÜ $temp$‰øùÂ≠òÂêëÂêé‰∏Ä‰ΩçÁöÑÂÄü‰Ωç Â§ÑÁêÜË¥üÊï∞ÁöÑÂÅ∑ÊáíÊñπÂºè‰∏∫,Â∞ÜÁ¨¨‰∏Ä‰ΩçÂâçÂä†‰∏™Á¨¶Âè∑,ËæìÂá∫ÁöÑÊó∂ÂÄôÂ∞±Âä†‰∏ä‰∫ÜÁ¨¶Âè∑1234567891011121314151617181920212223242526272829303132333435363738BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; È´òÁ≤æÂ∫¶‰πòÊ≥ïÊàë‰ª¨Áé∞Âú®ËøòÊòØÂ∞èÂ≠¶ÊèêÈóÆ:$1234\times5678$Á≠îÊ°àÊòØÂ§öÂ∞ëÊàë‰ª¨Êù•Âàó‰∏™ÂºèÊùÇ$\quad\quad\quad1234$$;\quad\underline{\quad\times5678}$$\quad\quad\quad9872$$\quad\quad8638$$\quad;;7404$$\underline{\quad6170\quad;}$$\quad7006652$ÈÇ£‰πàÂàÜÊûê‰∏Ä‰∏ãËøô‰∏™ËøáÁ®ã.ËÆæ‰∏Ä‰∏™Á©∫ÁöÑ$s$Êï∞ÁªÑ,$b$Êï∞ÁªÑÁöÑ‰∏™‰Ωç$\times a$‰ªé‰∏™‰ΩçÂºÄÂßãÂíå$s$ÁöÑÊØè‰∏Ä‰ΩçÁõ∏Âä†,$b$Êï∞ÁªÑÁöÑÂçÅ‰Ωç$\times a$‰ªéÂçÅ‰ΩçÂºÄÂßãÂíå$s$ÁöÑÊØè‰∏Ä‰ΩçÁõ∏Âä†,‰ª•Ê≠§Á±ªÊé®,‰∏ÄÁõ¥Âà∞$b$ÁöÑÂçÉ‰ΩçËÆ°ÁÆóÁªìÊùü,ÂæóÂà∞ÁöÑ‰æøÊòØÁ≠îÊ°à 1234567891011121314151617181920212223242526BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; È´òÁ≤æÂ∫¶Èô§Ê≥ïÂ•ΩÁöÑ,Êàë‰ª¨Áé∞Âú®ËøòÊòØÂ∞èÂ≠¶Áîü È´òÁ≤æÂ∫¶Èô§‰ΩéÁ≤æÂ∫¶Â•ΩÁöÑ,È¶ñÂÖà,Èô§Ê≥ïÊòØ‰πòÊ≥ïÁöÑÈÄÜÂÖÉ,ÊâÄ‰ª•Êàë‰ª¨~ÂÄíÁùÄÂÅöÂõûÂéª ‰ªéÂ§¥ÂæÄÂêéÂ§ÑÁêÜ $down$ÂÇ®Â≠ò‰ΩôÊï∞ ÂΩì‰ΩôÊï∞+ËØ•‰ΩçÂ∞è‰∫é‰ΩéÁ≤æÂ∫¶ÁöÑÊï∞Êó∂,Êàë‰ª¨ÂêëÂêéÂª∂Áª≠‰∏Ä‰Ωç12345678910111213BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret, len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; ÂÆåÊï¥‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#define MAXN 9999 //MAXNÊéßÂà∂ÊØè‰∏™a[i]ÂÜÖÂ§ßÂ∞è#define DLEN 4 //DLENÊéßÂà∂a[i]‰∏≠ÊúâÂá†‰Ωç#define MAXSIZE 5010 //ÊéßÂà∂Êï∞Â≠ó‰ΩçÊï∞class BigNum &#123;private: int a[MAXSIZE]; int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator +(const BigNum &amp;)const; BigNum operator -(const BigNum &amp;)const; BigNum operator *(const BigNum &amp;)const; BigNum operator /(const int &amp;)const; BigNum operator ^(const int &amp;)const; long long operator %(const long long &amp;)const; bool operator &gt;(const BigNum&amp;i_T)const; bool operator &gt;(const int &amp;i_T)const; void print();&#125;;//int-&gt;BigNumBigNum::BigNum(const int i_b)&#123; int c, d = i_b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1))*(MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;//char-&gt;BigNumBigNum::BigNum(const char *i_s)&#123; int t, k, index, L; memset(a, 0, sizeof(a)); L = strlen(i_s); len = L / DLEN; if (L%DLEN) len++; index = 0; for (int i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + i_s[j] - '0'; a[index++] = t; &#125;&#125;//copyBigNum::BigNum(const BigNum &amp;i_T) :len(i_T.len)&#123; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_T.a[i];&#125;//BigNumÂ§çÂà∂BigNumBigNum&amp;BigNum::operator=(const BigNum&amp;i_n)&#123; len = i_n.len; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_n.a[i]; return *this;&#125;//cin&gt;&gt; BigNumistream&amp; operator &gt;&gt;(istream &amp;in, BigNum &amp;i_b)&#123; char ch[MAXSIZE * DLEN]; in &gt;&gt; ch; int L = strlen(ch), count = 0, sum = 0; for (int i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; DLEN &amp;&amp; i &gt;= 0; j++, i--, t *= 10) sum += (ch[i] - '0')*t; i_b.a[count] = sum; count++; &#125; i_b.len = count++; return in;&#125;//cout&lt;&lt;BigNumostream&amp; operator &lt;&lt;(ostream&amp; out, BigNum&amp; i_b)&#123; cout &lt;&lt; i_b.a[i_b.len - 1]; for (int i = i_b.len - 2; i &gt;= 0; i--) printf("%04d", i_b.a[i]); return out;&#125;//È´òÁ≤æÂ∫¶Èô§‰ΩéÁ≤æÂ∫¶BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;//È´òÁ≤æÂ∫¶%‰ΩéÁ≤æÂ∫¶long long BigNum::operator%(const long long &amp;i_b)const&#123; long long d = 0; for (int i = len - 1; i &gt;= 0; i--) d = ((d*MAXN + 1) % i_b + a[i] * 1LL) % i_b; return d;&#125;//È´òÁ≤æÂ∫¶Ê±ÇÂπÇBigNum BigNum::operator^(const int &amp;n)const&#123; int i; BigNum t, ret(1); if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;//È´òÁ≤æ‰∏éÈ´òÁ≤æÊØîËæÉbool BigNum::operator&gt;(const BigNum &amp;i_T)const&#123; int ln; if (len &gt; i_T.len) return true; else if (len &lt; i_T.len) return false; else &#123; ln = len - 1; while (a[ln] == i_T.a[ln] &amp;&amp; ln &gt; 0) ln--; return (ln &gt;= 0 &amp;&amp; a[ln] &gt; i_T.a[ln]); &#125;&#125;//È´òÁ≤æ‰∏é‰ΩéÁ≤æÂ∫¶bool BigNum::operator&gt;(const int &amp;i_T)const&#123; BigNum b(i_T); return *this &gt; b;&#125;//ÊâìÂç∞È´òÁ≤æÂ∫¶void BigNum::print()&#123; printf("%d", a[len - 1]); for (int i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;//È´òÁ≤æÂ∫¶Áõ∏‰πòBigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; È´òÁ≤æÂ∫¶Èô§È´òÁ≤æÂ∫¶Â•ΩÁöÑ,Êàë‰ª¨Áé∞Âú®‰∏çÂÅöÂ∞èÂ≠¶Áîü‰∫ÜËÄÉËôëÁî®Èô§‰ΩéÁ≤æÂ∫¶ÁöÑÂÅöÊ≥ï,Â§™È∫ªÁÉ¶‰∫Ü.ÈÇ£‰πàÊàë‰ª¨ÂÜçÂõûÂà∞ÈÇ£Âè•ËØù,Èô§Ê≥ïÊòØ‰πòÊ≥ïÁöÑÈÄÜÂÖÉ.ËÄÉËôë:$a/b=c\ldots d$,ÈÇ£‰πà‰πüÂ∞±ÊÑèÂë≥ÁùÄ$d+c\times b=a$,ÈÇ£‰πàÂè™Ë¶ÅÊâæÂà∞‰∏Ä‰∏™Êï∞$c$,‰ΩøÂæó$c\times b+d=a$Âç≥ÂèØ‰∫éÊòØ,ÈóÆÈ¢òÂèò‰∏∫‰∫ÜÂä†Ê≥ïÂíå‰πòÊ≥ïÁöÑÁªÑÂêà.ÂØπ‰∫éÂä†Ê≥ï,‰∏Ä‰∏™‰∏™ËØïÁöÑËØù,ÂøÖÂÆöË∂ÖÊó∂.ËÄÉËôë‰∏§ÁßçÊñπÂºè:‰∫åÂàÜÊ≥ïÂíåÁâõÈ°øÊ≥ï.È´òÁ≤æÂ∫¶Áî®‰∏ç‰∫ÜÁâõÈ°øÊ≥ïÂÜµ‰∏îÊàë‰πü‰∏ç‰ºö,‰ΩøÁî®‰∫åÂàÜÊ≥ï,Â§çÊùÇÂ∫¶‰∏∫$O(logN)$.ÂØπ‰∫é‰πòÊ≥ï ÊôÆÈÄöÁöÑÊ®°Êãü$O(N^2)$. ÂàÜÊ≤ª‰πòÊ≥ïÔºöÊúÄÁÆÄÂçïÁöÑÊòØ$Karatsuba$‰πòÊ≥ïÔºå‰∏ÄËà¨Âåñ‰ª•ÂêéÊúâ$Toom-Cook$‰πòÊ≥ïÔºõ Âø´ÈÄüÂÇÖÈáåÂè∂ÂèòÊç¢$FFT$ÔºöÔºà‰∏∫‰∫ÜÈÅøÂÖçÁ≤æÂ∫¶ÈóÆÈ¢òÔºåÂèØ‰ª•ÊîπÁî®Âø´ÈÄüÊï∞ËÆ∫ÂèòÊç¢$FNTT$ÔºâÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶$O(N lgN lglgN)$„ÄÇÂèÇÁÖß$Sch√∂nhage‚ÄìStrassen algorithm$Âíå$F√ºrer‚Äôs algorithm$ ‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÔºöÊääÊØè‰∏™Êï∞ÂàÜËß£Âà∞‰∏Ä‰∫õ‰∫íÁ¥†ÁöÑÊ®°‰∏äÔºåÁÑ∂ÂêéÊØè‰∏™Âêå‰ΩôÊñπÁ®ãÂØπÂ∫î‰πòËµ∑Êù•Â∞±Ë°å ‰∏§ËÄÖÁªìÂêàÂç≥ÂèØËß£ÂÜ≥ÈóÆÈ¢ò.$fft$ÁöÑËØùÂèØ‰ª•Áúã‰∏Ä‰∏ã$hdu1402$$java$$AC$Âêé,$c/c++$ËøòÂú®Êï≤‰ª£Á†Å.]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>È´òÁ≤æÂ∫¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂàÜÂùó1-9(Êú™ÂÆå)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%88%86%E5%9D%971-9-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[Â∫èÊÑüË∞¢@hzwerÂ§ß‰Ω¨Âá∫ÁöÑÁªÉ‰π†È¢òÈ¢òÁõÆÈìæÊé•LOJÊú¨ËíüËøáÂº±,ÂÆûÂú®‰∏çÁü•ÈÅìÊÄé‰πàÂéãÁº©‰ª£Á†ÅÈáè‰∫Ü-&gt;_-&gt; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 1ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞ÂàóÔºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂå∫Èó¥Âä†Ê≥ïÔºåÂçïÁÇπÊü•ÂÄº„ÄÇ Â∞Ü$n$‰∏™Êï∞,ÊåâÁÖßÊØè$\sqrt{n}$‰∏∫‰∏Ä‰∏™ÂùóÊ†áËÆ∞. 123belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x];start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x];end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x]; ÊØèÊ¨°ÂØπÊâÄÁªôÁöÑ$[l,r]$Âå∫Èó¥ËøõË°åËÆ®ËÆ∫,ÂàÜ‰∏∫‚ÄùÂçïËπ¶‚ÄùÂíå‚ÄùÂùó‚Äù,ÂØπ‰∫é‰∏çÊª°ÂùóÁöÑÊï∞,Áõ¥Êé•Êö¥Âäõ‰øÆÊîπ.ÂØπ‰∫éÊª°Ë∂≥ÂùóÁöÑÊï∞,Áõ¥Êé•Êâì‰∏Ä‰∏™Ê†áËÆ∞,ÂΩìËÆøÈóÆÁöÑÊó∂ÂÄôÂÜçËøõË°å‰øÆÊîπÂç≥ÂèØ,Á±ª‰ºº‰∫éÁ∫øÊÆµÊ†ë$lazy$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x];start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x];end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x];*/const int MAXN = 1e5 + 10;int belong[MAXN], tot = 1, a[MAXN], n, cnt;struct block &#123; int lazy; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // cin &gt;&gt; a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); // cin &gt;&gt; opt&gt;&gt; l &gt;&gt; r &gt;&gt; c; if (opt) cout &lt;&lt; p[belong[r]].lazy + a[r] &lt;&lt; endl; else &#123; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) a[j] += c; &#125; &#125; return 0;&#125; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 2ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞ÂàóÔºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂå∫Èó¥Âä†Ê≥ïÔºåËØ¢ÈóÆÂå∫Èó¥ÂÜÖÂ∞è‰∫éÊüê‰∏™ÂÄº $x$ ÁöÑÂÖÉÁ¥†‰∏™Êï∞„ÄÇ Âå∫Èó¥Âä†Ê≥ï‰ªøÁÖß$1$Âç≥ÂèØ.ÂØπ‰∫éÊØè‰∏Ä‰∏™ÂùóÂÜÖÁöÑÊï∞ÊçÆ,‰∏∫‰∫ÜÊñπ‰æøÊü•ËØ¢,Êàë‰ª¨ÂàÜ‰æøÂØπÊØè‰∏Ä‰∏™ÂùóÂÜÖÁöÑÊï∞ÊçÆËøõË°åÊéíÂ∫è.ÂØπ‰∫é‰∏çÊª°Ë∂≥ÂùóÁöÑÊï∞ÊçÆ,Êàë‰ª¨Êö¥ÂäõÂ§ÑÁêÜ,ÂÜçÂ∞ÜËøô‰∏™ÂùóÂÜÖÁöÑÊï∞ÊçÆÊéíÂ∫è,Êª°Ë∂≥ÂùóÁöÑÂå∫Èó¥,Êàë‰ª¨‰æùÁÑ∂ÊòØÊâìÊ†áËÆ∞Âç≥ÂèØ.Êü•ËØ¢ÁöÑÊó∂ÂÄô,‰∫åÂàÜÊü•ÊâæÂç≥ÂèØ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int MAXN = 1e5 + 10;/*belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x];start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x];end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN],b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for(int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //Âú®Âè≥ËæπÂ≠êÂ∫èÂàó‰∏≠Êü•Êâæ &#125; else len = half; //Âú®Â∑¶ËæπÂ≠êÂ∫èÂàóÔºàÂåÖÂê´middleÔºâ‰∏≠Êü•Êâæ &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[i]=a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = 0; c *= c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans += lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; if (p[belong[r]].end == r) ans += lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans += lowerbound(b + p[j].start, p[j].end - p[j].start + 1, c, p[j].lazy); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans += lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 3ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞ÂàóÔºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂå∫Èó¥Âä†Ê≥ïÔºåËØ¢ÈóÆÂå∫Èó¥ÂÜÖÂ∞è‰∫éÊüê‰∏™ÂÄº $x$ ÁöÑÂâçÈ©±ÔºàÊØîÂÖ∂Â∞èÁöÑÊúÄÂ§ßÂÖÉÁ¥†Ôºâ„ÄÇ Âíå$2$Á±ª‰ºº. Âá∫È¢ò‰∫∫ÁöÑÊÉ≥Ê≥ï:ÂèØ‰ª•Âú®ÂùóÂÜÖÁª¥Êä§ÂÖ∂ÂÆÉÁªìÊûÑ‰ΩøÂÖ∂Êõ¥ÂÖ∑ÊúâÊãìÂ±ïÊÄßÔºåÊØîÂ¶ÇÊîæ‰∏Ä‰∏™ set ÔºåËøôÊ†∑Â¶ÇÊûúËøòÊúâÊèíÂÖ•„ÄÅÂà†Èô§ÂÖÉÁ¥†ÁöÑÊìç‰ΩúÔºå‰ºöÊõ¥Âä†ÁöÑÊñπ‰æø„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const int MAXN = 1e5 + 10;/*belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x];start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x];end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN], b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //Âú®Âè≥ËæπÂ≠êÂ∫èÂàó‰∏≠Êü•Êâæ &#125; else len = half; //Âú®Â∑¶ËæπÂ≠êÂ∫èÂàóÔºàÂåÖÂê´middleÔºâ‰∏≠Êü•Êâæ &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; //cin &gt;&gt; a[i];//scanf("%d", &amp;a[i]); belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = -1; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) &#123; int t = lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[p[belong[l]].start+t-1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); if (p[belong[r]].end == r) &#123; int t = lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); if (t) ans = max(ans, b[p[belong[r]].start + t - 1] + p[belong[r]].lazy); &#125; else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); for (int j = belong[l] + 1; j &lt; belong[r]; j++) &#123; int t = lowerbound(b + p[j].start, p[j].end- p[j].start + 1, c, p[j].lazy); if (t) ans = max(ans, b[p[j].start + t - 1] + p[j].lazy); &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) &#123; int t = lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[l + t - 1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 4ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞ÂàóÔºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂå∫Èó¥Âä†Ê≥ïÔºåÂå∫Èó¥Ê±ÇÂíå„ÄÇ Ê±ÇÂíåÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãÂ∞±Èòî‰ª•‰∫Ü,ÊâìÊ†áËÆ∞ÁöÑÊó∂ÂÄôÊòØÈïøÂ∫¶$*$Âä†Ê≥ï 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef long long ll;const int MAXN = 1e5 + 10;/*belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x];start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x];end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x];*/ll cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; ll lazy; ll sum; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; //scanf("%d", &amp;a[i]); belong[i] = tot; p[tot].sum += a[i]; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; ll c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; ll ans = 0; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= p[belong[l]].end; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); if (p[belong[r]].end == r) ans = (ans + (p[belong[r]].lazy*(p[belong[r]].end - p[belong[r]].start + 1)) % (c + 1) + p[belong[r]].sum % (c + 1)) % (c + 1); else for (int j = p[belong[r]].start; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans = (ans + (p[j].lazy*(p[j].end - p[j].start + 1)) % (c + 1) + p[j].sum % (c + 1)) % (c + 1); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) &#123; p[belong[r]].sum += c; a[j] += c; &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; &#125; return 0;&#125; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 5ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞Âàó Ôºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂå∫Èó¥ÂºÄÊñπÔºåÂå∫Èó¥Ê±ÇÂíå„ÄÇ Ëøô‰∏™È¢òÁõÆÂÖ∂ÂÆûÊØîËæÉÊêû‰∫∫==ÂØπ‰∫é‰∏Ä‰∏™Êï∞,ÂÖ∂Â±û‰∫é${-2^{31},2^{31}-1}$,ÊúÄÂ§öÂºÄÊñπ‰∏çË∂ÖËøá$4$Ê¨°.ËøòÊòØÂíå‰πãÂâç‰∏ÄÊ†∑,Âçï‰∏™Êö¥Âäõ,Êï¥ÂùóÊ†áËÆ∞.ÂØπ‰∫é‰∏Ä‰∏™Âùó,Â¶ÇÊûúÂºÄÊñπÊ¨°Êï∞Ë∂ÖËøá$4$Ê¨°,ÊàñËÄÖÊï¥‰∏™ÂùóÂè™Êúâ$1$Êàñ$0$,Êàë‰ª¨Â∞±ÂèØ‰ª•ËÆ§‰∏∫‰∏çÈúÄË¶ÅÂØπÂÖ∂Â§ÑÁêÜ‰∫Ü,Âè™ËÆ∞‰∏ãÂíåÂç≥ÂèØ.Ëá™Â∑±‰ª£Á†ÅÂÆûÁé∞ÁöÑÊó∂ÂÄô,Ê≥®ÊÑèÁªÜËäÇ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200typedef long long ll;const int MAXN = 1e5 + 10;/* belong[x]:ÂÖÉÁ¥†xÊâÄÂú®ÁöÑÂùóÁöÑÁºñÂè∑ÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫bl[x]; start[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂ∑¶ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫st[x]; end[x]:ÁºñÂè∑‰∏∫xÁöÑÂùóÁöÑÊúÄÂè≥ËæπÁöÑÁÇπÔºåÊ†∑‰æã‰ª£Á†Å‰∏≠‰∏∫ed[x]; */int cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; int lazy; ll sum; int start, end; bool f; block() &#123; lazy = start = end = sum = 0; f = false;&#125;&#125; p[MAXN];void built() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; // scanf("%d", &amp;a[i]); belong[i] = tot; if (a[i] != 0) p[tot].sum++; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125;&#125;void print(int l, int r) &#123; ll ans = 0, c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; if (p[belong[r]].end == r) if (p[belong[r]].lazy &gt; 4 || p[belong[r]].f) ans += p[belong[r]].sum; else &#123; p[belong[r]].f = true; for (int i = p[belong[r]].start; i &lt;= p[belong[r]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[r]].f = false; ans += x; &#125; &#125; else for (int i = p[belong[r]].start; i &lt;= r; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; for (int i = belong[l] + 1; i &lt; belong[r]; i++) if (p[i].lazy &gt; 4 || p[i].f) ans += p[i].sum; else &#123; p[i].f = true; for (int j = p[i].start; j &lt;= p[i].end; j++) &#123; int lazy = p[i].lazy, x = a[j]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[i].f = false; ans += x; &#125; &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= r; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125;void update(int l, int r) &#123; ll c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy++; else for (int i = l; i &lt;= p[belong[l]].end; i++) a[i] = sqrt(a[i]); if (p[belong[r]].end == r) p[belong[r]].lazy++; else for (int i = p[belong[r]].start; i &lt;= r; i++) a[i] = sqrt(a[i]); for (int i = belong[l] + 1; i &lt; belong[r]; i++) p[i].lazy++; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy++; else for (int i = l; i &lt;= r; i++) a[i] = sqrt(a[i]);&#125;int main() &#123; built(); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; // scanf("%d %d %d %d", // &amp;opt, // &amp;l, &amp;r, &amp;c); if (opt) print(l, r); else update(l, r); &#125; return 0;&#125; Êï∞ÂàóÂàÜÂùóÂÖ•Èó® 6ÁªôÂá∫‰∏Ä‰∏™Èïø‰∏∫ $n$ ÁöÑÊï∞ÂàóÔºå‰ª•Âèä $n$ ‰∏™Êìç‰ΩúÔºåÊìç‰ΩúÊ∂âÂèäÂçïÁÇπÊèíÂÖ•ÔºåÂçïÁÇπËØ¢ÈóÆÔºåÊï∞ÊçÆÈöèÊú∫ÁîüÊàê. Âà∞‰∫ÜÂñúÈóª‰πêËßÅÁöÑÂä®ÊÄÅÂàÜÂùó‰∫Ü$23333$.$c++$ÁöÑ$vector$Â§ßÊ≥ïÂ•Ω,ÊàëÊòØ‰∏ç‰ºöÁî®ÊåáÈíàÂÜôÈìæË°®ÁöÑ,ÊãíÁªùÊØèÊ¨°ÊèíÂÖ•‰∏Ä‰∏™Êï∞,Â∞±ÊâæÂà∞ÂØπÂ∫îÁöÑÂùó,ÊâîËøõÂéªÂ∞±Ë°å.Â∞ÜÊèíÂÖ•ÁöÑÊ¨°Êï∞ËÆ∞‰∏ãÊù•,ÂΩìÊ¨°Êï∞Ë∂ÖËøá$\sqrt n$ÁöÑÊó∂ÂÄôÂ∞±ËøõË°åÈáçÊûÑ,‰πüÂ∞±ÊòØÈáçÊñ∞ÂàÜÂùó.ÁÑ∂ÂêéÂ∞±Ê≤°ÊúâÁÑ∂Âêé‰∫Ü. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int MAXN = 1e6 + 10;const int INF = 1e8 + 10;const int MOD = 998244353;const int ans = 11;typedef long long ll;int a[MAXN];vector&lt;int&gt;p[MAXN];int n, tot = 0, m, optt;void find(int k)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; cout &lt;&lt; p[i][k] &lt;&lt; '\n'; break; &#125; &#125;&#125;void rebuild()&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; for (int j = 0; j &lt; p[i].size(); j++) a[++num] = p[i][j]; p[i].clear(); &#125; n = num, m = sqrt(n), tot = 0; for (int i = 1; i &lt;= n; i++) &#123; p[tot].push_back(a[i]); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++;&#125;void insert(int k, int x)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; p[i].insert(p[i].begin() + k, x); optt++; break; &#125; &#125; if (optt == m) &#123; rebuild(); optt = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); p[tot].push_back(x); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++; int opt, l, r, c, q = n; for (int i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d%d",&amp;opt,&amp;l,&amp;r,&amp;c); if (opt) find(r); else insert(l, r); &#125; return 0;&#125; Êú™ÂÆåÂæÖÁª≠]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]ÈöèÊú∫Êï∞ÁîüÊàêÂô®]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[Â∫èËøô‰∏™È¢ò,ÈöæÂú®ÈòÖËØª. È¢òÁõÆÂ§ßÊÑèË∑≥Ëøá!ÈìæÊé•:üîó Ëß£Êûê È¶ñÂÖàÊ†πÊçÆÈ¢òÁõÆÂæóÂà∞‰∏Ä‰∏™ÈöèÊú∫Êï∞Âàó$\lbrace x_i=(a√óx_{i‚àí1}^2+b√óx_{i‚àí1}+c)$mod$d\rbrace$ÂÖ∂‰∏≠$i\in{1‚Ä¶n√óm}$ Êêû‰∏Ä‰∏™Êï∞Âàó$T$,ÂÖ∂‰∏≠$T_i=i$,$i\in{1‚Ä¶.n√óm}$ ÂØπÊØè‰∏ÄÈ°π$T_i$,Êàë‰ª¨$swap(T_i,$$T_{x_imodi+1})$ ‰ª•‰∏ä$3$Ê≠•ÁªìÊùüÂêé,ÂæóÂà∞ÁöÑÂ∞±ÊòØÊ£ãÁõòË¶ÅÂ°´ÁöÑÊï∞$T_i$ Ê†∑‰æã‰∏ÄÊï∞ÊçÆÁîüÊàêÁöÑÊ£ãÁõòÂ¶Ç‰∏ã: 12917 51162 41038 &emsp;&emsp;Ë∑ØÁ∫ø‰æøÊòØ$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;‰∏Ä‰∏™ÊúâÊäÄÂ∑ßÁöÑË¥™ÂøÉÊù•ÈÄâÊï∞.&emsp;&emsp;È¶ñÂÖà,$map[1][1]$ÂøÖÂÆöÈÄâ.&emsp;&emsp;Â¶ÇÊûúÊàë‰ª¨‰∏çËÄÉËôëÊ£ãÁõòÈ°∫Â∫è,Ëã•Ë¶ÅÂ∫èÂàóÊúÄÂ∞è,ÊòæÁÑ∂ÊòØÈÄâÊúÄÂ∞èÊï∞ÁöÑÊîæËøõÂéª,ÈÇ£‰πàÊàë‰ª¨‰æø‰ªé$1$Ëøô‰∏™Êï∞ÂºÄÂßãË¥™ÂøÉ.ÈÇ£‰πà,Ëøô‰∏™Êï∞Êàë‰ª¨‰ªÄ‰πàÊó∂ÂÄôÊâçÂèñÂÆÉÂë¢?&emsp;&emsp;Ê†πÊçÆÈ¢òÁõÆË¶ÅÊ±Ç,Êàë‰ª¨‰ªéÂ∑¶‰∏äËßíÂà∞Âè≥‰∏ãËßí,Âè™ËÉΩÂêëÂè≥ÊàñËÄÖÂêë‰∏ãËµ∞,Âè™Ë¶ÅÈÄâËøáÁöÑÊï∞Âú®Ë¶ÅÈÄâÁöÑÊï∞Â∑¶‰∏äÊñπÊàñÂè≥‰∏ãÊñπÁöÑÊó∂ÂÄô,Ëøô‰∏™Êï∞ÊâçÊòØÂèØÈÄâÁöÑ,ÊàñËÄÖËØ¥ÊòØÂèØÂà∞ËææÁöÑ.&emsp;&emsp;ÂÅáËÆæÂΩìÊàë‰ª¨Ë¶ÅÈÄâ$9$Êó∂,Êàë‰ª¨Â∑≤ÁªèÈÄâ‰∫Ü$1,2,6,8,12$,Êàë‰ª¨Áúã$9$ËÉΩÂê¶Âà∞ËææÂë¢?&emsp;&emsp;ÊòæÁÑ∂,Â∑¶‰æßÁ¶ªÂÆÉÊúÄËøëÁöÑÊï∞Ë¶Å$\ge$ÂÆÉÁöÑË°å,Âè≥‰æßÁ¶ªÂÆÉÊúÄËøëÁöÑÊï∞Ë¶Å$\leq$ÂÆÉÁöÑË°å.ËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•ÈÄâÂÆÉ.&emsp;&emsp;ÂΩìÁÑ∂,ÈÄâÂÆåÂêéÊõ¥Êñ∞$L[],R[]$. Âç≥‰ª£Á†Å: 123456789101112//x‰∏∫Ë°å,y‰∏∫Âàó//nË°å,mÂàófor (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;ÁêÜËß£‰∫ÜËøô‰∏™Ë¥™ÂøÉ,È¢òÁõÆÂ∞±ÂæàÊ∞¥‰∫Ü.&emsp;&emsp;ÊçÆËØ¥Ë¶ÅÊ≥®ÊÑèÁ©∫Èó¥,Êó∂Èó¥‚Ä¶..ÂÖ®Á®ãcinÂ•ΩÂÉèÊ≤°Âï•‰∫ã. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>Ê®°Êãü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈÇ£‰∫õÂπ¥ÊàëÊê≠ÂçöÂÆ¢ÊâÄË∏©ÁöÑÂùë]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[‰∏Ä.ÂçöÊñáÊèíÂÖ•ÂõæÁâáÂú® Hexo‰∏≠ ÊèíÂÖ•ÂõæÁâáÊó∂ÔºåËØ∑ÊåâÁÖß‰ª•‰∏ãÁöÑÊ≠•È™§ËøõË°åËÆæÁΩÆ Â∞Ü Á´ôÁÇπÈÖçÁΩÆÊñá‰ª∂ ‰∏≠ÁöÑ post_asset_folde ÈÄâÈ°πÁöÑÂÄºËÆæÁΩÆ‰∏∫ true Âú®Á´ôÁÇπÊñá‰ª∂Â§π‰∏≠ÊâìÂºÄ git bashÔºåËæìÂÖ•ÂëΩ‰ª§ npm install hexo-asset-image --save ÂÆâË£ÖÊèí‰ª∂ ËøôÊ†∑ÔºåÂΩì‰ΩøÁî® hexo new title ÂàõÂª∫ÊñáÁ´†Êó∂ÔºåÂ∞ÜÂêåÊó∂Âú® source/_post Êñá‰ª∂Â§π‰∏≠ÁîüÊàê‰∏Ä‰∏™‰∏é title ÂêåÂêçÁöÑÊñá‰ª∂Â§πÔºåÊàë‰ª¨Âè™ÈúÄÂ∞ÜÂõæÁâáÊîæËøõÊ≠§Êñá‰ª∂Â§π‰∏≠ÔºåÁÑ∂ÂêéÂú®ÊñáÁ´†‰∏≠ÈÄöËøá Markdown ËØ≠Ê≥ïËøõË°åÂºïÁî®Âç≥ÂèØ ‰æãÂ¶ÇÔºåÂú®ËµÑÊ∫êÊñá‰ª∂Â§πÔºàÂ∞±ÊòØÈÇ£‰∏™‰∏é title ÂêåÂêçÁöÑÊñá‰ª∂Â§πÔºâ‰∏≠Ê∑ªÂä†ÂõæÁâá example.PNGÔºåÂàôÂèØ‰ª•Âú®ÂØπÂ∫îÁöÑÊñáÁ´†‰∏≠‰ΩøÁî®ËØ≠Âè• ![Á§∫‰æãÂõæÁâá](title/example.PNG &quot;Á§∫‰æãÂõæÁâá&quot;) Ê∑ªÂä†ÂõæÁâá ‰∫å.‰øÆÊîπÂçöÂÆ¢Ê†áÈ¢òËÉåÊôØÂ¶ÇÊûú‰Ω†‰ΩøÁî®ÁöÑÊòØpiscesÊ®°ÂºèÁöÑËØù,ÂèØ‰ª•ÂèÇËÄÉ‰∏ãÂàóÊïôÁ®ãÂú®\blog\themes\next\source\css\_schemes\Pisces‰∏≠ÁöÑ_brand.stylÊñá‰ª∂ÂÜÖ.Âú®.site-meta ‰∏ãÁöÑbackgroundÂêéÈù¢‰øÆÊîπ‰∏∫url(ÂõæÁâáÈìæÊé•); ‰∏â.ÊèíÂÖ•Èü≥‰πêÂú®ÁΩëÊòì‰∫ëÈü≥‰πêÁîüÊàêÂ§ñÈìæÂêéÊèíÂÖ•Âà∞‰Ω†ÊÉ≥ÊîæÁöÑÂú∞ÊñπÂç≥ÂèØ.Ê≥®ÊÑè:‰∏çË¶ÅÊâìÂºÄ‚ÄùÈòªÊ≠¢Á¨¨‰∏âÊñπ Cookie‚ÄùËøô‰∏™ÈÄâÈ°π‰∏ÄÊó¶ÊâìÂºÄ,iframeÂ∞±Âä†ËΩΩ‰∏çÂá∫Êù•,ÊèíÂÖ•Èü≥‰πêÈÇ£‰∏ÄÂùóÂÖ®ÁôΩ.ÁΩë‰∏ä‰πüÊ≤°ÊúâÂ§öÂ∞ë‰∫∫ÁªèÂéÜËøá‰º∞ËÆ°(ÈÄºÁùÄÊàëÂ≠¶‰ºö‰∫ÜÁúãF12‚Ä¶) Âõõ.npm‰∏ãËΩΩË∂ÖÊÖ¢ÁöÑÈóÆÈ¢ò‰ΩøÁî®cnpm,ËøôÊòØÂõΩÂÜÖÁöÑ‰∏Ä‰∏™ÈïúÂÉè,ÈÄüÂ∫¶ÂæàÂø´,‰ΩÜÊó†Ê≥ï‰ΩøÁî®publishÈìæÊé•:https://npm.taobao.org/ ‰∫î.AlgoliaÊêúÁ¥¢Êê≠Âª∫ÁöÑÈóÆÈ¢ònextÁöÑ‰ΩøÁî®ÊñáÊ°£Â∑≤ÁªèÊØîËæÉÂÖ®Èù¢‰∫Ü Ëøô‰∏™Âú∞ÊñπË¶ÅÂä†‰∏ÄÂè• 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 ÂÖ∂Ê¨°Áî®export,ÊúÄÂ•Ω‰∏çË¶ÅÁî®set 12export HEXO_ALGOLIA_INDEXING_KEY=‰Ω†ÁöÑSearch-Only API Key$ hexo algolia Ëøô‰∫õÈÉΩÈÄâ‰∏ä ÂÖ≠.Â§¥ÂÉèÊóãËΩ¨‰ª•ÂèäÁÇπÂáªÂ§¥ÂÉèÂõûÂà∞‰∏ªÈ°µ ÂõûÂà∞‰∏ªÈ°µ:Âú®123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; Â∞±ÊòØÂú®‰ª£Á†Å‰∏ä‰∏ãÂàÜÂà´Âä†‰∫Ühref1232. ÊóãËΩ¨~~Ëøô‰∏™Êàë‰πü‰∏çÊáÇ~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl ÂÜÖÊ∑ªÂä†: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* Â§¥ÂÉèÂúÜÂΩ¢ */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* ËÆæÁΩÆÂæ™ÁéØÂä®Áîª [animation: (play)Âä®ÁîªÂêçÁß∞ (2s)Âä®ÁîªÊí≠ÊîæÊó∂ÈïøÂçï‰ΩçÁßíÊàñÂæÆÁßí (ase-out)Âä®ÁîªÊí≠ÊîæÁöÑÈÄüÂ∫¶Êõ≤Á∫ø‰∏∫‰ª•‰ΩéÈÄüÁªìÊùü (1s)Á≠âÂæÖ1ÁßíÁÑ∂ÂêéÂºÄÂßãÂä®Áîª (1)Âä®ÁîªÊí≠ÊîæÊ¨°Êï∞(infinite‰∏∫Âæ™ÁéØÊí≠Êîæ) ]*/ /* Èº†Ê†áÁªèËøáÂ§¥ÂÉèÊóãËΩ¨360Â∫¶ */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* Èº†Ê†áÁªèËøáÂÅúÊ≠¢Â§¥ÂÉèÊóãËΩ¨ -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* Èº†Ê†áÁªèËøáÂ§¥ÂÉèÊóãËΩ¨360Â∫¶ */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z ËΩ¥ÊóãËΩ¨Âä®Áîª */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; Êê≠Âª∫ËØÑËÆ∫Âå∫ Â§öËØ¥ ÁΩëÊòì‰∫ëË∑üÂ∏ñ ÁïÖË®Ä Êù•ÂøÖÂäõÔºàLiveReÔºâ Disqus Hypercomments valinevaline YES!( ‚Ä¢ÃÄ œâ ‚Ä¢ÃÅ )yËôΩÁÑ∂ÂõΩÂÜÖÁâàÈúÄË¶ÅÂ§áÊ°à,‰ΩÜÊòØÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî®ÂõΩÈôÖÁâàÁöÑüîó Ê≥®ÂÜå È™åËØÅÈÇÆÁÆ±ÂíåÊâãÊú∫Âè∑ ÂàõÂª∫‰∏Ä‰∏™Â∫îÁî®ÔºåÂêçÂ≠óÂèØ‰ª•Èöè‰æøËµ∑ ËøõÂÖ•Â∫îÁî®-&gt;ËÆæÁΩÆ-&gt;Â∫îÁî®$key$ Â§çÂà∂ $appid$ Âíå $appkey$ ËøõÂÖ•‰∏ªÈ¢òÈÖçÁΩÆÊñá‰ª∂ÊêúÁ¥¢ $valine$ 12345678910valine: enable: Áî±falseÊîπÊàêtrue app_id: Ë¶ÅÂ°´ app_key: Ë¶ÅÂ°´ notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ÂèØÊîπ avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size Âú®Leancloud -&gt; ËÆæÁΩÆ -&gt; ÂÆâÂÖ®‰∏≠ÂøÉ -&gt; Web ÂÆâÂÖ®ÂüüÂêç Êää‰Ω†ÁöÑÂüüÂêçÂä†ËøõÂéª$d$‰∏Ä‰∏ãÂÆåÊàê. ÂÖàËøô‰∫õ,ÊåÅÁª≠Êõ¥Êñ∞]]></content>
      <categories>
        <category>ÊùÇÊñá</category>
      </categories>
      <tags>
        <tag>ÂçöÂÆ¢Êê≠Âª∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ÊçÆÁªìÊûÑ-ÂàíÂàÜÊ†ëÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ÂºïÂ¶ÇÈ¢ò:POJ2014ÁªôÂÆö‰∏Ä$n$‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÁªÑ,ÊØèÊ¨°Êü•ËØ¢$[l,r]$Âå∫Èó¥ÂÜÖ‰ªéÂ∞èÂà∞Â§ßÁ¨¨k‰∏™Êï∞.Êú¥Á¥†Ëß£Ê≥ï‰∏∫Â∞ÜÊï∞ÁªÑ$[l,r]$ÂÜÖÁöÑÊï∞ÊéíÂ∫è,ÁÑ∂ÂêéÈÄâÊã©Á¨¨$k$‰∏™Âç≥ÂèØ.ÊúÄÂùèÊÉÖÂÜµ$O(m*n)$.Ëøô‰∏™Êó∂ÂÄô,Â∞±ÈúÄË¶ÅÊõ¥Â•ΩÁöÑÊï∞ÊçÆÁªìÊûÑ,ÂàíÂàÜÊ†ë/ÂΩíÂπ∂Ê†ë. ÂÆö‰πâÂéüÊï∞ÁªÑ‰∏∫${4,2,5,7,1,8,3,6}$,Âú®ÊØèÊ¨°ÂàíÂàÜÂ∑¶Âè≥Â≠êÊ†ëÊó∂ÁöÑ‰∏≠ÂÄº,ÈÉΩÁî®Á∫¢Ëâ≤Ë°®Êòé.Â∞è‰∫é‰∏≠ÂÄºÁöÑËøõÂÖ•Â∑¶Â≠êÊ†ë,Â§ß‰∫é‰∏≠ÂÄºÁöÑËøõÂÖ•Âè≥Â≠êÊ†ë.ËßÇÂØüÊàë‰ª¨ÂèëÁé∞,ÊØè‰∏ÄÂ±ÇÈÉΩÊòØÊï∞ÁªÑ$n$,Âè™‰∏çËøáÈ°∫Â∫èÊúâ‰∫ÜÂèòÂåñ.ËÄåÂØπ‰∫é$log2(1e9)$Ëøô‰∏™Êï∞,‰πü‰∏çËøá$20$.ÊâÄ‰ª•Êàë‰ª¨ÂÆö‰πâ‰∏Ä‰∏™$tree[20][n]$ÁöÑÊï∞ÁªÑ,Áî®Êù•Â≠òÊ†ë. 12//toleftÁ®çÂêéÂÜçËÆ≤int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; Âª∫Ê†ëÊàë‰ª¨ÂÆö‰πâ‰∏Ä‰∏™Êï∞ÁªÑ$toleft[20][MAXN]$,ÂÖ∂ÊåáÂú®ÊüêÊï∞ÁöÑÂ∑¶ËæπÊâÄÊúâËøõÂÖ•Â∑¶Â≠êÊ†ëÁöÑÊï∞ÁöÑ‰∏™Êï∞.toleftÊï∞ÁªÑ 123456789101112Á¨¨‰∏ÄÊ¨°ÂàíÂàÜ[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] Áúãi-thÂâçÈù¢ÊúâÂ§öÂ∞ë‰∏™Êï∞ËøõÂÖ•Â∑¶Â≠êÊ†ë.Á¨¨‰∫åÊ¨°ÂàíÂàÜ[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]Á¨¨‰∏âÊ¨°ÂàíÂàÜ[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]Á¨¨ÂõõÊ¨°ÂàíÂàÜ[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //sameÂÄºÊåáÁõ∏ÂêåÁöÑ‰∏≠ÂÄº if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //Â∞Ü[l,r]ÂÜÖÁöÑÊï∞ÂàíÂàÜ if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //ËÆ∞‰∏ãÂΩìÂâçÊï∞ÁöÑtoleftÂÄº &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; Êü•ËØ¢Á±ª‰ºº‰∫éÁ∫øÊÆµÊ†ëÁöÑÂçïÁÇπÊü•ËØ¢Âè™ÈúÄË¶ÅËÄÉËôë‰∏Ä‰∏™‰∏çÁ≠âÂºè$toleft[dep][r] - toleft[dep][l - 1]\leq k$Â¶ÇÊûúÊàêÁ´ã,ËØ¥ÊòéËøô‰∏™Êï∞Ë¢´ÂàíËøõ‰∫ÜÂ∑¶Â≠êÊ†ë.ÈÇ£‰πàÂ§ßÂå∫Èó¥$[L,(L+R)&gt;&gt;1]$,Â∞èÂå∫Èó¥$[l,r]$Âèò‰∏∫$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$Â¶ÇÊûú$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$ÈÇ£‰πà,Ëøô‰∏™Êï∞Â∞±Ë¢´ÂàíËøõ‰∫ÜÂè≥Â≠êÊ†ë,ÈÇ£‰πàÂ§ßÂå∫Èó¥Âèò‰∏∫$[(L+R)&gt;&gt;1+1,R]$,Â∞èÂå∫Èó¥Âèò‰∏∫$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.ËøôÊ†∑‰∏çÊñ≠ÈÄíÂΩí,ÂΩìÂ∞èÂå∫Èó¥$l==r$Êó∂,‰æøÁ°ÆÂÆö‰∫Ü‰ªéÂ∞èÂà∞Â§ßÁ¨¨$k$‰∏™Êï∞ÊòØÂá†. 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; ÂÆåÊï¥‰ª£Á†ÅÂΩìÊÉ≥Êü•ËØ¢‰ªéÂ§ßÂà∞Â∞èÁ¨¨$k$‰∏™Êï∞,ÂàôÂ∞Ü(tree[dep][i] < sorted[mid])```Êîπ‰∏∫```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```Êîπ‰∏∫‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÂç≥ÂèØ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; ÁªÉ‰π†È¢òÁõÆÊ¥õË∞∑P2048]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>ÂàíÂàÜÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êï∞ÊçÆÁªìÊûÑ-Á∫øÊÆµÊ†ëÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Ê¨¢ËøéÂêÑÂ§ß‰Ω¨ÔºåÂ§ßÁâõÂØπÊú¨ÊñáÊåáÊ≠£Ôºå‰πüÂ∏åÊúõÊú¨ÊñáËÉΩÂØπÂêÑ‰ΩçÊúâÊâÄÂ∏ÆÂä© Êú¨ÁØáÂæàÂ§öÂú∞ÊñπÂÄüÈâ¥Ëã±ÈõÑÂì™ÈáåÂá∫Êù•ÁöÑÂçöÂÆ¢%%% ‰∏Ä„ÄÅÂü∫Êú¨Ê¶ÇÂøµ Á∫øÊÆµÊ†ëÊòØ‰∏ÄÊ£µ‰∫åÂèâÊêúÁ¥¢Ê†ëÔºåÂÆÉÂÇ®Â≠òÁöÑÊòØ‰∏Ä‰∏™Âå∫Èó¥ÁöÑ‰ø°ÊÅØ„ÄÇ ÊØè‰∏™ËäÇÁÇπ‰ª•ÁªìÊûÑ‰ΩìÁöÑÊñπÂºèÂ≠òÂÇ®ÔºåÁªìÊûÑ‰ΩìÂåÖÂê´‰ª•‰∏ãÂá†‰∏™‰ø°ÊÅØÔºöÊØè‰∏™ËäÇÁÇπ‰ª•ÁªìÊûÑ‰ΩìÁöÑÊñπÂºèÂ≠òÂÇ®ÔºåÁªìÊûÑ‰ΩìÂåÖÂê´‰ª•‰∏ãÂá†‰∏™‰ø°ÊÅØÔºö (1). Âå∫Èó¥Â∑¶Á´ØÁÇπ„ÄÅÂè≥Á´ØÁÇπ (2). Âå∫Èó¥ÊâÄ‰ª£Ë°®ÁöÑÂÄº (3). ËØ•ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ Á∫øÊÆµÊ†ëÁöÑÂü∫Êú¨ÊÄùÊÉ≥Ôºö‰∫åÂàÜ„ÄÇ Á∫øÊÆµÊ†ë‰∏ÄËà¨ÁªìÊûÑÂ¶ÇÂõæÊâÄÁ§∫ÔºöÂÅáËÆæÊï∞ÊçÆ‰∏∫4‰∏™Êï∞ÔºåÂàôÊ†ëÂ∫îÊòØËøôÊ†∑ Áî±‰∏äÂõæÂèØÁü•ÔºåÊØè‰∏™ËäÇÁÇπÁöÑ ÊØè‰∏™ËäÇÁÇπÁöÑÂ∑¶Â≠©Â≠êÂå∫Èó¥ËåÉÂõ¥‰∏∫[leftÔºåmid]ÔºåÂè≥Â≠©Â≠ê‰∏∫[mid+1,right] ‰∫å„ÄÅ‰ª£Á†ÅÂÆûÁé∞‰∏éÂü∫Êú¨Êìç‰Ωú0.Âü∫Á°ÄÊï∞ÊçÆÁªìÊûÑ123456789#ifndef NULL //Èò≤Êä•Èîô#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.Âª∫Ê†ë builtÂáΩÊï∞12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,cÁî®Ê≥ï //Áî≥ËØ∑‰∏Ä‰∏™Êñ∞ÂÜÖÂ≠òÔºåÂπ∂‰ª§pÊåáÂêëËØ•Â§Ñ p-&gt;left = left; //ÂÇ®Â≠òÂå∫Èó¥‰ø°ÊÅØ p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,ÁöÜÂèØÔºåÂèäÂÇ®Â≠òÊï∞ÊçÆ p-&gt;lson = NULL; //‰ª§Â∑¶ÂÑøÂ≠êÂíåÂè≥ÂÑøÂ≠êÊåáÂêëNULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //‰∫åÂàÜ p-&gt;lson = built(left, mid); //Â∑¶ÂÑøÂ≠ê p-&gt;rson = built(mid + 1, right); //Âè≥ÂÑøÂ≠ê p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //Â≠òÂÇ®Â∑¶ÂÑøÂ≠êÂíåÂè≥ÂÑøÂ≠êÁöÑÂíå &#125; return p; //ËøîÂõûÊåáÂêëËØ•Â§ÑÁöÑÊåáÈíà&#125; &emsp;&emsp;Èô§‰∫ÜÂª∫Ê†ëÔºåÁõ∏Â∫îÂÖ≥Èó≠Ê†ëÁöÑÂáΩÊï∞‰∏∫Ôºö 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cÁî®Ê≥ï &#125; return;&#125; &emsp;ÈùûÂ∏∏ÈúÄË¶ÅÊ≥®ÊÑèÁöÑ‰∏Ä‰ª∂‰∫ãÔºåÊØèÊ¨°Áî®ÊåáÈíàÂª∫Á´ãÊ†ëÁöÑÊó∂ÂÄôÔºåËØ∑Âä°ÂøÖÂÜô‰∏Ä‰∏™ÂÖ≥Èó≠Ê∏ÖÁêÜÁî≥ËØ∑ÁöÑÂÜÖÂ≠òÁöÑÂáΩÊï∞ 2. ÂçïÁÇπÊü•ËØ¢&emsp;&emsp;(1).Êü•Êâæk‰ΩçÁΩÆÁöÑÊï∞ÊçÆ 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.ÂçïÁÇπ‰øÆÊîπ&emsp;&emsp;(1).Áü•ÈÅìÁÇπÊâÄÂú®‰ΩçÁΩÆÔºå‰øÆÊîπËØ•ÁÇπÂ§ÑÂÄº 123456789int update(Node p, int x,int k) //ÂØπx‰ΩçÁΩÆÁöÑÂÄºÔºåËøõË°åkÂÄºÁöÑÂèòÂä®&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //Â¶ÇËøáÊâæÂà∞‰∫Ük‰ΩçÁΩÆ return p-&gt;d +=k; //ÂØπËØ•ÁÇπÂÄºËøõË°åÊìç‰ΩúÔºåÂèØ‰ª•‰∏∫+-*/Á≠â int mid = (p-&gt;left + p-&gt;right) / 2; //Âà§Êñ≠ËØ•ÁÇπÂú®Â∑¶Âå∫Èó¥ËøòÊòØÂè≥Âå∫Èó¥ if (x &lt;= mid) //Â¶ÇÊûúÊòØÂ∑¶Âå∫Èó¥ÔºåÂè™ÂØπÂ∑¶Âå∫Èó¥ËøõË°åÈÄíÂΩíÊü•ËØ¢ return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //Êü•ÊâæÂÆåÂêéÂØπÁà∂ËäÇÁÇπÂ≠òÂÇ®ÂÄºËøõË°å‰øÆÊîπ return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //‰∏çÊòØËØ•ÁÇπÔºå‰πü‰∏çÂú®Â∑¶Âå∫Èó¥ÔºåÂè™ËÉΩÊòØÂè≥Âå∫Èó¥&#125; 4.Âå∫Èó¥Êü•ËØ¢&emsp;&emsp;ÊâÄÁªôÂå∫Èó¥‰ªÖÂèØËÉΩ‰∏∫‰∏äÂõæÂõõÁßçÊÉÖÂÜµ„ÄÇ&emsp;&emsp;ÈÄöËøá‰∏ÄÂÆöÊìç‰ΩúÔºåÊàë‰ª¨ÈÉΩÂèØ‰ª•Â∞Ü‰∏ä‰∏âÁßçÔºåÂÖ®ÈÉ®ËΩ¨Êç¢‰∏∫ÊúÄÂêé‰∏ÄÁßçÁõ¥Êé•ËæìÂá∫„ÄÇ&emsp;&emsp;Èó≤ËØùÂ∞ëËØ¥Ôºå‰ª£Á†ÅÂÆûÁé∞ 12345678910111213int find(Node p, int x,int y) //Ê≥®ÔºåËøôÈáåÂÅáËÆæ‰ªªÊÑèx,yÔºåÈÉΩÊúâx&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //Â¶ÇÊûúÊòØÁ¨¨ÂõõÁßçÊÉÖÂÜµÔºåÁõ¥Êé•ËøîÂõû return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //Ê±Ç‰∏≠Èó¥ÂÄº if (y &lt;= mid) //Â¶ÇÊûúÊü•ËØ¢Âå∫Èó¥Âú®midÂ∑¶ËæπÔºåÂõ†‰∏∫x&lt;y&lt;=mid return find(p-&gt;lson, x, y); //ÈÇ£‰πàÁõ¥Êé•ÈÄíÂΩíÂ∑¶ÂÑøÂ≠ê if (x &gt; mid) //Â¶ÇÊûúÊü•ËØ¢Âå∫Èó¥Âú®midÂè≥ËæπÔºåÂõ†‰∏∫mid&lt;x&lt;y return find(p-&gt;rson, x, y); //ÈÇ£‰πàÁõ¥Êé•ÈÄíÂΩíÂè≥ÂÑøÂ≠ê return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //‰∏§ÂºèÈÉΩ‰∏çÁ¨¶ÂêàÔºåÂèäx&lt;=mid&lt;y //Âàô‰ªémid‰∏∫‰∏≠Èó¥ÂÄºÂàÜÂºÄ //Â∑¶ÂÑøÂ≠êÊü•ËØ¢[x,mid],Âè≥ÂÑøÂ≠êÊü•ËØ¢[mid+1,y]&#125; 5.Âå∫Èó¥‰øÆÊîπ1234567891011int update(Node p, int x, int y, int k) //ËÆæÂå∫Èó¥‰∏∫[x,y]Ôºå‰øÆÊîπÁöÑÂÄº‰∏∫k&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //Â¶ÇÊûúÊòØËøô‰∏™Âå∫Èó¥ÂÜÖÁöÑÂÖÉÁ¥†ÔºåÂ∞±ËÆ©ÂÆÉ+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //‰∫åÂàÜ if (y &lt;= mid) //Â¶ÇÊûúÂå∫Èó¥Âú®‰∏≠ÂÄºÁöÑÂ∑¶‰æß return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //‰ªÖÈúÄÊõ¥Êñ∞Â∑¶ÂÑøÂ≠êÁöÑÂÄºÔºåÂπ∂Êõ¥Êñ∞Áà∂‰∫≤ÁöÑÂÄº if (x &gt; mid) //Â¶ÇÊûúÂå∫Èó¥Âú®‰∏≠ÂÄºÁöÑÂ∑¶‰æß return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //Âêå‰∏ä return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //Â¶ÇÊûúÂå∫Èó¥Ë¢´‰∏≠ÂÄºÂàÜÂºÄ&#125; ‰∏â.‰ºòÂåñÔºà‰∏ÄÔºâ. Lazy-TagÊáíÊ†áËÆ∞&emsp;&emsp;Êàë‰ª¨ËÄÉËôë‰∏Ä‰∏ãÂå∫Èó¥ÊîπÂÄºÁöÑËøáÁ®ãÔºöÂΩìÊõ¥ÊîπÊüê‰∏™Âå∫Èó¥ÁöÑÂÄºÁöÑÊó∂ÂÄôÔºåÂ≠êÂå∫Èó¥‰πüË∑üÁùÄÊõ¥Êîπ„ÄÇÊòæÁÑ∂ÔºåÂú®Â§ßÊï∞ÊçÆ‰∏ãÔºåËøôÊ†∑Êìç‰Ωú‰ºöÂØºËá¥TLE„ÄÇ&emsp;&emsp;ÊÄé‰πàÂäûÔºü&emsp;&emsp;ËøôÊó∂Êàë‰ª¨Â∞±ÂºïÂÖ•‰∏Ä‰∏™‰ºòÂåñÊñπÊ≥ïÔºåÂè´ÂÅöLazy-TagÊáíÊ†áËÆ∞„ÄÇ&emsp;&emsp;‰Ωï‰∏∫ÊáíÊ†áËÆ∞Âë¢ÔºüÈ°æÂêçÊÄù‰πâÔºåÂ∞±ÊòØÁî®Êù•ÂÅ∑ÊáíÁöÑÂáèÂ∞ë‰øÆÊîπÊó∂Ê∂àËÄóÊó∂Èó¥ÁöÑ„ÄÇÂç≥Ôºö&emsp;&emsp;ÂΩìÊàëÊÉ≥Ë¶ÅÂØπÊüê‰∏ÄÂå∫Èó¥ÁöÑÊâÄÊúâÂÖÉÁ¥†ÈÉΩ+kÊó∂ÔºåÂú®‰øÆÊîπËØ•Âå∫Èó¥ËäÇÁÇπÊó∂ÔºåÂØπÂÖ∂Êâì‰∏äÊ†áËÆ∞lazyÔºåÂπ∂ËÆ∞lazy‰∏∫kÔºå‰øÆÊîπËØ•ËäÇÁÇπÁöÑÂÄº‰∏∫+Âå∫Èó¥ÈïøÂ∫¶*kÔºåÁ´ãÂàªreturnÔºåËÄå‰∏çÂ∞ÜËØ•ËäÇÁÇπ‰∏ãÈù¢ÁöÑÊâÄÊúâÂ≠êËäÇÁÇπ‰∏Ä‰∏Ä‰øÆÊîπ„ÄÇ ÊÄùÊÉ≥ÂÆûÁé∞&emsp;&emsp;Â¶ÇÂõæÁ§∫Ôºö1~4ÁöÑÂÄºÂàÜÂà´‰∏∫1Ôºå2Ôºå3Ôºå4&emsp;&emsp;Êàë‰ª¨ÈÄâÊã©ÂØπ[1,2]Âå∫Èó¥ËøõË°å‰øÆÊîπÔºåË¶ÅÊ±ÇÊîπÂå∫Èó¥ÊâÄÊúâÂÄº+2ÔºåÂàôÔºöÂú®Âå∫Èó¥[1,2]ÔºåÊâì‰∏äÊ†áËÆ∞lazy=2ÔºåÂπ∂‰øÆÊîπÂÖ∂ÂÄº‰∏∫3+(2-1+1)2ÔºåÁõ¥Êé•ËøîÂõûÔºåÂπ∂‰∏çÂØπÂÖ∂Â≠êËäÇÁÇπËøõË°å‰øÆÊîπ&emsp;&emsp;ÂΩìÊàë‰ª¨ÂÜçÊ¨°ÂØπ[1,2]Âå∫Èó¥‰øÆÊîπÊó∂ÔºåÂπ∂Ë¶ÅÊ±ÇÂå∫Èó¥ÂÜÖÊâÄÊúâÁöÑÂÄº+1ÔºåÂàôÔºöÁî±‰∫é[1,2]ÊúâÊ†áËÆ∞lazy=2Ôºå‰∫éÊòØÊàë‰ª¨Â∞ÜlazyÊ†áËÆ∞ÂêëÂÖ∂Â≠êËäÇÁÇπ‰º†ÂØºÔºåÂπ∂‰øÆÊîπÂÖ∂Â≠êËäÇÁÇπÁöÑÂÄº„ÄÇÂÜçÂú®[1,2]Âå∫Èó¥Êâì‰∏älazy=1Ôºå‰øÆÊîπÂÄº‰∏∫(2-1+1)1ÔºåËøîÂõû„ÄÇ ‰ª£Á†ÅÂÆûÁé∞0.Ê†∏ÂøÉ‰ª£Á†Å pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //Â¶ÇÊûúËØ•ËäÇÁÇπËøòÊúâÂêéÁª≠ËäÇÁÇπ p-&gt;lson-&gt;lazy += p-&gt;lazy; //‰ª§Â≠êËäÇÁÇπlazyÁªßÊâøÁà∂ËäÇÁÇπlazyÔºå‰∏ãÂêå p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //‰øÆÊîπÂ≠êËäÇÁÇπÁöÑÂÄºÔºå‰∏ãÂêå p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //‰ª§ËØ•ËäÇÁÇπÁöÑlazyÊ∏ÖÈõ∂&#125; 1.Ê†ëÊú¨‰Ωì123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //‰ªÖ‰ªÖÂ§ö‰∫Ü‰∏Ä‰∏™lazyÊ†áËÆ∞ int left, right; Node lson, rson;&#125;*root; 2.Âª∫Ê†ë12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //Âè™ÊòØÂØπlazyÊ†áËÆ∞ËøõË°åÂàùÂßãÂåñ if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cÁî®Ê≥ï &#125; return;&#125; 3.ÂçïÁÇπÊü•ËØ¢ÂíåÂçïÁÇπ‰øÆÊîπÊó†ÊîπÂèò4.Âå∫Èó¥Êü•ËØ¢12345678910111213long long find(Node p, int x, int y) //Âå∫Èó¥Êü•ËØ¢&#123; if (p-&gt;lazy != 0) //Ëß£ÂÜ≥‰∏Ä‰∏ãÂéÜÂè≤ÈÅóÁïôÈóÆÈ¢òÂÜçÊü•ËØ¢ pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //ÂÖ∂‰ªñÊú™Âèò return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.Âå∫Èó¥‰øÆÊîπ123456789101112131415int update(Node p, int x, int y, int k) //Âå∫Èó¥‰øÆÊîπ&#123; if (p-&gt;lazy!=0) //Â¶ÇÊûúËØ•ËäÇÁÇπÁöÑlazy‰∏ç‰∏∫Èõ∂ÔºåÂ∞±Â§ÑÁêÜ‰∏Ä‰∏ã pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //Â¶ÇÊûúÊòØË¶ÅËøõË°å‰øÆÊîπÁöÑËäÇÁÇπÔºå‰æøËÆ©ËØ•ËäÇÁÇπÁöÑlazy‰∏∫kÔºåÂπ∂‰øÆÊîπÂÄº p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; Ôºà‰∫åÔºâ. Á¶ªÊï£Âåñ&emsp;&emsp;Á¶ªÊï£ÂåñÊòØ‰∏Ä‰∏™Âê¨Ëµ∑Êù•ÂæàÈ´òÂ§ß‰∏äÁöÑÊñπÊ≥ï.&emsp;&emsp;ÂÖ∂ÂÆûÂÅöËµ∑Êù•ÂæàÁÆÄÂçï.ÂΩìÁÑ∂Â¶ÇÊûúÊÉ≥È´òÊ∑±ÁöÑËØù,Ëá™ÁÑ∂‰πüÊã¶‰∏ç‰Ωè&emsp;&emsp;ÂÖ∂ÂÆûÂ∞±ÊòØÂ∞Ü‰∏Ä‰∏≤Êï∞ÊçÆÂÇ®Â≠òÂà∞Êï∞ÁªÑ‰∏≠,‰∏çÂ∞ÜÊï∞ÊçÆÊú¨Ë∫´‰Ωú‰∏∫ÈîÆÂÄº,ËÄåÊòØÈÄâÊã©‰ΩøÁî®Êï∞ÁªÑÁöÑ‰∏ãÊ†á‰Ωú‰∏∫ÈîÆÂÄº.&emsp;&emsp;ÂΩ¢Ë±°ÁöÑ,$1,2,3,10000000$ËøôÂõõ‰∏™Êï∞,‰øùÂ≠òÂú®Êï∞ÁªÑ$a[]$‰∏≠,Áõ∏ÂØπÂ∫îÁöÑ‰∏ãÊ†á‰∏∫$1,2,3,4$Â∞±ÂèØ‰ª•ÂáèÂ∞ëÁ©∫Èó¥ÁöÑÂºÄÊîØ. Êï∞ÁªÑÂÆûÁé∞1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 1e5 + 10;typedef long long ll;struct Segment_Tree &#123; ll d, lazy; int left, right; int lson, rson;&#125;root[4 * MAXN];int n;void built(int p, int left, int right)&#123; root[p].left = left; root[p].right = right; root[p].lazy = 0; if (left == right) &#123; cin &gt;&gt; root[p].d; root[p].lson = root[p].rson = null; &#125; else &#123; int mid = (left + right) &gt;&gt; 1; built(root[p].lson = (p &lt;&lt; 1), left, mid); built(root[p].rson = (p &lt;&lt; 1 | 1), mid + 1, right); root[p].d = root[root[p].lson].d + root[root[p].rson].d; &#125;&#125;void pushdown(int p)&#123; if (root[p].lson != null) &#123; root[root[p].lson].lazy += root[p].lazy; root[root[p].lson].d += (root[root[p].lson].right - root[root[p].lson].left + 1)*root[p].lazy; root[root[p].rson].lazy += root[p].lazy; root[root[p].rson].d += (root[root[p].rson].right - root[root[p].rson].left + 1)*root[p].lazy; &#125; root[p].lazy = 0;&#125;ll find(int p, int x, int y)&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) return root[p].d; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return find(root[p].lson, x, y); if (x &gt; mid) return find(root[p].rson, x, y); return find(root[p].lson, x, mid) + find(root[p].rson, mid + 1, y);&#125;long long update(int p, int x, int y, int k) //Âå∫Èó¥&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) &#123; root[p].lazy = k; return root[p].d += k * (y - x + 1); &#125; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return root[p].d = root[root[p].rson].d + update(root[p].lson, x, y, k); if (x &gt; mid) return root[p].d = root[root[p].lson].d + update(root[p].rson, x, y, k); return root[p].d = update(root[p].lson, x, mid, k) +update(root[p].rson, mid+1, y, k);&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; built(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int t, x, y, k; cin &gt;&gt; t; if (t == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1, x, y, k); &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; find(1, x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; ÁªÉ‰π†È¢òÁõÆÊ¥õË∞∑P2251Ë£∏ÁöÑRMQÈóÆÈ¢ò,Êï∞ÊçÆÈáèÂ∞è.Ê¥õË∞∑P3372Ê¥õË∞∑P3373Ê¥õË∞∑Á∫øÊÆµÊ†ëÊ®°ÊùøÈ¢ò]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMPÁÆóÊ≥ïÊ®°Êùø]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ËíüËíªÂ≠¶ËØÜÊµÖÈôã,Ê¨¢ËøéÂêÑ‰ΩçÂ§ßÁâõÊåáÊ≠£ KMP‰ªéÂÖ•Èó®Âà∞ÊîæÂºÉËØ∑ËßÇÂ∑¶Á•û‰∏∫‰ªÄ‰πàÊÉ≥Ë¶ÅÊùÄ‰∫∫%%%%njb7ÁùÄÈáçÂê¨1h12m20s$KMP$ÂàÜ‰∏∫‰∏§‰∏™ÈÉ®ÂàÜ,‰∏ÄÈÉ®ÂàÜ‰∏∫‰∏§‰∏™Â≠óÁ¨¶‰∏≤Èó¥ÁöÑÊØîËæÉ,Âè¶‰∏ÄÈÉ®ÂàÜ‰∏∫Ëá™Â∑±‰∏éËá™Â∑±ÁöÑÊØîËæÉ.ÁÆÄÂçïÁöÑÂàíÂàÜ‰∏∫‰∏ãÈù¢‰∏§‰∏™Âõæ,ËØ¶ÁªÜÁêÜËß£ËØ∑ËßÅÂ∑¶Á•û‰∏çÁ®≥ÂÆöÊÉÖÁª™ËÆ≤Ëß£.‰∏çËøáÊàë$jiao$ÁöÑÂú®$1:21:04$Êó∂,Â∞Ü‰æãÂ≠êÊç¢‰∏∫$‚Äùababcababak‚Äù$Êõ¥Â•ΩÁêÜËß£ ‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; ‰æãÈ¢òG.OulipoHDU 1686The French author Georges Perec (1936‚Äì1982) once wrote a book, La disparition, without the letter ‚Äòe‚Äô. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s‚Äôaffirmait faux. Tout avait Fair normal, d‚Äôabord, puis surgissait l‚Äôinhumain, l‚Äôaffolant. Il aurait voulu savoir o√π s‚Äôarticulait l‚Äôassociation qui l‚Äôunissait au roman : stir son tapis, assaillant √† tout instant son imagination, l‚Äôintuition d‚Äôun tabou, la vision d‚Äôun mal obscur, d‚Äôun quoi vacant, d‚Äôun non-dit : la vision, l‚Äôavision d‚Äôun oubli commandant tout, o√π s‚Äôabolissait la raison : tout avait l‚Äôair normal mais‚Ä¶ Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given ‚Äúword‚Äù as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $‚ÄôT‚Äô$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$, with $1 ‚â§ |W| ‚â§ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${‚ÄòA‚Äô, ‚ÄòB‚Äô, ‚ÄòC‚Äô, ‚Ä¶, ‚ÄòZ‚Äô}$, with $|W| ‚â§ |T| ‚â§ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 Ëß£Êûê$kmp$Ê®°Êùø,ËØªÂÖ•‰∏çËÉΩÁî®$cin$,Âê¶ÂàôË∂ÖÊó∂ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Ê®°Êùø</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]Âä®Áâ©Âõ≠]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[Â∫èË®Ä&emsp;&emsp;Ëøô‰∏™È¢òÂÜôÁöÑÊàëÂ•ΩËø∑Âïä== È¢òÁõÆÁÆÄËø∞&emsp;&emsp;Âõ≠ÈïøÊÉ≥ËÆ©‰Ω†Ê±Ç‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑ‚Äù‰∏ç‰∫íÁõ∏ÈáçÂè†ÁöÑÂÖ¨ÂÖ±ÂâçÂêéÁºÄ‰∏™Êï∞‚ÄùÁÑ∂ÂêéÂÜç‰πòËµ∑Êù•.‰∏ÄÂ§ßÈ™°Â≠êÁöÑÂ≠ó,ÊÄªÁªì‰∏Ä‰∏ãÂ∞±ÊòØËøô‰∏™ÊÑèÊÄù. Ëß£Êûê&emsp;&emsp;Â¶ÇÊûú‰Ω†‰∏ç‰ºö$KMP$‚Ä¶.ÈÇ£Êàë‰πüÊ≤°ÂäûÊ≥ï(Á¨ë)&emsp;&emsp;Êàë‰ª¨Áü•ÈÅì,$next$‰øùÂ≠òÁöÑÊòØÊúâÈáçÂè†ÈÉ®ÂàÜÁöÑÊúÄÂ§ßÈïøÂ∫¶.ÈÇ£‰πàÊàë‰ª¨Âú®ÂÆÉËÆ°ÁÆóÁöÑËøáÁ®ã‰∏≠,ÊääÂΩìÂâç$next[i]$ÁöÑ‰ΩçÁΩÆ,Â≠ò‰∏Ä‰∏™ÈïøÂ∫¶$cnt[i]$,Âï•ÊÑèÊÄù?&emsp;&emsp;Êàë$next[i]$‰ªéÂ§¥Êâ´Âà∞Â∞æ,Áõ∏ÂΩì‰∫é‰∏Ä‰∏™ÈÄíÊé®ÂæóÂà∞ÊúÄÂ§ßÈïøÂ∫¶.ÂêåÊó∂ËøõË°å$cnt[i]$‰ªéÂ§¥Êâ´Âà∞Â∞æ,Áõ∏ÂΩì‰∫éÈÄíÊé®ÂæóÂà∞ÊúÄÂ§ß‰∏™Êï∞.&emsp;&emsp;ÁÑ∂ÂêéÂÜçÁî®$next[]$Êï∞ÁªÑ,ÊâæÂà∞‰∏çÈáçÂ§çÁöÑ‰ΩçÁΩÆ,‰πüÂ∞±ÊòØ$j\leq{i/2}$ËøôÊ†∑ÁöÑ‰ΩçÁΩÆ,ËÆ°ÁÆó$cnt$,ÂÆåÊàê. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]È≠îÊ≥ïÊ£ÆÊûó]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[Â∫èË®Ä$UOJ$ÊûúÁÑ∂ÊòØÁ•û‰ªô$OJ$ÂïäÈáåÈù¢‰∏™‰∏™ÈÉΩÊòØ‰∫∫Êâç,ËØ¥ËØùËøòÂ•ΩÂê¨È¢òÁõÆÁöÑ$hack$Êï∞ÊçÆËøòÂèØ‰ª•$hack$ÊéâÁΩë‰∏ä‰∏ÄÂ§ßÁâáÁöÑÈ¢òËß£‚Ä¶.. È¢òÁõÆÊèèËø∞‰∏∫‰∫ÜÂæóÂà∞‰π¶Ê≥ïÂ§ßÂÆ∂ÁöÑÁúü‰º†ÔºåÂ∞è$E$ÂêåÂ≠¶‰∏ãÂÆöÂÜ≥ÂøÉÂéªÊãúËÆø‰ΩèÂú®È≠îÊ≥ïÊ£ÆÊûó‰∏≠ÁöÑÈöêÂ£´„ÄÇÈ≠îÊ≥ïÊ£ÆÊûóÂèØ‰ª•Ë¢´ÁúãÊàê‰∏Ä‰∏™ÂåÖÂê´‰∏™$N$ËäÇÁÇπ$M$Êù°ËæπÁöÑÊó†ÂêëÂõæÔºåËäÇÁÇπÊ†áÂè∑‰∏∫$1‚Ä¶n$ÔºåËæπÊ†áÂè∑‰∏∫$1‚Ä¶m$„ÄÇÂàùÂßãÊó∂Â∞è$E$ÂêåÂ≠¶Âú®$1$ Âè∑ËäÇÁÇπÔºåÈöêÂ£´Âàô‰ΩèÂú® $n$ Âè∑ËäÇÁÇπ„ÄÇÂ∞è$E$ÈúÄË¶ÅÈÄöËøáËøô‰∏ÄÁâáÈ≠îÊ≥ïÊ£ÆÊûóÔºåÊâçËÉΩÂ§üÊãúËÆøÂà∞ÈöêÂ£´„ÄÇÈ≠îÊ≥ïÊ£ÆÊûó‰∏≠Â±Ö‰Ωè‰∫Ü‰∏Ä‰∫õÂ¶ñÊÄ™„ÄÇÊØèÂΩìÊúâ‰∫∫ÁªèËøá‰∏ÄÊù°ËæπÁöÑÊó∂ÂÄôÔºåËøôÊù°Ëæπ‰∏äÁöÑÂ¶ñÊÄ™Â∞±‰ºöÂØπÂÖ∂ÂèëËµ∑ÊîªÂáª„ÄÇÂπ∏ËøêÁöÑÊòØÔºåÂú® $1$ Âè∑ËäÇÁÇπ‰ΩèÁùÄ‰∏§ÁßçÂÆàÊä§Á≤æÁÅµÔºö$A$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏é$B$ÂûãÂÆàÊä§Á≤æÁÅµ„ÄÇÂ∞è$E$ÂèØ‰ª•ÂÄüÂä©ÂÆÉ‰ª¨ÁöÑÂäõÈáèÔºåËææÂà∞Ëá™Â∑±ÁöÑÁõÆÁöÑ„ÄÇÂè™Ë¶ÅÂ∞èEÂ∏¶‰∏äË∂≥Â§üÂ§öÁöÑÂÆàÊä§Á≤æÁÅµÔºåÂ¶ñÊÄ™‰ª¨Â∞±‰∏ç‰ºöÂèëËµ∑ÊîªÂáª‰∫Ü„ÄÇÂÖ∑‰ΩìÊù•ËØ¥ÔºåÊó†ÂêëÂõæ‰∏≠ÁöÑÊØè‰∏ÄÊù°Ëæπ $e_i$ ÂåÖÂê´‰∏§‰∏™ÊùÉÂÄº $a_i$ ‰∏é $b_i$„ÄÇËã•Ë∫´‰∏äÊê∫Â∏¶ÁöÑ$A$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏™Êï∞‰∏çÂ∞ë‰∫é $a_i$Ôºå‰∏î$B$ÂûãÂÆàÊä§Á≤æÁÅµ‰∏™Êï∞‰∏çÂ∞ë‰∫é $b_i$ÔºåËøôÊù°Ëæπ‰∏äÁöÑÂ¶ñÊÄ™Â∞±‰∏ç‰ºöÂØπÈÄöËøáËøôÊù°ËæπÁöÑ‰∫∫ÂèëËµ∑ÊîªÂáª„ÄÇÂΩì‰∏î‰ªÖÂΩìÈÄöËøáËøôÁâáÈ≠îÊ≥ïÊ£ÆÊûóÁöÑËøáÁ®ã‰∏≠Ê≤°Êúâ‰ªªÊÑè‰∏ÄÊù°ËæπÁöÑÂ¶ñÊÄ™ÂêëÂ∞è$E$ÂèëËµ∑ÊîªÂáªÔºå‰ªñÊâçËÉΩÊàêÂäüÊâæÂà∞ÈöêÂ£´„ÄÇÁî±‰∫éÊê∫Â∏¶ÂÆàÊä§Á≤æÁÅµÊòØ‰∏Ä‰ª∂ÈùûÂ∏∏È∫ªÁÉ¶ÁöÑ‰∫ãÔºåÂ∞èEÊÉ≥Ë¶ÅÁü•ÈÅìÔºåË¶ÅËÉΩÂ§üÊàêÂäüÊãúËÆøÂà∞ÈöêÂ£´ÔºåÊúÄÂ∞ëÈúÄË¶ÅÊê∫Â∏¶ÂÆàÊä§Á≤æÁÅµÁöÑÊÄª‰∏™Êï∞„ÄÇÂÆàÊä§Á≤æÁÅµÁöÑÊÄª‰∏™Êï∞‰∏∫$A$ÂûãÂÆàÊä§Á≤æÁÅµÁöÑ‰∏™Êï∞‰∏é$B$ÂûãÂÆàÊä§Á≤æÁÅµÁöÑ‰∏™Êï∞‰πãÂíå„ÄÇ È¢òÁõÆÂ§ßÊÑè:‰ªé$1$Ëµ∞Âà∞$n$,$m$Êù°Ëæπ,Â¶Ç‰ΩïËµ∞ËÉΩ‰Ωø$a$Âíå$b$ÁöÑÂíåÊúÄÂ§ßÂÄºÊúÄÂ∞è. Ëß£ÊûêÈ¶ñÂÖà,ËøôÊòØ‰∏Ä‰∏™ÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑÈ¢òÁõÆ.ÂÖ∂Ê¨°,ËøôÂ∫îËØ•ÊòØ‰∏Ä‰∏™Âä®ÊÄÅÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑÈ¢òÁõÆ.(Â¶ÇÊûú‰Ω†Â≠¶ËøáÁî®LCTÂÅöÊúÄÂ∞èÁîüÊàêÊ†ë,Ëøô‰∏™È¢òÂ∞±ÈùûÂ∏∏ÁöÑÊ∞¥)Êàë‰ª¨Â∞Ü$a_i$ÊéíÂ∫èÂêé,ÊåâËæπÂèñ,ÂèØ‰ª•‰øùËØÅ$a_i$ÊòØÊúÄÂ∞èÁöÑ.Âú®Êåâ$a_i$Â§ßÂ∞èÂèñËæπÁöÑÊó∂ÂÄô,ÂêåÊó∂Êõ¥Êñ∞Ë∑Ø‰∏ä$b_i$ÁöÑÊúÄÂ§ßÂÄº.ÂΩìÊàë‰ª¨ÂèñÂà∞‰∏Ä‰∏™ÁéØÁöÑÊó∂ÂÄôÊÄé‰πàÂäû?ÂàóÂ¶ÇËøôÊ†∑:Êàë‰ª¨Â∞±Ë¶ÅÂØπÊñ∞Âä†ÂÖ•ÁöÑËæπ‰∏ä$b_i$ÁöÑÂÄº,ÂíåÁª¥Êä§ÁöÑÈìæ‰∏ä$b_i$ÁöÑÊúÄÂ§ßÂÄºËøõË°åÊØîËæÉ. Â¶ÇÊûúÈìæ‰∏äÁöÑÂÄºÂ§ß,ÈÇ£‰πàÊàë‰ª¨ÊääÈìæ‰∏äÊúÄÂ§ßÁöÑÈÇ£Êù°Ëæπ$cut$,Â¶Ç‰ΩïÊääÊñ∞ËæπËøû‰∏ä. Â¶ÇÊûúÊñ∞ËæπÂ§ß,Êàë‰ª¨‰æøÁõ¥Êé•Ë∑≥Ëøá. Â¶ÇÊ≠§ÂæÄÂ§ç,Áõ¥Âà∞$1$$n$ËøôÊù°Ë∑ØËøûÈÄö.ËøûÈÄöÂêé,Êàë‰ª¨Âä†ÂÖ•Âè¶‰∏Ä‰∏™Êìç‰Ωú:Âà§Êñ≠,Âä†ÂÖ•ÁöÑËøôÊù°ËæπÂØπ‰∫éÁ≠îÊ°àÁöÑÂΩ±Âìç.$a$Â§ßÂπ∂‰∏ç‰ª£Ë°®$b$‰πüÂ§ß,Âõ†‰∏∫ÈóÆÁöÑÊòØ$a+b$ÁöÑÂíå.Áõ¥Âà∞ÈÅçÂéÜÂÆåÊâÄÊúâËæπ.~Ëøá‰∫ÜÊúÄÂ∞èÁîüÊàêÊ†ëÁöÑ‰ª£Á†ÅÂ±ÖÁÑ∂Âè™Êúâ97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]Ëµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóá]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[ÊèèËø∞ ÈìæÊé•:http://uoj.ac/problem/2 21 ‰∏ñÁ∫™ÔºåËÆ∏Â§ö‰∫∫Âæó‰∫Ü‰∏ÄÁßçÂ•áÊÄ™ÁöÑÁóÖÔºöËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóáÔºåÂÖ∂‰∏¥Â∫äË°®Áé∞‰∏∫ÔºöËµ∑Â∫äÈöæÔºåËµ∑Â∫äÂêéÁ≤æÁ•û‰∏ç‰Ω≥„ÄÇ‰Ωú‰∏∫‰∏ÄÂêçÈùíÊò•Èò≥ÂÖâÂ•ΩÂ∞ëÂπ¥Ôºåatm ‰∏ÄÁõ¥ÂùöÊåÅ‰∏éËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóá‰ΩúÊñó‰∫â„ÄÇÈÄöËøáÁ†îÁ©∂Áõ∏ÂÖ≥ÊñáÁåÆÔºå‰ªñÊâæÂà∞‰∫ÜËØ•ÁóÖÁöÑÂèëÁóÖÂéüÂõ†ÔºöÂú®Ê∑±ÈÇÉÁöÑÂ§™Âπ≥Ê¥ãÊµ∑Â∫ï‰∏≠ÔºåÂá∫Áé∞‰∫Ü‰∏ÄÊù°Âêç‰∏∫ drd ÁöÑÂ∑®ÈæôÔºåÂÆÉÊéåÊè°ÁùÄÁù°Áú†‰πãÁ≤æÈ´ìÔºåËÉΩÈöèÊÑèÂª∂ÈïøÂ§ßÂÆ∂ÁöÑÁù°Áú†Êó∂Èó¥„ÄÇÊ≠£ÊòØÁî±‰∫é drd ÁöÑÊ¥ªÂä®ÔºåËµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóáÊÑàÊºîÊÑàÁÉàÔºå‰ª•ÊÉä‰∫∫ÁöÑÈÄüÂ∫¶Âú®‰∏ñÁïå‰∏ä‰º†Êí≠„ÄÇ‰∏∫‰∫ÜÂΩªÂ∫ïÊ∂àÁÅ≠ËøôÁßçÁóÖÔºåatm ÂÜ≥ÂÆöÂâçÂæÄÊµ∑Â∫ïÔºåÊ∂àÁÅ≠ËøôÊù°ÊÅ∂Èæô. ÂéÜÁªèÂçÉËæõ‰∏áËã¶Ôºåatm Áªà‰∫éÊù•Âà∞‰∫Ü drd ÊâÄÂú®ÁöÑÂú∞ÊñπÔºåÂáÜÂ§á‰∏éÂÖ∂Â±ïÂºÄËâ∞Ëã¶ÂçìÁªùÁöÑÊàòÊñó„ÄÇdrd ÊúâÁùÄÂçÅÂàÜÁâπÊÆäÁöÑÊäÄËÉΩÔºå‰ªñÁöÑÈò≤Âæ°ÊàòÁ∫øËÉΩÂ§ü‰ΩøÁî®‰∏ÄÂÆöÁöÑËøêÁÆóÊù•ÊîπÂèò‰ªñÂèóÂà∞ÁöÑ‰º§ÂÆ≥„ÄÇÂÖ∑‰ΩìËØ¥Êù•Ôºådrd ÁöÑÈò≤Âæ°ÊàòÁ∫øÁî± $n$ ÊâáÈò≤Âæ°Èó®ÁªÑÊàê„ÄÇÊØèÊâáÈò≤Âæ°Èó®ÂåÖÊã¨‰∏Ä‰∏™ËøêÁÆó$op$ Âíå‰∏Ä‰∏™ÂèÇÊï∞$t$ÔºåÂÖ∂‰∏≠ËøêÁÆó‰∏ÄÂÆöÊòØ $OR,XOR,AND$ ‰∏≠ÁöÑ‰∏ÄÁßçÔºåÂèÇÊï∞Âàô‰∏ÄÂÆö‰∏∫ÈùûË¥üÊï¥Êï∞„ÄÇÂ¶ÇÊûúËøòÊú™ÈÄöËøáÈò≤Âæ°Èó®Êó∂ÊîªÂáªÂäõ‰∏∫ $x$ÔºåÂàôÂÖ∂ÈÄöËøáËøôÊâáÈò≤Âæ°Èó®ÂêéÊîªÂáªÂäõÂ∞ÜÂèò‰∏∫ $x$ $op$ $t$„ÄÇÊúÄÁªàdrd ÂèóÂà∞ÁöÑ‰º§ÂÆ≥‰∏∫ÂØπÊñπÂàùÂßãÊîªÂáªÂäõ $x$ ‰æùÊ¨°ÁªèËøáÊâÄÊúâ $n$ÊâáÈò≤Âæ°Èó®ÂêéËΩ¨ÂèòÂæóÂà∞ÁöÑÊîªÂáªÂäõ„ÄÇ Áî±‰∫é atm Ê∞¥Âπ≥ÊúâÈôêÔºå‰ªñÁöÑÂàùÂßãÊîªÂáªÂäõÂè™ËÉΩ‰∏∫ $0$ Âà∞ $m$ ‰πãÈó¥ÁöÑ‰∏Ä‰∏™Êï¥Êï∞ÔºàÂç≥‰ªñÁöÑÂàùÂßãÊîªÂáªÂäõÂè™ËÉΩÂú® $0,1,‚Ä¶,m$ ‰∏≠‰ªªÈÄâÔºå‰ΩÜÂú®ÈÄöËøáÈò≤Âæ°Èó®‰πãÂêéÁöÑÊîªÂáªÂäõ‰∏çÂèó $m$ ÁöÑÈôêÂà∂Ôºâ„ÄÇ‰∏∫‰∫ÜËäÇÁúÅ‰ΩìÂäõÔºå‰ªñÂ∏åÊúõÈÄöËøáÈÄâÊã©ÂêàÈÄÇÁöÑÂàùÂßãÊîªÂáªÂäõ‰ΩøÂæó‰ªñÁöÑÊîªÂáªËÉΩËÆ© drd ÂèóÂà∞ÊúÄÂ§ßÁöÑ‰º§ÂÆ≥ÔºåËØ∑‰Ω†Â∏Æ‰ªñËÆ°ÁÆó‰∏Ä‰∏ãÔºå‰ªñÁöÑ‰∏ÄÊ¨°ÊîªÂáªÊúÄÂ§öËÉΩ‰Ωø drd ÂèóÂà∞Â§öÂ∞ë‰º§ÂÆ≥„ÄÇ Ëß£ÊûêÂæàÊúâÊÑèÊÄùÁöÑÈ¢òÁõÆ,ÊÉ≥Âà∞‰∫åËøõÂà∂ÊãÜ‰ΩçÁöÑËØù,ÊÄùË∑ØÂ∞±ÂæàÊ∏ÖÊô∞‰∫Ü. ËôΩÁÑ∂ÊàëÁî±‰∫é‰∏çÁü•ÂêçÁöÑÂéüÂõ†‰∏ÄÁõ¥50ÂàÜ Êàë‰ª¨Êåâ‰ΩçËøêÁÆó,Âõ†‰∏∫ÊØè‰∏Ä‰ΩçÁöÑËøêÁÆóÊòØÁã¨Á´ãÁöÑ,ËÄåÊØè‰∏Ä‰ΩçÂè™ÂèØËÉΩÊòØ$0$Êàñ$1$. Âè™ÈúÄË¶ÅÊ≥®ÊÑèÂá†ÁÇπÂç≥ÂèØ ÂéüÊï∞Á¨¨$k$‰ΩçÂ¶ÇÊûúÊòØ$0$,Âá∫Êù•ÁöÑÁªìÊûúÊòØ$1$,Êàë‰ª¨Â∞±Â≠ò‰∏ãÊù• ÂéüÊï∞ÁöÑÁ¨¨$k$‰ΩçÂ¶ÇÊûúÊòØ$1$,Âá∫Êù•ÁöÑÁªìÊûúÊòØ$1$,‰∏îÂéüÊï∞Â∞è‰∫ém,Êàë‰ª¨Â∞±Â≠ò‰∏ãÊù•. ==97ÂàÜ‰ª£Á†Å== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; ‰∏çÁü•ÈÅìÊòØÂì™‰ΩçÂ∏¶‰Ω¨Âá∫ÁöÑhackÊï∞ÊçÆ, 123452 13983XOR 12XOR 12Á≠îÊ°àÊòØ13983 ÂêåÊ†∑ÁöÑÊÄùË∑Ø,‰∏çÂêåÁöÑÂÅöÊ≥ï,Êàë‰ª¨ÂèØ‰ª•Â∞Ü$11111‚Ä¶$Âíå$0$ÂàÜÂà´ÊâîËøõÂéª,ÈÇ£‰πàÂàÜÂà´Â∞ÜÂá∫Êù•ÁöÑÈùû$0$ÁöÑ‰ΩçÂä†Ëµ∑Êù•,Â∞±ÊòØÊàë‰ª¨ÁöÑÁ≠îÊ°à.ÂêåÊ†∑,‰ºòÂÖàÁ∫ß$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; ËøôÈáå$i$Â¶ÇÊûú‰ªé$30$ÂºÄÂßãÁÆó,È¢ùÂ§ñÊï∞ÊçÆÂ∞±ÊòØÈîôÁöÑ,$29$ÂºÄÂßãÁÆó,È¢ùÂ§ñÊï∞ÊçÆÂ∞±ËÉΩËøá. $emmmm$]]></content>
      <categories>
        <category>UOJÁªÉ‰π†ËÆ∞ÂΩï</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>‰∫åÁ∫ßÂà∂ÊãÜ‰Ωç</tag>
      </tags>
  </entry>
</search>
