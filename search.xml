<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ST表]]></title>
    <url>%2F2019%2F08%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[引例洛谷P3865$RMQ$的中文翻译为:静态区间最值查询.英文我不知道所以不写给你$n$个数,$m$次查询,查询的内容为区间$[l,r]$中的最大值.$RMQ$有解法蛮多的,$st$表,线段树,树状数组,划分树都可以做.$st$表的复杂度为预处理$O(n*{\log_2} n)$+查询$O(m)$而线段树则需要预处理$O(n*{\log_2} n)$+查询$O(m*{\log_2} n)$树状数组没学,不清楚线段树可以看我之前的博客. 定义这个算法就是基于$DP$和位运算符，我们用$dp[i][j]$表示从第 $i$ 位开始，到第 $i + 2^j -1$ 位的最大值或者最小值。 那么我求$dp[i][j]$的时候可以把它分成两部分，第一部分从 $i$ 到 $i + 2 ^{(j-1)} - 1$ ，第二部分从 $i + 2 ^{(j-1)}$ 到$i + 2^j- 1$,那么可以得到$$dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1])$$当$j=0$时,求的是长度为1的区间的最小值,$j=1$时,求的是长度为2的区间最小值$j=2$时,求的是长度为4的区间最小值以此类推,故可在$O(n\log_2 n)$的复杂度处理完.如图所示查询的话,只需要反过来就阔以了. 完整代码这里mm[i] = mm[i - 1] +((i&(i - 1)) == 0);123456789101112131415161718192021222324252627282930313233343536373839```cppconst int MAXN = 1e5 + 10;int dp[MAXN][31],a[MAXN],mm[MAXN];void initRMQ(int n)&#123; mm[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; mm[i] = mm[i - 1] +((i&amp;(i - 1)) == 0); dp[i][0] = a[i]; &#125; for (int j = 1; j &lt;= mm[n]; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int x, int y)&#123; int k = mm[y - x + 1]; return max(dp[x][k], dp[y - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m;//scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initRMQ(n); while (m--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; rmq(x, y) &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; 二维st表暂存https://blog.csdn.net/VictoryCzt/article/details/83684082 约束RMQhttps://www.cnblogs.com/ghostcai/p/9280720.htmlhttps://blog.csdn.net/VictoryCzt/article/details/83348579 练习题目洛谷P2251裸的$RMQ$问题洛谷P3865$st$表模板题目洛谷P2048$st$表+前缀和+贪心+堆优化]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2F2019%2F08%2F09%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[不得不说&emsp;&emsp;本来标题想写分治,但是想了想发现自己分治能说的不多,主要的内容就是$CDQ$分治.便取了这个标题. 预备知识 关于什么是分治&emsp;&emsp;分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。在计算机科学中，分治法就是运用分治思想的一种很重要的算法。分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。 一般步骤 划分步：把输入的问题划分为$k$个子问题，并尽量使这$k$个子问题的规模大致相同。 治理步：当问题的规模大于某个预定的阈值$n_0$时，治理步由$k$个递归调用组成。 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。 时间复杂度 直观估计 分治由以上三部分构成，整体时间复杂度则由这三部分的时间复杂度之和构成. 由于递归，最终的子问题变得极为简单，以至于其时间复杂度在整个分治策略上的比重微乎其微. 经典例题 归并排序,快排等 求逆序对等经典例题$Atcoder\ A\ -\ Colorful\ Subsequence$https://atcoder.jp/contests/agc031/tasks/agc031_a 题目简析: 问多少种子序列,子序列中的字母不同. 列如$baa$,包括:$b,a,a,$两个不同位置$a$的$ba$,总计$5$个,$baa$排除是因为$a$是重复的. 解法 先将每个字母的个数统计下来,然后分治计算,一个字母的时候,答案是该字母出现的次数. 只有两个字母的时候,如$ab$,包含的排列有$a,b,ab$,相当于’$a$的个数,$b$的个数,$a$和$b$组合个数’的加和,而$a$和$b$组合个数,则是$a$的个数$\times b$的个数 同理可得,$ans$即为$ansL+ansR+ansL\times ansR$.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e5 + 10;const int MOD = 1e9 + 7;typedef long long ll;char s[INF];int num[27];string s1="0";ll solve(int L, int R)&#123; if (L == R) return num[s1[L] - 'a']; int mid = (L + R) &gt;&gt; 1; ll nL = solve(L, mid), nR = solve(mid + 1, R); return (nL%MOD + nR%MOD + (nL%MOD * nR%MOD)%MOD)%MOD;&#125;int main()&#123; int n; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (!num[s[i] - 'a']) s1 = s1 + s[i]; num[s[i] - 'a']++; &#125; cout &lt;&lt; solve(1, s1.length() - 1)&lt;&lt;endl; return 0;&#125; CDQ分治前面絮絮叨叨的简单介绍了下分治,想必各位对分治有了一定认识.下面是重头戏:$CDQ$分治.这个算法,是由陈丹琦大牛在论文中提出的%%%.首先,我们需要知道一些事情: 优势在于可以顶替复杂的高级数据结构，而且常数比较小 缺点在于必须离线操作 用来解决什么问题呢? 首先,分治问题2333 分治后的答案,不仅单单考虑子问题${L,mid}$和子问题${mid+1,R}$. 还需要考虑子问题${L,mid}$对子问题${mid+1,R}$的影响$/$联系产生的答案. 列如: 二维偏序问题 给定一个二元组${x,y}$,要求问有多少对${x_i,y_i},{x_j,y_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$ 解法为: 先将二元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的二元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得左区间相对于右区间的点的个数. 三维偏序问题 和二维偏序问题类似,但有一定不同 给定一个三元组${x,y,z}$,要求问有多少对${x_i,y_i,z_i},{x_j,y_j,z_j}$满足$x_i&gt;x_j$&&$y_i&gt;y_j$&&$z_i&gt;z_j$ 解法为: 先将三元组按照$x$的大小排列. 分治后,我们分别知道${L,mid}$区间和${mid+1,R}$区间内的解 再计算跨过$mid$的两对点,对${L,mid}$和${mid+1,R}$中的三元组按照$y$的大小排序 由于先前分组便已经对$x$进行排序,所以,只需要二分便可以求得满足$y$条件的点. 再建立一个权值树状数组$/$线段树,再将上面符合的${x,y,z}$对应中满足不等式的$z$的点求出. 例题 BZOJ3262: 陌上花开 BZOJ4237: 稻草人或者这个LibreOJ稻草人 伪代码123456789101112void cdq(int left,int right)&#123; if(left==right) return ; int mid=(left+right)&gt;&gt;1; cdq(left,mid),cdq(mid+1,right); sort(a+l,a+mid+1,cmp); sort(a+mid+1,a+right+1,cmp); /** *处理左区间对于右区间影响的代码 */]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[我好羡慕会用java的人为什么要用到高精度呢?我们知道,$int$的范围是$\pm2^{31}-1$,$long,long$的范围是$\pm2^{63}-1$,那么当我们想要表示更往上的数字,应该怎么做?虽然,我已经学会了 我上小学很计算机的一种方式,将每一位放在一个$a[i]$中,这样,一个数字就变成一个数组,对数字的四则运算,也就变成了对数组的操作. 高精度加法问:$1234+5678$答案是多少?答:$我不知道$咳咳,按照小学的教法,我们知道,要列个竖式,对齐数位,一位一位相加,满$10$进$1$.于是:$$\quad\quad1234\\underline{,\quad+5678}\\quad\quad6912$$分析一下计算过程,我们发现,当我们用数组$a$,数组$b$,分别存下$1234$和$5678$后,从数组的最后一位开始$for$循环,用数组$S$保存和,$temp$保存进位可以得到再将这个过程转化为代码,高精度加法就写出来了 123456789101112131415BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125; 高精度减法众所周知,减法是加法的逆运算.所以,我们将加法的过程反过来就是减法. 从头往后处理 $temp$保存向后一位的借位 处理负数的偷懒方式为,将第一位前加个符号,输出的时候就加上了符号1234567891011121314151617181920212223242526272829303132333435363738BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度乘法我们现在还是小学提问:$1234\times5678$答案是多少我们来列个式杂$\quad\quad\quad1234$$;\quad\underline{\quad\times5678}$$\quad\quad\quad9872$$\quad\quad8638$$\quad;;7404$$\underline{\quad6170\quad;}$$\quad7006652$那么分析一下这个过程.设一个空的$s$数组,$b$数组的个位$\times a$从个位开始和$s$的每一位相加,$b$数组的十位$\times a$从十位开始和$s$的每一位相加,以此类推,一直到$b$的千位计算结束,得到的便是答案 1234567891011121314151617181920212223242526BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 高精度除法好的,我们现在还是小学生 高精度除低精度好的,首先,除法是乘法的逆元,所以我们~倒着做回去 从头往后处理 $down$储存余数 当余数+该位小于低精度的数时,我们向后延续一位12345678910111213BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret, len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#define MAXN 9999 //MAXN控制每个a[i]内大小#define DLEN 4 //DLEN控制a[i]中有几位#define MAXSIZE 5010 //控制数字位数class BigNum &#123;private: int a[MAXSIZE]; int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator +(const BigNum &amp;)const; BigNum operator -(const BigNum &amp;)const; BigNum operator *(const BigNum &amp;)const; BigNum operator /(const int &amp;)const; BigNum operator ^(const int &amp;)const; long long operator %(const long long &amp;)const; bool operator &gt;(const BigNum&amp;i_T)const; bool operator &gt;(const int &amp;i_T)const; void print();&#125;;//int-&gt;BigNumBigNum::BigNum(const int i_b)&#123; int c, d = i_b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1))*(MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;//char-&gt;BigNumBigNum::BigNum(const char *i_s)&#123; int t, k, index, L; memset(a, 0, sizeof(a)); L = strlen(i_s); len = L / DLEN; if (L%DLEN) len++; index = 0; for (int i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + i_s[j] - '0'; a[index++] = t; &#125;&#125;//copyBigNum::BigNum(const BigNum &amp;i_T) :len(i_T.len)&#123; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_T.a[i];&#125;//BigNum复制BigNumBigNum&amp;BigNum::operator=(const BigNum&amp;i_n)&#123; len = i_n.len; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_n.a[i]; return *this;&#125;//cin&gt;&gt; BigNumistream&amp; operator &gt;&gt;(istream &amp;in, BigNum &amp;i_b)&#123; char ch[MAXSIZE * DLEN]; in &gt;&gt; ch; int L = strlen(ch), count = 0, sum = 0; for (int i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; DLEN &amp;&amp; i &gt;= 0; j++, i--, t *= 10) sum += (ch[i] - '0')*t; i_b.a[count] = sum; count++; &#125; i_b.len = count++; return in;&#125;//cout&lt;&lt;BigNumostream&amp; operator &lt;&lt;(ostream&amp; out, BigNum&amp; i_b)&#123; cout &lt;&lt; i_b.a[i_b.len - 1]; for (int i = i_b.len - 2; i &gt;= 0; i--) printf("%04d", i_b.a[i]); return out;&#125;//高精度除低精度BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;//高精度%低精度long long BigNum::operator%(const long long &amp;i_b)const&#123; long long d = 0; for (int i = len - 1; i &gt;= 0; i--) d = ((d*MAXN + 1) % i_b + a[i] * 1LL) % i_b; return d;&#125;//高精度求幂BigNum BigNum::operator^(const int &amp;n)const&#123; int i; BigNum t, ret(1); if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;//高精与高精比较bool BigNum::operator&gt;(const BigNum &amp;i_T)const&#123; int ln; if (len &gt; i_T.len) return true; else if (len &lt; i_T.len) return false; else &#123; ln = len - 1; while (a[ln] == i_T.a[ln] &amp;&amp; ln &gt; 0) ln--; return (ln &gt;= 0 &amp;&amp; a[ln] &gt; i_T.a[ln]); &#125;&#125;//高精与低精度bool BigNum::operator&gt;(const int &amp;i_T)const&#123; BigNum b(i_T); return *this &gt; b;&#125;//打印高精度void BigNum::print()&#123; printf("%d", a[len - 1]); for (int i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;//高精度相乘BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; 高精度除高精度好的,我们现在不做小学生了考虑用除低精度的做法,太麻烦了.那么我们再回到那句话,除法是乘法的逆元.考虑:$a/b=c\ldots d$,那么也就意味着$d+c\times b=a$,那么只要找到一个数$c$,使得$c\times b+d=a$即可于是,问题变为了加法和乘法的组合.对于加法,一个个试的话,必定超时.考虑两种方式:二分法和牛顿法.高精度用不了牛顿法况且我也不会,使用二分法,复杂度为$O(logN)$.对于乘法 普通的模拟$O(N^2)$. 分治乘法：最简单的是$Karatsuba$乘法，一般化以后有$Toom-Cook$乘法； 快速傅里叶变换$FFT$：（为了避免精度问题，可以改用快速数论变换$FNTT$），时间复杂度$O(N lgN lglgN)$。参照$Schönhage–Strassen algorithm$和$Fürer’s algorithm$ 中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行 两者结合即可解决问题.$fft$的话可以看一下$hdu1402$$java$$AC$后,$c/c++$还在敲代码.]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块1-9(未完)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%88%86%E5%9D%971-9-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[序感谢@hzwer大佬出的练习题题目链接LOJ本蒟过弱,实在不知道怎么压缩代码量了-&gt;_-&gt; 数列分块入门 1给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，单点查值。 将$n$个数,按照每$\sqrt{n}$为一个块标记. 123belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; 每次对所给的$[l,r]$区间进行讨论,分为”单蹦”和”块”,对于不满块的数,直接暴力修改.对于满足块的数,直接打一个标记,当访问的时候再进行修改即可,类似于线段树$lazy$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/const int MAXN = 1e5 + 10;int belong[MAXN], tot = 1, a[MAXN], n, cnt;struct block &#123; int lazy; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // cin &gt;&gt; a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); // cin &gt;&gt; opt&gt;&gt; l &gt;&gt; r &gt;&gt; c; if (opt) cout &lt;&lt; p[belong[r]].lazy + a[r] &lt;&lt; endl; else &#123; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) a[j] += c; &#125; &#125; return 0;&#125; 数列分块入门 2给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的元素个数。 区间加法仿照$1$即可.对于每一个块内的数据,为了方便查询,我们分便对每一个块内的数据进行排序.对于不满足块的数据,我们暴力处理,再将这个块内的数据排序,满足块的区间,我们依然是打标记即可.查询的时候,二分查找即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN],b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for(int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[i]=a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = 0; c *= c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans += lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; if (p[belong[r]].end == r) ans += lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans += lowerbound(b + p[j].start, p[j].end - p[j].start + 1, c, p[j].lazy); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans += lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 3给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的前驱（比其小的最大元素）。 和$2$类似. 出题人的想法:可以在块内维护其它结构使其更具有拓展性，比如放一个 set ，这样如果还有插入、删除元素的操作，会更加的方便。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN], b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; //cin &gt;&gt; a[i];//scanf("%d", &amp;a[i]); belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = -1; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) &#123; int t = lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[p[belong[l]].start+t-1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); if (p[belong[r]].end == r) &#123; int t = lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); if (t) ans = max(ans, b[p[belong[r]].start + t - 1] + p[belong[r]].lazy); &#125; else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); for (int j = belong[l] + 1; j &lt; belong[r]; j++) &#123; int t = lowerbound(b + p[j].start, p[j].end- p[j].start + 1, c, p[j].lazy); if (t) ans = max(ans, b[p[j].start + t - 1] + p[j].lazy); &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) &#123; int t = lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[l + t - 1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; 数列分块入门 4给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，区间求和。 求和预处理一下就阔以了,打标记的时候是长度$*$加法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef long long ll;const int MAXN = 1e5 + 10;/*belong[x]:元素x所在的块的编号，样例代码中为bl[x];start[x]:编号为x的块的最左边的点，样例代码中为st[x];end[x]:编号为x的块的最右边的点，样例代码中为ed[x];*/ll cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; ll lazy; ll sum; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; //scanf("%d", &amp;a[i]); belong[i] = tot; p[tot].sum += a[i]; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; ll c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; ll ans = 0; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= p[belong[l]].end; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); if (p[belong[r]].end == r) ans = (ans + (p[belong[r]].lazy*(p[belong[r]].end - p[belong[r]].start + 1)) % (c + 1) + p[belong[r]].sum % (c + 1)) % (c + 1); else for (int j = p[belong[r]].start; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans = (ans + (p[j].lazy*(p[j].end - p[j].start + 1)) % (c + 1) + p[j].sum % (c + 1)) % (c + 1); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) &#123; p[belong[r]].sum += c; a[j] += c; &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; &#125; return 0;&#125; 数列分块入门 5给出一个长为 $n$ 的数列 ，以及 $n$ 个操作，操作涉及区间开方，区间求和。 这个题目其实比较搞人==对于一个数,其属于${-2^{31},2^{31}-1}$,最多开方不超过$4$次.还是和之前一样,单个暴力,整块标记.对于一个块,如果开方次数超过$4$次,或者整个块只有$1$或$0$,我们就可以认为不需要对其处理了,只记下和即可.自己代码实现的时候,注意细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200typedef long long ll;const int MAXN = 1e5 + 10;/* belong[x]:元素x所在的块的编号，样例代码中为bl[x]; start[x]:编号为x的块的最左边的点，样例代码中为st[x]; end[x]:编号为x的块的最右边的点，样例代码中为ed[x]; */int cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; int lazy; ll sum; int start, end; bool f; block() &#123; lazy = start = end = sum = 0; f = false;&#125;&#125; p[MAXN];void built() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; // scanf("%d", &amp;a[i]); belong[i] = tot; if (a[i] != 0) p[tot].sum++; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125;&#125;void print(int l, int r) &#123; ll ans = 0, c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; if (p[belong[r]].end == r) if (p[belong[r]].lazy &gt; 4 || p[belong[r]].f) ans += p[belong[r]].sum; else &#123; p[belong[r]].f = true; for (int i = p[belong[r]].start; i &lt;= p[belong[r]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[r]].f = false; ans += x; &#125; &#125; else for (int i = p[belong[r]].start; i &lt;= r; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; for (int i = belong[l] + 1; i &lt; belong[r]; i++) if (p[i].lazy &gt; 4 || p[i].f) ans += p[i].sum; else &#123; p[i].f = true; for (int j = p[i].start; j &lt;= p[i].end; j++) &#123; int lazy = p[i].lazy, x = a[j]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[i].f = false; ans += x; &#125; &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= r; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125;void update(int l, int r) &#123; ll c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy++; else for (int i = l; i &lt;= p[belong[l]].end; i++) a[i] = sqrt(a[i]); if (p[belong[r]].end == r) p[belong[r]].lazy++; else for (int i = p[belong[r]].start; i &lt;= r; i++) a[i] = sqrt(a[i]); for (int i = belong[l] + 1; i &lt; belong[r]; i++) p[i].lazy++; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy++; else for (int i = l; i &lt;= r; i++) a[i] = sqrt(a[i]);&#125;int main() &#123; built(); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; // scanf("%d %d %d %d", // &amp;opt, // &amp;l, &amp;r, &amp;c); if (opt) print(l, r); else update(l, r); &#125; return 0;&#125; 数列分块入门 6给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及单点插入，单点询问，数据随机生成. 到了喜闻乐见的动态分块了$23333$.$c++$的$vector$大法好,我是不会用指针写链表的,拒绝每次插入一个数,就找到对应的块,扔进去就行.将插入的次数记下来,当次数超过$\sqrt n$的时候就进行重构,也就是重新分块.然后就没有然后了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int MAXN = 1e6 + 10;const int INF = 1e8 + 10;const int MOD = 998244353;const int ans = 11;typedef long long ll;int a[MAXN];vector&lt;int&gt;p[MAXN];int n, tot = 0, m, optt;void find(int k)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; cout &lt;&lt; p[i][k] &lt;&lt; '\n'; break; &#125; &#125;&#125;void rebuild()&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; for (int j = 0; j &lt; p[i].size(); j++) a[++num] = p[i][j]; p[i].clear(); &#125; n = num, m = sqrt(n), tot = 0; for (int i = 1; i &lt;= n; i++) &#123; p[tot].push_back(a[i]); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++;&#125;void insert(int k, int x)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; p[i].insert(p[i].begin() + k, x); optt++; break; &#125; &#125; if (optt == m) &#123; rebuild(); optt = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); p[tot].push_back(x); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++; int opt, l, r, c, q = n; for (int i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d%d",&amp;opt,&amp;l,&amp;r,&amp;c); if (opt) find(r); else insert(l, r); &#125; return 0;&#125; 未完待续]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]随机数生成器]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[序这个题,难在阅读. 题目大意跳过!链接:🔗 解析 首先根据题目得到一个随机数列$\lbrace x_i=(a×x_{i−1}^2+b×x_{i−1}+c)$mod$d\rbrace$其中$i\in{1…n×m}$ 搞一个数列$T$,其中$T_i=i$,$i\in{1….n×m}$ 对每一项$T_i$,我们$swap(T_i,$$T_{x_imodi+1})$ 以上$3$步结束后,得到的就是棋盘要填的数$T_i$ 样例一数据生成的棋盘如下: 12917 51162 41038 &emsp;&emsp;路线便是$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;一个有技巧的贪心来选数.&emsp;&emsp;首先,$map[1][1]$必定选.&emsp;&emsp;如果我们不考虑棋盘顺序,若要序列最小,显然是选最小数的放进去,那么我们便从$1$这个数开始贪心.那么,这个数我们什么时候才取它呢?&emsp;&emsp;根据题目要求,我们从左上角到右下角,只能向右或者向下走,只要选过的数在要选的数左上方或右下方的时候,这个数才是可选的,或者说是可到达的.&emsp;&emsp;假设当我们要选$9$时,我们已经选了$1,2,6,8,12$,我们看$9$能否到达呢?&emsp;&emsp;显然,左侧离它最近的数要$\ge$它的行,右侧离它最近的数要$\leq$它的行.这样我们就可以选它.&emsp;&emsp;当然,选完后更新$L[],R[]$. 即代码: 123456789101112//x为行,y为列//n行,m列for (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;理解了这个贪心,题目就很水了.&emsp;&emsp;据说要注意空间,时间…..全程cin好像没啥事. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我搭博客所踩的坑]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一.博文插入图片在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image --save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 二.修改博客标题背景如果你使用的是pisces模式的话,可以参考下列教程在\blog\themes\next\source\css\_schemes\Pisces中的_brand.styl文件内.在.site-meta 下的background后面修改为url(图片链接); 三.插入音乐在网易云音乐生成外链后插入到你想放的地方即可.注意:不要打开”阻止第三方 Cookie”这个选项一旦打开,iframe就加载不出来,插入音乐那一块全白.网上也没有多少人经历过估计(逼着我学会了看F12…) 四.npm下载超慢的问题使用cnpm,这是国内的一个镜像,速度很快,但无法使用publish链接:https://npm.taobao.org/ 五.Algolia搜索搭建的问题next的使用文档已经比较全面了 这个地方要加一句 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 其次用export,最好不要用set 12export HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API Key$ hexo algolia 这些都选上 六.头像旋转以及点击头像回到主页 回到主页:在123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; 就是在代码上下分别加了href1232. 旋转~~这个我也不懂~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl 内添加: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 搭建评论区 多说 网易云跟帖 畅言 来必力（LiveRe） Disqus Hypercomments valinevaline YES!( •̀ ω •́ )y虽然国内版需要备案,但是我们可以使用国际版的🔗 注册 验证邮箱和手机号 创建一个应用，名字可以随便起 进入应用-&gt;设置-&gt;应用$key$ 复制 $appid$ 和 $appkey$ 进入主题配置文件搜索 $valine$ 12345678910valine: enable: 由false改成true app_id: 要填 app_key: 要填 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 可改 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去$d$一下完成. 先这些,持续更新]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-划分树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[引如题:POJ2014给定一$n$个元素的数组,每次查询$[l,r]$区间内从小到大第k个数.朴素解法为将数组$[l,r]$内的数排序,然后选择第$k$个即可.最坏情况$O(m*n)$.这个时候,就需要更好的数据结构,划分树/归并树. 定义原数组为${4,2,5,7,1,8,3,6}$,在每次划分左右子树时的中值,都用红色表明.小于中值的进入左子树,大于中值的进入右子树.观察我们发现,每一层都是数组$n$,只不过顺序有了变化.而对于$log2(1e9)$这个数,也不过$20$.所以我们定义一个$tree[20][n]$的数组,用来存树. 12//toleft稍后再讲int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; 建树我们定义一个数组$toleft[20][MAXN]$,其指在某数的左边所有进入左子树的数的个数.toleft数组 123456789101112第一次划分[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] 看i-th前面有多少个数进入左子树.第二次划分[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]第三次划分[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]第四次划分[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //same值指相同的中值 if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //将[l,r]内的数划分 if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //记下当前数的toleft值 &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; 查询类似于线段树的单点查询只需要考虑一个不等式$toleft[dep][r] - toleft[dep][l - 1]\leq k$如果成立,说明这个数被划进了左子树.那么大区间$[L,(L+R)&gt;&gt;1]$,小区间$[l,r]$变为$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$如果$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$那么,这个数就被划进了右子树,那么大区间变为$[(L+R)&gt;&gt;1+1,R]$,小区间变为$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.这样不断递归,当小区间$l==r$时,便确定了从小到大第$k$个数是几. 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; 完整代码当想查询从大到小第$k$个数,则将(tree[dep][i] < sorted[mid])```改为```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```改为从大到小排序即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2048]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>划分树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线段树模板]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助 本篇很多地方借鉴英雄哪里出来的博客%%% 一、基本概念 线段树是一棵二叉搜索树，它储存的是一个区间的信息。 每个节点以结构体的方式存储，结构体包含以下几个信息：每个节点以结构体的方式存储，结构体包含以下几个信息： (1). 区间左端点、右端点 (2). 区间所代表的值 (3). 该节点的子节点 线段树的基本思想：二分。 线段树一般结构如图所示：假设数据为4个数，则树应是这样 由上图可知，每个节点的 每个节点的左孩子区间范围为[left，mid]，右孩子为[mid+1,right] 二、代码实现与基本操作0.基础数据结构123456789#ifndef NULL //防报错#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.建树 built函数12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,c用法 //申请一个新内存，并令p指向该处 p-&gt;left = left; //储存区间信息 p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,皆可，及储存数据 p-&gt;lson = NULL; //令左儿子和右儿子指向NULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //二分 p-&gt;lson = built(left, mid); //左儿子 p-&gt;rson = built(mid + 1, right); //右儿子 p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //存储左儿子和右儿子的和 &#125; return p; //返回指向该处的指针&#125; &emsp;&emsp;除了建树，相应关闭树的函数为： 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; &emsp;非常需要注意的一件事，每次用指针建立树的时候，请务必写一个关闭清理申请的内存的函数 2. 单点查询&emsp;&emsp;(1).查找k位置的数据 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.单点修改&emsp;&emsp;(1).知道点所在位置，修改该点处值 123456789int update(Node p, int x,int k) //对x位置的值，进行k值的变动&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //如过找到了k位置 return p-&gt;d +=k; //对该点值进行操作，可以为+-*/等 int mid = (p-&gt;left + p-&gt;right) / 2; //判断该点在左区间还是右区间 if (x &lt;= mid) //如果是左区间，只对左区间进行递归查询 return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //查找完后对父节点存储值进行修改 return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //不是该点，也不在左区间，只能是右区间&#125; 4.区间查询&emsp;&emsp;所给区间仅可能为上图四种情况。&emsp;&emsp;通过一定操作，我们都可以将上三种，全部转换为最后一种直接输出。&emsp;&emsp;闲话少说，代码实现 12345678910111213int find(Node p, int x,int y) //注，这里假设任意x,y，都有x&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //如果是第四种情况，直接返回 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //求中间值 if (y &lt;= mid) //如果查询区间在mid左边，因为x&lt;y&lt;=mid return find(p-&gt;lson, x, y); //那么直接递归左儿子 if (x &gt; mid) //如果查询区间在mid右边，因为mid&lt;x&lt;y return find(p-&gt;rson, x, y); //那么直接递归右儿子 return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //两式都不符合，及x&lt;=mid&lt;y //则从mid为中间值分开 //左儿子查询[x,mid],右儿子查询[mid+1,y]&#125; 5.区间修改1234567891011int update(Node p, int x, int y, int k) //设区间为[x,y]，修改的值为k&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //如果是这个区间内的元素，就让它+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //二分 if (y &lt;= mid) //如果区间在中值的左侧 return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //仅需更新左儿子的值，并更新父亲的值 if (x &gt; mid) //如果区间在中值的左侧 return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //同上 return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //如果区间被中值分开&#125; 三.优化（一）. Lazy-Tag懒标记&emsp;&emsp;我们考虑一下区间改值的过程：当更改某个区间的值的时候，子区间也跟着更改。显然，在大数据下，这样操作会导致TLE。&emsp;&emsp;怎么办？&emsp;&emsp;这时我们就引入一个优化方法，叫做Lazy-Tag懒标记。&emsp;&emsp;何为懒标记呢？顾名思义，就是用来偷懒的减少修改时消耗时间的。即：&emsp;&emsp;当我想要对某一区间的所有元素都+k时，在修改该区间节点时，对其打上标记lazy，并记lazy为k，修改该节点的值为+区间长度*k，立刻return，而不将该节点下面的所有子节点一一修改。 思想实现&emsp;&emsp;如图示：1~4的值分别为1，2，3，4&emsp;&emsp;我们选择对[1,2]区间进行修改，要求改区间所有值+2，则：在区间[1,2]，打上标记lazy=2，并修改其值为3+(2-1+1)2，直接返回，并不对其子节点进行修改&emsp;&emsp;当我们再次对[1,2]区间修改时，并要求区间内所有的值+1，则：由于[1,2]有标记lazy=2，于是我们将lazy标记向其子节点传导，并修改其子节点的值。再在[1,2]区间打上lazy=1，修改值为(2-1+1)1，返回。 代码实现0.核心代码 pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //如果该节点还有后续节点 p-&gt;lson-&gt;lazy += p-&gt;lazy; //令子节点lazy继承父节点lazy，下同 p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //修改子节点的值，下同 p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //令该节点的lazy清零&#125; 1.树本体123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //仅仅多了一个lazy标记 int left, right; Node lson, rson;&#125;*root; 2.建树12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //只是对lazy标记进行初始化 if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);c用法 &#125; return;&#125; 3.单点查询和单点修改无改变4.区间查询12345678910111213long long find(Node p, int x, int y) //区间查询&#123; if (p-&gt;lazy != 0) //解决一下历史遗留问题再查询 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //其他未变 return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.区间修改123456789101112131415int update(Node p, int x, int y, int k) //区间修改&#123; if (p-&gt;lazy!=0) //如果该节点的lazy不为零，就处理一下 pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //如果是要进行修改的节点，便让该节点的lazy为k，并修改值 p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; （二）. 离散化&emsp;&emsp;离散化是一个听起来很高大上的方法.&emsp;&emsp;其实做起来很简单.当然如果想高深的话,自然也拦不住&emsp;&emsp;其实就是将一串数据储存到数组中,不将数据本身作为键值,而是选择使用数组的下标作为键值.&emsp;&emsp;形象的,$1,2,3,10000000$这四个数,保存在数组$a[]$中,相对应的下标为$1,2,3,4$就可以减少空间的开支. 数组实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 1e5 + 10;typedef long long ll;struct Segment_Tree &#123; ll d, lazy; int left, right; int lson, rson;&#125;root[4 * MAXN];int n;void built(int p, int left, int right)&#123; root[p].left = left; root[p].right = right; root[p].lazy = 0; if (left == right) &#123; cin &gt;&gt; root[p].d; root[p].lson = root[p].rson = null; &#125; else &#123; int mid = (left + right) &gt;&gt; 1; built(root[p].lson = (p &lt;&lt; 1), left, mid); built(root[p].rson = (p &lt;&lt; 1 | 1), mid + 1, right); root[p].d = root[root[p].lson].d + root[root[p].rson].d; &#125;&#125;void pushdown(int p)&#123; if (root[p].lson != null) &#123; root[root[p].lson].lazy += root[p].lazy; root[root[p].lson].d += (root[root[p].lson].right - root[root[p].lson].left + 1)*root[p].lazy; root[root[p].rson].lazy += root[p].lazy; root[root[p].rson].d += (root[root[p].rson].right - root[root[p].rson].left + 1)*root[p].lazy; &#125; root[p].lazy = 0;&#125;ll find(int p, int x, int y)&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) return root[p].d; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return find(root[p].lson, x, y); if (x &gt; mid) return find(root[p].rson, x, y); return find(root[p].lson, x, mid) + find(root[p].rson, mid + 1, y);&#125;long long update(int p, int x, int y, int k) //区间&#123; if (root[p].lazy != 0) pushdown(p); if (root[p].left == x &amp;&amp; root[p].right == y) &#123; root[p].lazy = k; return root[p].d += k * (y - x + 1); &#125; int mid = (root[p].left + root[p].right) &gt;&gt; 1; if (y &lt;= mid) return root[p].d = root[root[p].rson].d + update(root[p].lson, x, y, k); if (x &gt; mid) return root[p].d = root[root[p].lson].d + update(root[p].rson, x, y, k); return root[p].d = update(root[p].lson, x, mid, k) +update(root[p].rson, mid+1, y, k);&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; built(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int t, x, y, k; cin &gt;&gt; t; if (t == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; update(1, x, y, k); &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; find(1, x, y) &lt;&lt; endl; &#125; &#125; return 0;&#125; 练习题目洛谷P2251裸的RMQ问题,数据量小.洛谷P3372洛谷P3373洛谷线段树模板题]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法模板]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蒟蒻学识浅陋,欢迎各位大牛指正 KMP从入门到放弃请观左神为什么想要杀人%%%%njb7着重听1h12m20s$KMP$分为两个部分,一部分为两个字符串间的比较,另一部分为自己与自己的比较.简单的划分为下面两个图,详细理解请见左神不稳定情绪讲解.不过我$jiao$的在$1:21:04$时,将例子换为$”ababcababak”$更好理解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; 例题G.OulipoHDU 1686The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $’T’$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${‘A’, ‘B’, ‘C’, …, ‘Z’}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $1 ≤ |W| ≤ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${‘A’, ‘B’, ‘C’, …, ‘Z’}$, with $|W| ≤ |T| ≤ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 解析$kmp$模板,读入不能用$cin$,否则超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]动物园]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[序言&emsp;&emsp;这个题写的我好迷啊== 题目简述&emsp;&emsp;园长想让你求一个字符串的”不互相重叠的公共前后缀个数”然后再乘起来.一大骡子的字,总结一下就是这个意思. 解析&emsp;&emsp;如果你不会$KMP$….那我也没办法(笑)&emsp;&emsp;我们知道,$next$保存的是有重叠部分的最大长度.那么我们在它计算的过程中,把当前$next[i]$的位置,存一个长度$cnt[i]$,啥意思?&emsp;&emsp;我$next[i]$从头扫到尾,相当于一个递推得到最大长度.同时进行$cnt[i]$从头扫到尾,相当于递推得到最大个数.&emsp;&emsp;然后再用$next[]$数组,找到不重复的位置,也就是$j\leq{i/2}$这样的位置,计算$cnt$,完成. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]魔法森林]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[序言$UOJ$果然是神仙$OJ$啊里面个个都是人才,说话还好听题目的$hack$数据还可以$hack$掉网上一大片的题解….. 题目描述为了得到书法大家的真传，小$E$同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个$N$节点$M$条边的无向图，节点标号为$1…n$，边标号为$1…m$。初始时小$E$同学在$1$ 号节点，隐士则住在 $n$ 号节点。小$E$需要通过这一片魔法森林，才能够拜访到隐士。魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：$A$型守护精灵与$B$型守护精灵。小$E$可以借助它们的力量，达到自己的目的。只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$。若身上携带的$A$型守护精灵个数不少于 $a_i$，且$B$型守护精灵个数不少于 $b_i$，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小$E$发起攻击，他才能成功找到隐士。由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为$A$型守护精灵的个数与$B$型守护精灵的个数之和。 题目大意:从$1$走到$n$,$m$条边,如何走能使$a$和$b$的和最大值最小. 解析首先,这是一个最小生成树的题目.其次,这应该是一个动态最小生成树的题目.(如果你学过用LCT做最小生成树,这个题就非常的水)我们将$a_i$排序后,按边取,可以保证$a_i$是最小的.在按$a_i$大小取边的时候,同时更新路上$b_i$的最大值.当我们取到一个环的时候怎么办?列如这样:我们就要对新加入的边上$b_i$的值,和维护的链上$b_i$的最大值进行比较. 如果链上的值大,那么我们把链上最大的那条边$cut$,如何把新边连上. 如果新边大,我们便直接跳过. 如此往复,直到$1$$n$这条路连通.连通后,我们加入另一个操作:判断,加入的这条边对于答案的影响.$a$大并不代表$b$也大,因为问的是$a+b$的和.直到遍历完所有边.~过了最小生成树的代码居然只有97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]起床困难综合症]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[描述 链接:http://uoj.ac/problem/2 21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙. 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算$op$ 和一个参数$t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x$ $op$ $t$。最终drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$扇防御门后转变得到的攻击力。 由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 解析很有意思的题目,想到二进制拆位的话,思路就很清晰了. 虽然我由于不知名的原因一直50分 我们按位运算,因为每一位的运算是独立的,而每一位只可能是$0$或$1$. 只需要注意几点即可 原数第$k$位如果是$0$,出来的结果是$1$,我们就存下来 原数的第$k$位如果是$1$,出来的结果是$1$,且原数小于m,我们就存下来. ==97分代码== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; 不知道是哪位带佬出的hack数据, 123452 13983XOR 12XOR 12答案是13983 同样的思路,不同的做法,我们可以将$11111…$和$0$分别扔进去,那么分别将出来的非$0$的位加起来,就是我们的答案.同样,优先级$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; 这里$i$如果从$30$开始算,额外数据就是错的,$29$开始算,额外数据就能过. $emmmm$]]></content>
      <categories>
        <category>UOJ练习记录</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>二级制拆位</tag>
      </tags>
  </entry>
</search>
