<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ICPC Central Europe Regional Contest 2019 D.Deep800080]]></title>
    <url>%2F2020%2F05%2F21%2FICPC-Central-Europe-Regional-Contest-2019-D-Deep800080%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥æˆ³æ­¤å¤„ğŸ—¡æ•°æ®ä¸‹è½½â”â”›å¢“â”—â”“â€¦(((m -__-)m)) è§£ææ³¨æ„ï¼Œæ­¤å¤„ç å¤´æŒ‡çš„æ˜¯ä¸€æ¡ç›´çº¿ã€‚ã€‚ a straight line passing throughtwo distinct points with coordinates (0, 0)(0,0) and (A, B)(A,B). æˆ‘ä»¬è€ƒè™‘ï¼Œåœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œä»¥ç‚¹$o$ä¸ºåœ†å¿ƒï¼Œ$r$ä¸ºåŠå¾„çš„ä¸€ä¸ªåœ†ï¼Œå¦‚ä½•æ‰èƒ½å°†ä¸€ä¸ªç‚¹$p$åŒ…å«?æ˜¾ç„¶ï¼Œä»¥$p$ä¸ºåœ†å¿ƒ,åŒæ ·çš„åšä¸€ä¸ªåŠå¾„$r$çš„åœ†ï¼Œå…¶ä¸ç›´çº¿çš„ä¸¤ä¸ªäº¤ç‚¹å½¢æˆçš„çº¿æ®µï¼Œä¾¿æ˜¯$o$çš„å–å€¼èŒƒå›´ã€‚å¦‚å›¾1ï¼šäºæ˜¯ä¹ï¼Œé¢˜ç›®å°±ä»ï¼Œå¦‚ä½•åœ¨çº¿ä¸Šæ‰¾ä¸€ç‚¹ï¼Œä½¿å¾—å…¶åšçš„åœ†åŒ…å«ç‚¹æœ€å¤šï¼Œå˜æˆäº†çº¿æ®µé‡å é—®é¢˜ã€‚é—®å“ªä¸ªåœ°æ–¹çº¿æ®µé‡å æœ€å¤šï¼Œæ˜¾ç„¶æ˜¯æ‰«æçº¿ç±»å‹çš„é¢˜ç›®ã€‚æŒ‰ç…§ä¸€ä¸ªæ–¹å‘æ‰«è¿‡å»ï¼Œç¢°åˆ°ä¸€ä¸ªçº¿æ®µçš„èµ·ç‚¹ä¾¿$ans+=1$ï¼Œç¢°åˆ°çº¿æ®µçš„æœ«å°¾$ans-=1$å¦‚æ­¤æ‰«ä¸€éï¼Œæ¯æ¬¡$ans$æ›´æ”¹æ—¶å–ä¸€æ¬¡$maxx$ï¼Œæ‰«å®Œåçš„$maxx$ä¾¿æ˜¯ç­”æ¡ˆã€‚ ä»£ç ä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/*#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;*/#pragma comment(linker, "/STACK:102400000,102400000")#pragma GCC optimize(3, "Ofast", "inline")#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace __gnu_pbds;using namespace std;#define inf __INT_MAX__#define enf INT_MIN#define INF LLONG_MAX#define ENF LLONG_MINconst int MAXN = 1e6 + 10;const double pi = acos(-1.0);const double eps = 1e-6;typedef long long ll;#define zhengfu(x) ((x &gt; eps) - (x &lt; -eps))typedef struct point vec;struct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; int poe; point(double _x = 0, double _y = 0) : x(_x), y(_y) &#123; &#125; double len() //æ¨¡é•¿ &#123; return sqrt(x * x + y * y); &#125; vec chuizhi() &#123; return vec(-y, x); &#125; double operator*(const point &amp;i_T) const //ç‚¹ç§¯ &#123; return x * i_T.x + y * i_T.y; &#125; double operator^(const point &amp;i_T) const //å‰ç§¯ &#123; return x * i_T.y - y * i_T.x; &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point &amp;i_T) const &#123; return fabs(x - i_T.x) &lt; eps &amp;&amp; fabs(y - i_T.y) &lt; eps; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point &amp;i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point &amp;i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return fabs(a.y - b.y) &lt; eps ? a.x &lt; b.x : a.y &lt; b.y; &#125; void atn2() &#123; poe = atan2(y, x); &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, point &amp;a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.8f %.8f", a.x, a.y); return out; &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, point &amp;a) &#123; scanf("%lf%lf", &amp;a.x, &amp;a.y); return in; &#125;&#125;;struct cirles &#123; point o; double r; cirles(point _o = point(), double _r = 0.0) : r(_r), o(_o) &#123; &#125; point Point(double t) //åœ†ä¸Šä»»æ„ä¸€ç‚¹ &#123; return point(o.x + r * cos(t), o.y + r * sin(t)); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, cirles &amp;a) &#123; in &gt;&gt; a.o &gt;&gt; a.r; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, cirles &amp;a) &#123; out &lt;&lt; a.o &lt;&lt; ' '; printf("%.8f", a.r); return out; &#125;&#125;;typedef struct Line Segment; //çº¿æ®µSegmentstruct Line &#123; //ç›´çº¿ point a, b; double poe; Line(point _a = point(), point _b = point()) : a(_a), b(_b) &#123; &#125; double len() &#123; return (a - b).len(); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, Line &amp;a) &#123; cin &gt;&gt; a.a &gt;&gt; a.b; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Line &amp;a) &#123; out &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b; return out; &#125; bool in(point pi) &#123; if (b &lt; a) return ((b == pi || b &lt; pi) &amp;&amp; (a == pi || pi &lt; a)); return ((a == pi || a &lt; pi) &amp;&amp; (b == pi || pi &lt; b)); &#125; void atn2() &#123; poe = atan2(b.y - a.y, b.x - a.x); &#125;&#125;;point zhixian_zhixian_jiaodian(Line l1, Line l2) //ä¸¤ç›´çº¿äº¤ç‚¹&#123; double t = ((l1.a.x - l2.a.x) * (l2.a.y - l2.b.y) - (l1.a.y - l2.a.y) * (l2.a.x - l2.b.x)) / ((l1.a.x - l1.b.x) * (l2.a.y - l2.b.y) - (l1.a.y - l1.b.y) * (l2.a.x - l2.b.x)); return l1.a + (l1.b - l1.a) * t;&#125;double zhixian_yuanxin_juli(Line l, cirles a) //ç›´çº¿åˆ°åœ†å¿ƒçš„è·ç¦»&#123; return fabs((a.o - l.a) ^ (l.b - l.a)) / (l.b - l.a).len();&#125;int bijiao(double x, double y) &#123; if (fabs(x - y) &lt; eps) return 0; if (x &gt; y) return 1; return -1;&#125;int zhixian_yuan_jiaodian(cirles c, Line l, point &amp;p1, point &amp;p2) &#123; //ç›´çº¿ä¸åœ†äº¤ç‚¹ä»¥åŠä¸ªæ•° if (zhixian_yuanxin_juli(l, c) &gt; c.r) return 0; point pi = c.o; pi.x += l.a.y - l.b.y; pi.y += l.b.x - l.a.x; pi = zhixian_zhixian_jiaodian(Line(pi, c.o), l); double t = sqrt(c.r * c.r - (pi - c.o).len() * (pi - c.o).len()) / (l.a - l.b).len(); p1 = pi - (l.b - l.a) * t; p2 = pi + (l.b - l.a) * t; return 1 + !(bijiao(p1.x, p2.x) == 0 &amp;&amp; bijiao(p1.y, p2.y) == 0);&#125;bool cmp(point a, point b) &#123; return (bijiao(a.x, b.x) == 0 ? (bijiao(a.y, b.y) == 0 ? a.poe &gt; b.poe : a.y &lt; b.y) : a.x &lt; b.x);&#125;int main() &#123; Line l; int n, r; cin &gt;&gt; n &gt;&gt; r &gt;&gt; l.b; vector&lt;cirles&gt; c(n); for (auto &amp;p : c) &#123; cin &gt;&gt; p.o; p.r = r + eps; &#125; vector&lt;point&gt; p; for (auto it : c) &#123; point p1, p2; if (zhixian_yuan_jiaodian(it, l, p1, p2)) &#123; p1.poe = 1; p2.poe = -1; p.push_back(p1), p.push_back(p2); &#125; &#125; sort(p.begin(), p.end(), cmp); ll maxx = 0, sum = 0; for (auto it : p) &#123; sum += it.poe; maxx = max(maxx, abs(sum)); &#125; cout &lt;&lt; maxx &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6603 Azshara's deep sea]]></title>
    <url>%2F2020%2F05%2F20%2FHDU6603-Azshara-s-deep-sea%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®å¤§æ„é¢˜ç›®å¾ˆé•¿ï¼Œæ˜¯æœ‰å…³äºWOWçš„ä¸€ä¸ªæ”»ç•¥å‡ºçš„æ¨¡æ‹Ÿé¢˜ã€‚å¤§è‡´æ„æ€å°±æ˜¯ç»™ä½ ä¸€å †ç‚¹å’Œä¸€å †åœ†ï¼Œé—®ä½ åœ¨ç¬¦åˆé¢˜æ„ä¸‹ï¼Œæœ€å¤šèƒ½è¿å‡ æ¡çº¿æ®µã€‚è¦æ±‚å¦‚ä¸‹ï¼š çº¿æ®µä¸èƒ½ç›¸äº¤ï¼Œç«¯ç‚¹é‡åˆé™¤å¤– çº¿æ®µä¸èƒ½ä¸åœ†ç›¸äº¤æˆ–ç›¸åˆ‡ çº¿æ®µä¸¤ä¸ªç«¯ç‚¹ä¸èƒ½ç›¸é‚»ï¼Œå¦‚$(i,i+1)$ æˆ–$(i-1,i)$ ç«¯ç‚¹å¿…é¡»æœ€é å¤– æ ¹æ®è¿™å››æ¡è¦æ±‚,å°±å¯ä»¥åšäº†â€¦ æ€è·¯é¦–å…ˆï¼Œç«¯ç‚¹å¿…é¡»æœ€é å¤–ï¼Œå°±æ˜¯è¯´ç«¯ç‚¹æ˜¯å‡¸åŒ…ä¸Šçš„ç‚¹ã€‚å°±æ˜¯è¯´ ï¼Œå…ˆè·‘ä¸ªå‡¸åŒ…ã€‚å…¶æ¬¡ï¼Œçº¿æ®µä¸¤ä¸ªç«¯ç‚¹ä¸ç›¸é‚»ï¼Œä¸”ä¸ä¸åœ†ç›¸äº¤æˆ–ç›¸åˆ‡ï¼Œæšä¸¾ä¸€éå°±å¥½äº†ã€‚æœ€åï¼Œè€ƒè™‘çº¿æ®µä¸ç›¸äº¤ã€‚çº¿æ®µç«¯ç‚¹éƒ½æ˜¯å‡¸åŒ…ä¸Šçš„ç‚¹ï¼Œé‚£ä¹ˆåªè¦æ»¡è¶³ï¼Œçº¿æ®µ$ab$å’Œçº¿æ®µ$cd$ï¼Œ$c&lt;a\&amp;\&amp;b&lt;d$å³å¯ã€‚å¦‚å›¾1ï¼šå› æ­¤é¢˜ç›®å˜æˆäº†ï¼Œæ±‚æœ€å¤§çº¿æ®µä¸ç›¸äº¤æ•°é‡ã€‚å—¯ï¼Œæ˜¾ç„¶dpã€‚ç„¶åè€ƒè™‘ä¸Šé¢å‡¸åŒ…çº¿æ®µä¸ç›¸äº¤çš„æ€§è´¨ï¼Œæ˜¯ä¸€ç§åŒ…å«å…³ç³»ã€‚å¯ä»¥å¾—å‡ºï¼Œè¿™æ˜¯ä¸€ä¸ªåŒºé—´dpã€‚ç„¶åå°±æ˜¯ï¼Œæšä¸¾å°åŒºé—´ï¼Œå†æ±‚å¤§åŒºé—´äº†ã€‚$dp[i][j]=max(dp[i][j],dp[i][t]+dp[t][j]+dk[i][j]);$å…¶ä¸­ï¼Œ$dk$æŒ‡çš„æ˜¯è¯¥çº¿æ®µæ˜¯å¦æ˜¯ç¬¦åˆ$2$ï¼Œ$3$ï¼Œ$4$çš„ï¼Œç¬¦åˆä¸º$1$ï¼Œä¸ç¬¦åˆä¸º$0$ ä»£ç ä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/*#pragma comment(linker, "/STACK:102400000,102400000")#pragma GCC optimize(3, "Ofast", "inline")#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace __gnu_pbds;*/#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;#define inf __INT_MAX__#define enf INT_MIN#define INF LLONG_MAX#define ENF LLONG_MINconst int MAXN = 1e3 + 10;const double pi = acos(-1.0);const double eps = 1e-6;typedef long long ll;#define zhengfu(x) ((x &gt; eps) - (x &lt; -eps))typedef struct point vec;struct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; double poe; point(double _x = 0, double _y = 0) : x(_x), y(_y) &#123; &#125; double len() //æ¨¡é•¿ &#123; return sqrt(x * x + y * y); &#125; vec chuizhi() &#123; return vec(-y, x); &#125; double operator*(const point &amp;i_T) const //ç‚¹ç§¯ &#123; return x * i_T.x + y * i_T.y; &#125; double operator^(const point &amp;i_T) const //å‰ç§¯ &#123; return x * i_T.y - y * i_T.x; &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point &amp;i_T) const &#123; return fabs(x - i_T.x) &lt; eps &amp;&amp; fabs(y - i_T.y) &lt; eps; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point &amp;i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point &amp;i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return fabs(a.y - b.y) &lt; eps ? a.x &lt; b.x : a.y &lt; b.y; &#125; void atn2() &#123; poe = atan2(y, x); &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, point &amp;a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.8f %.8f", a.x, a.y); return out; &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, point &amp;a) &#123; scanf("%lf%lf", &amp;a.x, &amp;a.y); return in; &#125;&#125;;struct cirles &#123; point o; double r; cirles(point _o = point(), double _r = 0.0) : r(_r), o(_o) &#123; &#125; point Point(double t) //åœ†ä¸Šä»»æ„ä¸€ç‚¹ &#123; return point(o.x + r * cos(t), o.y + r * sin(t)); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, cirles &amp;a) &#123; in &gt;&gt; a.o &gt;&gt; a.r; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, cirles &amp;a) &#123; out &lt;&lt; a.o &lt;&lt; ' '; printf("%.8f", a.r); return out; &#125;&#125;;typedef struct Line Segment; //çº¿æ®µSegmentstruct Line &#123; //ç›´çº¿ point a, b; double poe; Line(point _a = point(), point _b = point()) : a(_a), b(_b) &#123; &#125; double len() &#123; return (a - b).len(); &#125; bool in(point pi) &#123; if (b &lt; a) return ((b == pi || b &lt; pi) &amp;&amp; (a == pi || pi &lt; a)); return ((a == pi || a &lt; pi) &amp;&amp; (b == pi || pi &lt; b)); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, Line &amp;a) &#123; cin &gt;&gt; a.a &gt;&gt; a.b; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Line &amp;a) &#123; out &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b; return out; &#125; void atn2() &#123; poe = atan2(b.y - a.y, b.x - a.x); &#125;&#125;;double xuanzhuan(vec a, vec b, vec c) //æ±‚ä¸‰ç‚¹å‰ç§¯ï¼Œæ­£ä¸º(b-a)-&gt;(c-a)å·¦æ—‹&#123; return (b - a) ^ (c - a);&#125;void Andrew(point po[], int n, point qo[], int &amp;tail) //æ±‚å‡¸åŒ…,&lt;0åˆ™åŒ…å«å‡¸åŒ…è¾¹ä¸Šçš„ç‚¹,&lt;=0åˆ™åªè¾“å‡ºæ‹ç‚¹&#123; sort(po + 1, po + 1 + n); tail = 1; qo[1] = po[1]; for (int i = 2; i &lt;= n; i++) &#123; while (tail &gt; 1 &amp;&amp; xuanzhuan(qo[tail - 1], qo[tail], po[i]) &lt;= 0) tail--; qo[++tail] = po[i]; &#125; int basic = tail; for (int i = n - 1; i &gt;= 1; i--) &#123; while (tail &gt; basic &amp;&amp; xuanzhuan(qo[tail - 1], qo[tail], po[i]) &lt;= 0) tail--; qo[++tail] = po[i]; &#125;&#125;double zhixian_yuanxin_juli(Line l, cirles a) //ç›´çº¿åˆ°åœ†å¿ƒçš„è·ç¦»&#123; return fabs((a.o - l.a) ^ (l.b - l.a)) / (l.b - l.a).len();&#125;bool check(Segment si, cirles ci[], int g) &#123; for (int i = 1; i &lt;= g; i++) if (zhixian_yuanxin_juli(si, ci[i]) &lt;= ci[i].r) return false; return true;&#125;point p[MAXN], q[MAXN];cirles c[MAXN];int dk[MAXN][MAXN], dp[MAXN][MAXN];int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, g, r; cin &gt;&gt; n &gt;&gt; g &gt;&gt; r; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dp[i][j] = dk[i][j] = 0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= g; i++) &#123; cin &gt;&gt; c[i].o; c[i].r = r; &#125; int tail; Andrew(p, n, q, tail); for (int i = 1; i &lt; tail; i++) for (int j = i + 2; j &lt; tail - (i == 1); j++) if (check(Segment(q[i], q[j]), c, g)) dk[i][j] = 1; for (int k = 2; k &lt;= n; k++) for (int i = 1; i &lt;= n - k; i++) &#123; int j = i + k; for (int t = i + 1; t &lt; j; t++) dp[i][j] = max(dp[i][j], dp[i][t] + dp[t][j] + dk[i][j]); &#125; int ans = enf; for (int i = 1; i &lt; tail; i++) for (int j = i + 2; j &lt; tail - (i == 1); j++) ans = max(ans, dp[i][j]); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;/*15 3 16 1010 79 12 00 32 25 68 3*/]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI2018 æˆ˜äº‰]]></title>
    <url>%2F2019%2F09%2F16%2FJSOI2018-%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[å¤§æ„ä¸ºäº†é˜»æ­¢æˆ˜äº‰,ä½ å°±æ˜¯,å¤©é€‰ä¹‹äºº~~ è§£æå‡è®¾$a\in A,b\in B$,å­˜åœ¨å‘é‡$w$,ä½¿å¾—$b+w=a$,é‚£ä¹ˆæ ¹æ®é—µå¯å¤«æ–¯åŸºå·®,å¯ä»¥å¾—åˆ°$A-B=\{w\rvert w+B\subseteq A\}$å½“ç„¶,è§£é¢˜éƒ½æ˜¯æ€ä¹ˆæ–¹ä¾¿æ€ä¹ˆæ¥,æˆ‘ä»¬ç›´æ¥å°†$B$å–å,ç„¶åå’Œ$A$æ±‚ä¸ªé—µå¯å¤«æ–¯åŸºå’Œå°±å®Œäº‹äº†.æœ€åå†åˆ¤æ–­æ‰€ç»™ç‚¹åœ¨ä¸åœ¨Cé‡Œ,å°±å®Œäº‹äº†å“¦,è¦å¯¹$A,B$è¿›è¡Œä¸€æ¬¡æ±‚å‡¸åŒ…,å»æ‰è¾¹ä¸Šçš„ç‚¹ç„¶åå†å¯¹$C$æ±‚ä¸€æ¬¡. ä»£ç ä»£ç æˆ³æˆ‘æˆ³æˆ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 10;const double pi = acos(-1.0);const double inf = 1e100;const double eps = 1e-12;typedef struct point vec; //å‘é‡vecstruct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; double poe; point(double _x = 0, double _y = 0) : x(_x) , y(_y) &#123; &#125; double len() //å‘é‡æ¨¡é•¿çš„å¹³æ–¹ &#123; return x * x + y * y; &#125; double operator*(const point&amp; i_T) const //ç‚¹ç§¯ &#123; return x * i_T.x + y * i_T.y; &#125; double operator^(const point&amp; i_T) const //å‰ç§¯ &#123; return x * i_T.y - y * i_T.x; &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point&amp; i_T) const &#123; return x == i_T.x &amp;&amp; y == i_T.y; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point&amp; i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point&amp; i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return fabs(a.y - b.y) &lt; eps ? a.x &lt; b.x : a.y &lt; b.y; &#125; void atn2() &#123; poe = atan2(y, x); &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.0f %.0f", a.x, a.y); return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; scanf("%lf%lf", &amp;a.x, &amp;a.y); return in; &#125;&#125;;int bijiao(double x, double y)&#123; if (fabs(x - y) &lt; eps) return 0; if (x &gt; y) return 1; return -1;&#125;bool cmp(vec a, vec b)&#123; return bijiao(a.poe, b.poe) == 0 ? (a ^ b) &gt;= 0 : a.poe &lt; b.poe;&#125;double xuanzhuan(vec a, vec b, vec c) //æ±‚ä¸‰ç‚¹å‰ç§¯&#123; return (b - a) ^ (c - a);&#125;void Andrew(int&amp; tail, point cl[], int n, point ql[]) //æ±‚å‡¸åŒ…&#123; sort(cl + 1, cl + 1 + n); tail = 1; ql[1] = cl[1]; for (int i = 2; i &lt;= n; i++) &#123; while (tail &gt; 1 &amp;&amp; xuanzhuan(ql[tail - 1], ql[tail], cl[i]) &lt;= 0) tail--; ql[++tail] = cl[i]; &#125; int basic = tail; for (int i = n - 1; i &gt;= 1; i--) &#123; while (tail &gt; basic &amp;&amp; xuanzhuan(ql[tail - 1], ql[tail], cl[i]) &lt;= 0) tail--; ql[++tail] = cl[i]; &#125;&#125;void Minkefusiji(point s[], int&amp; cnt, point pl1[], int tail1, point pl2[], int tail2)&#123; s[cnt = 1] = pl1[1] + pl2[1]; for (int i = 1; i &lt;= tail1; i++) pl1[i] = pl1[i + 1] - pl1[i]; for (int i = 1; i &lt;= tail2; i++) pl2[i] = pl2[i + 1] - pl2[i]; int a1 = 1, a2 = 1; while (a1 &lt;= tail1 &amp;&amp; a2 &lt;= tail2) &#123; ++cnt; if ((pl1[a1] ^ pl2[a2]) &gt;= 0) s[cnt] = s[cnt - 1] + pl1[a1++]; else s[cnt] = s[cnt - 1] + pl2[a2++]; &#125; while (a1 &lt;= tail1) ++cnt, s[cnt] = s[cnt - 1] + pl1[a1++]; while (a2 &lt;= tail2) ++cnt, s[cnt] = s[cnt - 1] + pl2[a2++];&#125;bool cmp2(point A, point B)&#123; return (A ^ B) &gt; 0 || ((A ^ B) == 0 &amp;&amp; A.len() &lt; B.len());&#125;bool dian_in_tubao(point a, point p[], int tail) //åŒ…å«è¾¹ç•Œ&#123; if ((a ^ p[1]) &gt; 0 || (p[tail] ^ a) &gt; 0) return false; int ps = lower_bound(p + 1, p + tail + 1, a, cmp2) - p - 1; return ((a - p[ps]) ^ (p[ps % tail + 1] - p[ps])) &lt;= 0;&#125;point p[MAXN], q2[MAXN], q1[MAXN];int main()&#123; int m, n, q; cin &gt;&gt; m &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; p[i]; int tail1; Andrew(tail1, p, m, q1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i]; p[i].x = -p[i].x, p[i].y = -p[i].y; &#125; int tail2; Andrew(tail2, p, n, q2); tail1--, tail2--; int cnt, tail; Minkefusiji(p, cnt, q1, tail1, q2, tail2); Andrew(tail, p, cnt, q1); tail--; point bs = q1[1]; for (int i = 1; i &lt;= tail; i++) q1[i] = q1[i] - bs; while (q--) &#123; point pi; cin &gt;&gt; pi; if (dian_in_tubao(pi - bs, q1, tail)) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é—µå¯å¤«æ–¯åŸºå’Œ]]></title>
    <url>%2F2019%2F09%2F16%2F%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C%2F</url>
    <content type="text"><![CDATA[å®šä¹‰ä»€ä¹ˆæ˜¯é—µå¯å¤«æ–¯åŸºå’Œ?ä¸¤ä¸ªå‡¸åŒ…$A$,$B$,é‚£ä¹ˆä»–ä»¬çš„å’Œ$A+B=C$,å…¶ä¸­,å¯¹äº$C$ä¸­çš„æ¯ä¸ªåæ ‡,éƒ½æœ‰$(x_C,y_C)=(x_A+x_B,y_A+y_B)$.å®šä¹‰ä¸º:$A+B=\{a+b\rvert a\in A,b\in B\}$æœ€æš´åŠ›çš„è§£æ³•,ä¾¿æ˜¯å¯¹$A$ä¸­æ¯ä¸€ä¸ªç‚¹,éƒ½åŠ ä¸€é$B$ä¸­çš„ç‚¹,å¤æ‚åº¦ä¸º$O(n*m)$å›¾å‘¢,é•¿è¿™æ ·: æµç¨‹å’‹å‡ºæ¥çš„å•Š?å°†$B$æŒ‰ç…§,ä»åŸç‚¹åˆ°å‡¸åŒ…$A$ä¸­æ¯ä¸ªç‚¹çš„å‘é‡ä¸ºæ–¹å‘,ç§»åŠ¨å‡ºæ¥çš„.å•¥??å…¶å®é•¿è¿™æ ·:æ˜¾ç„¶,ä¸€ä¸ªå‡¸åŒ…å†…çš„å‘é‡åº”è¯¥æ˜¯æ— ç©·çš„.æˆ‘æ‡’å¾—ç”»äº†å°†$B$æŒ‰ç…§å¦‚å›¾çš„å‘é‡è¿›è¡Œç§»åŠ¨,å°±å¾—åˆ°äº†æˆ‘ä»¬è¦çš„$C$ä½†æ˜¯è¿™æ˜¾ç„¶æ˜¯ä¸å¯è¡Œçš„.æˆ‘ä»¬ç”¨è‚‰çœ¼è§‚å¯Ÿæ³•,å¯ä»¥çŸ¥é“,è¿™ä¸ª$C$æ˜¯ç”±$A$å’Œ$B$çš„è¾¹é€†æ—¶é’ˆé¦–å°¾ç›¸æ¥è€Œæˆçš„.è¿™æ ·çš„è¯,åªéœ€è¦å…¨é¢†å‡ºæ¥,ç„¶åæ¥èµ·æ¥å°±å®Œäº‹äº†.å°±æ˜¯è¿™æ ·: 1234567891011121314151617181920void Minkefusiji(point s[], int&amp; cnt, point pl1[], int tail1, point pl2[], int tail2)&#123; s[cnt = 1] = pl1[1] + pl2[1]; for (int i = 1; i &lt;= tail1; i++) pl1[i] = pl1[i + 1] - pl1[i]; for (int i = 1; i &lt;= tail2; i++) pl2[i] = pl2[i + 1] - pl2[i]; int a1 = 1, a2 = 1; while (a1 &lt;= tail1 &amp;&amp; a2 &lt;= tail2) &#123; ++cnt; if ((pl1[a1] ^ pl2[a2]) &gt;= 0) //å‰ç§¯ s[cnt] = s[cnt - 1] + pl1[a1++]; else s[cnt] = s[cnt - 1] + pl2[a2++]; &#125; while (a1 &lt;= tail1) ++cnt, s[cnt] = s[cnt - 1] + pl1[a1++]; while (a2 &lt;= tail2) ++cnt, s[cnt] = s[cnt - 1] + pl2[a2++];&#125; æ€ä¹ˆåšçš„? é¦–å…ˆ,èµ·ç‚¹åº”æ˜¯ä¸¤ä¸ªå‡¸åŒ…æœ€å·¦ä¸‹è§’çš„ç‚¹çš„å’Œ. å…¶æ¬¡,æˆ‘ä»¬å°†æ¯ä¸ªå‡¸åŒ…çš„è¾¹æ”¹ä¸ºå‘é‡ æ¯æ¬¡å’Œ$S[cnt-1]$ç›¸åŠ ,åŠåœ¨æ±‚å¾—çš„å‡¸åŒ…ä¸Šæ¥è¾¹,å¾—åˆ°ä¸‹ä¸€ä¸ªè¾¹çš„ç»ˆç‚¹. å¯¹äºä¸¤ä¸ªå‡¸åŒ…,æˆ‘ä»¬è¦é€‰æ‹©æ›´ä¼˜çš„,åŠå‰ç§¯çš„åˆ¤æ–­. æœ€å,æˆ‘ä»¬å†å¯¹æ‰€å¾—é›†åˆè¿›è¡Œä¸€æ¬¡æ±‚å‡¸åŒ…,å°±ç»“æŸäº† ä¾‹é¢˜æ¨èbzoj 2564é›†åˆçš„é¢ç§¯JSOI2018æˆ˜äº‰è§£æ:JSOI2018æˆ˜äº‰ æ³¨å¯¹äº$A-B$,è¿™ä¸ªç­‰å¼æ˜¯è¿™ä¹ˆå†™çš„$A-B=\{c\rvert c+B\subseteq A\}$æˆ‘ä»¬ç§°å…¶ä¸ºé—µå¯å¤«æ–¯åŸºå·®å½“ç„¶,å–åè¿™ä¸ªéªšæ“ä½œ,è¿˜æ˜¯æ›´å¥½ç”¨]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å°å‡¸æƒ³è·‘æ­¥-åŠå¹³é¢äº¤]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%B0%8F%E5%87%B8%E6%83%B3%E8%B7%91%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®å¤§æ„åœ¨ä¸€ä¸ªå‡¸åŒ…é‡Œ,æ‰¾ä¸€ä¸ªç‚¹$p$,ä½¿å¾—è¯¥ç‚¹ä¸$\{k,k+1,k\in(1,n-1)\}$ç»„æˆçš„ä¸‰è§’å½¢é¢ç§¯å¤§äºå’Œ$\{0,1\}$ç»„æˆçš„ä¸‰è§’å½¢é¢ç§¯. è§£æé¦–å…ˆ,æˆ‘ä»¬è€ƒè™‘ç‚¹çš„å–å€¼èŒƒå›´.å¿…å®šåœ¨å‡¸åŒ…å†…ä»¥åŠå‡¸åŒ…çš„è¾¹ç•Œä¸Š.ç”¨çº¿æ€§è§„åˆ’åŠå¹³é¢äº¤è¡¨ç¤ºå³ä¸º:æ¯ä¸ªè¾¹æ‰€åœ¨ç›´çº¿çš„å·¦åŠè¾¹åŒºåŸŸäº¤é›†.å†è€ƒè™‘,ä¸‰è§’å½¢é¢ç§¯å…³ç³»:$\overrightarrow{(x_1-x,y_1-y)}\times\overrightarrow{(x_0-x,y_0-y)}\leq\overrightarrow{(x_{k+1}-x,y_{k+1}-y)}\times\overrightarrow{(x_k-x,y_k-y)}$ç„¶åä¸€å †åŒ–ç®€æ•´ç†ä¹‹å:$(y_1-y_0-y_{k+1}+y_k)x+(x_0-x_1-x_k+x_{k+1})y+(x_1y_0-x_0y_1-x_{k+1}y_k+x_ky_{k+1})\ge 0$ä¸€ä¸ªå½¢å¦‚$ax+by+c\ge 0$çš„å¼å­å°±å†™å‡ºæ¥äº†.å¯¹äºä¸€ä¸ªå½¢å¦‚ä¸Šè¿°çš„å¼å­,è¯¥ç›´çº¿çš„å‘é‡ä¸º$(b,-a)$,æ ¹æ®è¿™ä¸ªå°±å¯ä»¥ç”¨ä¸¤ç‚¹å¼è¡¨ç¤ºç›´çº¿.ç„¶åå¯¹äº$k\in\{1,n-1\}$çš„ç‚¹,éƒ½æ±‚ä¸€æ¬¡ç›´çº¿.å†ä¸ä¸Šé¢çš„ç›´çº¿æ±‚åŠå¹³é¢äº¤.å¾—åˆ°ç¬¦åˆæ¡ä»¶çš„è§£å³å¯. ä»£ç æˆ³æˆ‘æˆ³æˆ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 10;const double pi = acos(-1.0);const double inf = 1e100;const double eps = 1e-12;typedef struct point vec; //å‘é‡vecstruct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; double poe; point(double _x = 0, double _y = 0) : x(_x) , y(_y) &#123; &#125; point operator*(const point&amp; i_T) const &#123; return point(x * i_T.x, y * i_T.y); &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point&amp; i_T) const &#123; return x == i_T.x &amp;&amp; y == i_T.y; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point&amp; i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point&amp; i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return a.y == b.y ? a.x &lt; b.x : a.y &lt; b.y; &#125; void atn2() &#123; poe = atan2(y, x); &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.2f %.2f", a.x, a.y); return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; scanf("%lf%lf", &amp;a.x, &amp;a.y); return in; &#125;&#125;;typedef struct Line Segment; //çº¿æ®µSegmentstruct Line &#123; //ç›´çº¿ point a, b; double poe; Line(point _a = point(), point _b = point()) : a(_a) , b(_b) &#123; &#125; bool operator==(const Line&amp; i_T) const &#123; return a == i_T.a &amp;&amp; b == i_T.b; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, Line&amp; a) &#123; cin &gt;&gt; a.a &gt;&gt; a.b; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Line&amp; a) &#123; out &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b; return out; &#125; void atn2() &#123; poe = atan2(b.y - a.y, b.x - a.x); &#125;&#125;;double chaji(vec A, vec B) //æ±‚å‘é‡å‰ç§¯&#123; return A.x * B.y - A.y * B.x; // æ­£ä¸ºA-&gt;Bå·¦æ—‹&#125;int zhengfu(double d) //åˆ¤æ–­æ­£è´Ÿ&#123; if (fabs(d) &lt; eps) return 0; if (d &gt; 0) return 1; return -1;&#125;int bijiao(double x, double y)&#123; if (fabs(x - y) &lt; eps) return 0; if (x &gt; y) return 1; return -1;&#125;bool cmp(Line l1, Line l2) //åŠå¹³é¢äº¤çš„æè§’æ’åº&#123; return bijiao(l1.poe, l2.poe) == 0 ? zhengfu(chaji(l1.b - l1.a, l2.b - l1.a)) &gt; 0 : l1.poe &lt; l2.poe;&#125;point p[MAXN];Line l[MAXN], q[MAXN];point zhixian_zhixian_jiaodian(Line l1, Line l2) //ä¸¤ç›´çº¿äº¤ç‚¹&#123; double t = ((l1.a.x - l2.a.x) * (l2.a.y - l2.b.y) - (l1.a.y - l2.a.y) * (l2.a.x - l2.b.x)) / ((l1.a.x - l1.b.x) * (l2.a.y - l2.b.y) - (l1.a.y - l1.b.y) * (l2.a.x - l2.b.x)); return l1.a + (l1.b - l1.a) * t;&#125;double duobianxingmianji(point po[], int num) //å¤šè¾¹å½¢é¢ç§¯&#123; double ans = 0; po[num + 1] = po[1]; for (int i = 1; i &lt;= num; i++) ans += chaji(po[i], po[i + 1]); ans = fabs(ans) * 0.5; return ans;&#125;double solve(int head, int tail)&#123; int num = 0; q[tail + 1] = q[head]; for (int i = head; i &lt;= tail; i++) p[++num] = zhixian_zhixian_jiaodian(q[i], q[i + 1]); if (num &lt; 3) return 0; return duobianxingmianji(p, num);&#125;bool check(Line a, Line b, Line c) //åˆ¤æ–­a,bäº¤ç‚¹æ˜¯å¦åœ¨cçš„å³è¾¹&#123; point o = zhixian_zhixian_jiaodian(a, b); return zhengfu(chaji(c.b - c.a, o - c.a)) &lt; 0;&#125;void banpingmian_jiao(int&amp; head, int&amp; tail, Line L[], int t) //æ±‚åŠå¹³é¢äº¤&#123; sort(L + 1, L + t + 1, cmp); head = 1, tail = 0; int cnt = 0; for (int i = 1; i &lt; t; i++) &#123; if (bijiao(L[i].poe, L[i + 1].poe) == 0) continue; L[++cnt] = L[i]; //å› ä¸ºæ’è¿‡åºï¼Œå³ä½¿æè§’ç›¸åŒï¼Œåé¢çš„ä¹Ÿæ¯”å‰é¢çš„ä¼˜ &#125; L[++cnt] = L[t]; for (int i = 1; i &lt;= cnt; i++) &#123; while (head &lt; tail &amp;&amp; check(q[tail - 1], q[tail], L[i])) tail--; while (head &lt; tail &amp;&amp; check(q[head + 1], q[head], L[i])) head++; q[++tail] = L[i]; &#125; while (head &lt; tail &amp;&amp; check(q[tail - 1], q[tail], q[head])) tail--; while (head &lt; tail &amp;&amp; check(q[head + 1], q[head], q[tail])) head++;&#125;int main()&#123; int n; cin &gt;&gt; n; double ans=0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; p[n + 1] = p[1]; ans=duobianxingmianji(p,n); for (int i = 1; i &lt;= n; i++)&#123; l[i] = Line(p[i], p[i + 1]); l[i].atn2(); &#125; int t = n; for (int i = 2; i &lt;= n; i++) &#123; double a = (p[2] - p[1] - p[i + 1] + p[i]).y; double b = (p[1] - p[2] - p[i] + p[i + 1]).x; double c = p[2].x * p[1].y - p[1].x * p[2].y - p[i + 1].x * p[i].y + p[i].x * p[i + 1].y; if (zhengfu(a) == zhengfu(b) &amp;&amp; zhengfu(a) == 0) continue; if (zhengfu(a)!=0) &#123; l[++t] = Line(point(-c / a, 0), point(-c / a + b, -a)); &#125; else if (zhengfu(b)!=0) &#123; l[++t] = Line(point(0, -c / b), point(b, -c / b - a)); &#125; l[t].atn2(); &#125; int head, tail; banpingmian_jiao(head, tail, l, t); printf("%.4f\n", solve(head, tail)/ans); return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠå¹³é¢äº¤]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆæ˜¯å®šä¹‰ ä¸€æ¡ç›´çº¿å’Œç›´çº¿çš„ä¸€ä¾§ç§°ä¸ºä¸€ä¸ªåŠå¹³é¢ã€‚åŠå¹³é¢æ˜¯ä¸€ä¸ªç‚¹é›†ï¼Œå› æ­¤æ˜¯ä¸€æ¡ç›´çº¿å’Œç›´çº¿çš„ä¸€ä¾§æ„æˆçš„ç‚¹é›†ã€‚å½“åŒ…å«ç›´çº¿æ—¶ï¼Œç§°ä¸ºé—­åŠå¹³é¢ï¼›å½“ä¸åŒ…å«ç›´çº¿æ—¶ï¼Œç§°ä¸ºå¼€åŠå¹³é¢ã€‚ ä¸€èˆ¬æ¥è®²,éƒ½å†™æˆ$ax+by+c\ge 0$.æ˜¯ä¸æ˜¯å¾ˆçœ¼ç†Ÿ,çº¿æ€§è§„åˆ’è®°å¾—ä¸,è¿˜æœ‰å„ç§é¬¼ç•œåº”ç”¨é¢˜.ç”¨æ¥æ±‚$(x,y)$çš„å–å€¼èŒƒå›´.ç„¶ååŠå¹³é¢äº¤å‘¢â€¦.å°±æ˜¯æŠŠä¸€å †åŠå¹³é¢çš„äº¤é›†æ±‚å‡ºæ¥,å°±æ˜¯åŠå¹³é¢äº¤äº†.$\begin{cases}a_1x+b_1y+c_1\ge 0\\a_2x+b_2y+c_2\ge 0\\â€¦\end{cases}$æ˜‚,å°±è¿™æ ·å­,ç”»ç”»å›¾,å°±å‘ç°æ˜¯ä¸ªçº¿æ€§è§„åˆ’é—®é¢˜äº†â€¦ å“¦,è¿˜æœ‰å¤šè¾¹å½¢çš„æ ¸å®šä¹‰æ˜¯: å¦‚æœä¸€ä¸ªç‚¹é›†ä¸­çš„ç‚¹ä¸å¤šè¾¹å½¢ä¸Šä»»æ„ä¸€ç‚¹çš„è¿çº¿ä¸å¤šè¾¹å½¢æ²¡æœ‰å…¶ä»–äº¤ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹é›†è¢«ç§°ä¸ºå¤šè¾¹å½¢çš„æ ¸ã€‚ ç„¶åæ±‚è§£ä¹Ÿå¾ˆç®€å•,ä¹Ÿæ˜¯åŠå¹³é¢äº¤,ä»¥é€†æ—¶é’ˆæ–¹å‘ä¸ºæ­£æ–¹å‘,å°†å¤šè¾¹å½¢æ¯ä¸ªè¾¹çœ‹æˆ$ax+by+c\ge 0$,æ±‚ä¸€ä¸‹äº¤é›†,å°±æ˜¯ç­”æ¡ˆ. å¦‚ä½•æ±‚è§£ä¸¤ç§æ–¹æ³•,ä¸€ç§åˆ†æ²»,ä¸€ç§æ’åºå¢é‡æ³•,å«$S\&amp;I$ç®—æ³•å¥½åƒ.å½“ç„¶,å·¥å…·äººåªå­¦ç®€å•çš„2333. æˆ‘ä»¬ä»¥é€†æ—¶é’ˆä¸ºæ­£æ–¹å‘,åŠå¹³é¢ä¸ºå‘é‡æ–¹å‘çš„å·¦æ‰‹. ç»´æŠ¤ä¸€ä¸ªåŒç«¯é˜Ÿåˆ— åŠ å…¥ä¸€ä¸ªç›´çº¿,å°±åˆ¤æ–­$tail-1$å’Œ$tail$çš„äº¤ç‚¹åœ¨è¯¥ç›´çº¿çš„å“ªè¾¹. åœ¨å³é¢,è¯´æ˜$tail$çš„ç›´çº¿è¢«æ–°åŠ å…¥çš„ç›´çº¿è¦†ç›–äº†,äºæ˜¯$tailâ€“$ åœ¨å·¦é¢,ä¸åšå¤„ç† å¯¹äºé˜Ÿé¦–å…ƒç´ ,è¿›è¡ŒåŒæ ·æ“ä½œ. æ”¾å…¥é˜Ÿåˆ—ä¸­ å…¨éƒ¨éå†ç»“æŸå,å†åˆ†åˆ«å°†$\{tail-1,tail,head\}$ä»¥åŠ$\{head+1,head,tail\}$è¿™ä¸¤ç§æƒ…å†µçš„ä¸‰ä¸ªç›´çº¿åˆ†åˆ«åˆ¤æ–­. ä»£ç æˆ³æˆ‘æˆ³æˆ‘ 12345678910111213141516171819202122232425262728293031323334bool cmp(Line l1, Line l2) //åŠå¹³é¢äº¤çš„æè§’æ’åº&#123; return bijiao(l1.poe, l2.poe) == 0 ? zhengfu(chaji(l1.b - l1.a, l2.b - l1.a)) &gt; 0 : l1.poe &lt; l2.poe;&#125;bool check(Line a, Line b, Line c) //åˆ¤æ–­a,bäº¤ç‚¹æ˜¯å¦åœ¨cçš„å³è¾¹&#123; point o = zhixian_zhixian_jiaodian(a, b); return zhengfu(chaji(c.b - c.a, o - c.a)) &lt; 0;&#125;void banpingmian_jiao(int&amp; head, int&amp; tail, Line L[], int t) //æ±‚åŠå¹³é¢äº¤&#123; sort(L + 1, L + t + 1, cmp); head = 1, tail = 0; int cnt = 0; for (int i = 1; i &lt; t; i++) &#123; if (bijiao(L[i].poe, L[i + 1].poe) == 0) continue; L[++cnt] = L[i]; //å› ä¸ºæ’è¿‡åºï¼Œå³ä½¿æè§’ç›¸åŒï¼Œåé¢çš„ä¹Ÿæ¯”å‰é¢çš„ä¼˜ &#125; L[++cnt] = L[t]; for (int i = 1; i &lt;= cnt; i++) &#123; while (head &lt; tail &amp;&amp; check(q[tail - 1], q[tail], L[i])) tail--; while (head &lt; tail &amp;&amp; check(q[head + 1], q[head], L[i])) head++; q[++tail] = L[i]; &#125; while (head &lt; tail &amp;&amp; check(q[tail - 1], q[tail], q[head])) tail--; while (head &lt; tail &amp;&amp; check(q[head + 1], q[head], q[tail])) head++;&#125; ä¾‹é¢˜æ¨è JLOI2013 èµ›è½¦ CQOI2006 å‡¸å¤šè¾¹å½¢ SCOI2015å°å‡¸æƒ³è·‘æ­¥ é¢˜è§£:My blog]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€å°è¦†ç›–åŒåœ†é—®é¢˜]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8F%8C%E5%9C%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[å‰ç½®çŸ¥è¯†:æœ€å°åœ†è¦†ç›–æ´›è°·P1742 æœ€å°åœ†è¦†ç›–&emsp;&emsp;ç»™å®šå¹³é¢ä¸€å®šæ•°é‡çš„ç‚¹,æ‰¾ä¸€ä¸ªæœ€å°çš„åœ†,å°†æ‰€æœ‰ç‚¹åŒ…å«è¿›å».&emsp;&emsp;ç„¶å,å°±ä¸è®°å¾—æ˜¯å“ªä½å¤§ä½¬æå‡ºäº†ä¸€ç§$O(n)$çš„è§£å†³æ–¹å¼,éšæœºå¢é‡æ³•. ä¿è¯æ•°æ®çš„éšæœºæ€§,æˆ‘ä»¬ä½¿ç”¨$random\_shuffle$è¿™ä¸ªå‡½æ•° æˆ‘ä»¬è¦æ¥å—ä¸€ä¸ªå®šç†:å¦‚æœç‚¹$p$ä¸åœ¨é›†åˆ$S$çš„æœ€å°è¦†ç›–åœ†å†…,é‚£ä¹ˆè‚¯å®šåœ¨$p\cup S$çš„æœ€å°è¦†ç›–åœ†ä¸Š. é¦–å…ˆ,å‡è®¾æˆ‘ä»¬å·²ç»æ±‚å‡ºäº†å‰$i$ä¸ªç‚¹å½¢æˆçš„æœ€å°è¦†ç›–åœ† å¦‚æœ$i+1$è¿™ä¸ªç‚¹ä¸åœ¨$C_i$åœ†å†…,é‚£ä¹ˆè¯¥$P_{i+1}$å¿…å®šåœ¨$C_{i+1}$ä¸Š é‚£ä¹ˆæˆ‘ä»¬ä»¥$P_{i+1}$ä¸ºåœ†å¿ƒ,åŠå¾„ä¸º$0$ä½œä¸ºèµ·å§‹åœ†,æ‰¾åˆ°ç¬¬$j$ä¸ªç‚¹,ä¿è¯$dis\{i+1,j\}&gt;$å½“å‰åœ†çš„åŠå¾„.ä»¥è¿™ä¸¤ç‚¹ä¸ºåœ†$C_{i+1,j}$åŠå¾„ä¸º$dis\{i+1,j\}$,åœ†å¿ƒä¸º$\frac{P_{i+1}+P_j}{2}$ å†å¯»æ‰¾ç¬¬ä¸‰ä¸ªç‚¹ä¸åœ¨$C_{i+1,j}$,è®¾ä¸ºç¬¬$k$ä¸ªç‚¹,é‚£ä¹ˆä»¥$i,j,k$ä¸‰ç‚¹çš„åœ†å³å¯è¢«è®¤ä¸ºæ˜¯æœŸæœ›çš„æœ€å°è¦†ç›–åœ†$C_{i+1,j,k}$ ä¸æ–­é‡å¤$3-6$æ­¥éª¤,å³å¯å¾—åˆ°ç­”æ¡ˆ. &emsp;&emsp;ä½“æ„Ÿå°±æ˜¯$O(n^3)$çš„å˜›,åœ¨æ•°æ®ä¸éšæœºçš„æƒ…å†µä¸‹,ä¼šé€€åŒ–ä¸º$O(n^3)$,ä½†åœ¨æ•°æ®å®Œå…¨éšæœºçš„æƒ…å†µä¸‹,é¢„æœŸæœŸæœ›å¤æ‚åº¦ä¸º$O(n)$. ä»£ç æˆ³æˆ‘æˆ³æˆ‘ 1234567891011121314151617181920212223cirles zuixiaoyuan_fugai(int l, int r) //æœ€å°åœ†è¦†ç›–&#123; if (l &gt; r) return 0; for (int i = l; i &lt;= r; i++) s[i] = p[i]; random_shuffle(s + l, s + r + 1); cirles c(s[l], 0.0); for (int i = l; i &lt;= r; i++) if (zhengfu(sqr(c.o - s[i]) - c.r) &gt; 0) &#123; c = cirles(s[i], 0.0); for (int j = l; j &lt; i; j++) if (zhengfu(sqr(c.o - s[j]) - c.r) &gt; 0) &#123; c.o = (s[i] + s[j]) * 0.5, c.r = sqr(c.o - s[j]); for (int k = l; k &lt; j; k++) if (zhengfu(sqr(c.o - s[k]) - c.r) &gt; 0) &#123; c.o = sanjiaoxing_waixin(s[i], s[j], s[k]), c.r = sqr(c.o - s[k]); &#125; &#125; &#125; return c;&#125; æœ€å°è¦†ç›–åŒåœ†é—®é¢˜æ´›è°·P4586 æœ€å°è¦†ç›–åŒåœ†é—®é¢˜åˆæ˜¯ä¸€é“è€ƒéªŒäººç±»æ™ºæ…§çš„é—®é¢˜.é¦–å…ˆ,æˆ‘ä»¬è€ƒè™‘æœ€å¥½æƒ…å†µ.åŠä¸¤åœ†åŠå¾„ç›¸åŒ,å‡åˆ†äº†ä¸¤ä¾§çš„ç‚¹.å¦‚ä¸‹å›¾:(å¤§æ¦‚çš„ç”»ç”»å°±è¡Œå•¦)åæ­£å°±æ˜¯å¦‚ä½•è®©ä¸¤è¾¹çš„åœ†çš„åŠå¾„æ¥è¿‘ç›¸åŒ.å¾ˆæ˜¾ç„¶çš„äºŒåˆ†,å…ˆå¯¹ä¸¤è¾¹å„åšä¸€æ¬¡æœ€å°åœ†,å¾—åˆ°ä¸¤ä¸ªåœ†çš„åŠå¾„,æˆ‘ä»¬åªéœ€è¦åœ¨å¤§çš„åŠå¾„é‡ŒäºŒåˆ†ä¸€å“ˆ.ç„¶åå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆå•¦.ä½†æ˜¯æœ‰ä¸ªé—®é¢˜,åˆ’åˆ†ä¸¤ä¸ªé›†åˆçš„è¿™æ¡çº¿å¯èƒ½æ˜¯æ–œçš„,æ‰€ä»¥æˆ‘ä»¬è¿˜è¦æš´åŠ›è½¬è§’.æ¯æ¬¡è½¬é‚£ä¹ˆ$1Â°$,è½¬é‚£ä¹ˆ$180$æ¬¡å°±å·®ä¸å¤š.è½¬çš„è¶Šå¤š,ç²¾åº¦è¶Šé«˜,æ—¶é—´è¶Šé•¿.(åªè¦ç›¸ä¿¡ä½ è‡ªå·±æ˜¯æ¬§çš‡,ä½ å°±å¯ä»¥ä¸è¶…æ—¶åˆ$AC$) ä»£ç æˆ³æˆ‘æˆ³æˆ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 2 * 1e3 + 5;const double INF = 1e18;const double alpha = 1.0 / 180 * acos(-1);const double eps = 1e-9;const double pi = acos(-1.0);typedef struct point vec; //å‘é‡vecstruct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; point(double _x = 0, double _y = 0) : x(_x) , y(_y) &#123; &#125; point operator*(const point i_T) const &#123; return point(x * i_T.x, y * i_T.y); &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point i_T) const &#123; return x == i_T.x &amp;&amp; y == i_T.y; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.8f %.8f", a.x, a.y); return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; scanf("%lf%lf", &amp;a.x, &amp;a.y); return in; &#125;&#125;;struct cirles &#123; point o; double r; cirles(point _o = point(), double _r = 0.0) : r(_r) , o(_o) &#123; &#125; point Point(double t) //åœ†ä¸Šä»»æ„ä¸€ç‚¹ &#123; return point(o.x + r * cos(t), o.y + r * sin(t)); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, cirles&amp; a) &#123; in &gt;&gt; a.o &gt;&gt; a.r; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, cirles&amp; a) &#123; out &lt;&lt; a.o &lt;&lt; ' ' &lt;&lt; a.r; return out; &#125;&#125;;//æ±‚åœ†å¿ƒpoint s[MAXN], p[MAXN];int zhengfu(double d) //åˆ¤æ–­æ­£è´Ÿ&#123; if (fabs(d) &lt; eps) return 0; if (d &gt; 0) return 1; return -1;&#125;double changdu(vec a)&#123; return sqrt(a.x * a.x + a.y * a.y);&#125;double sqr(vec a)&#123; return a.x * a.x + a.y * a.y;&#125;point sanjiaoxing_waixin(point a, point b, point c) //ä¸‰è§’å½¢å¤–å¿ƒ&#123; double A = a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y, B = (b.x - a.x) * 2, C = (b.y - a.y) * 2; double D = c.x * c.x - b.x * b.x + c.y * c.y - b.y * b.y, E = (b.x - c.x) * 2, F = (b.y - c.y) * 2; return point((D * C - A * F) / (B * F - E * C), (D * B - A * E) / (C * E - F * B));&#125;vec xiangliang_xuanzhuan(vec a, double k) //å°†å‘é‡æŒ‰ç…§èµ·ç‚¹æ—‹è½¬é€†æ—¶é’ˆk,&#123; double x, y; x = cos(k) * a.x - sin(k) * a.y; y = sin(k) * a.x + cos(k) * a.y; return vec(x, y);&#125;double zuixiaoyuan_fugai(int l, int r) //æœ€å°åœ†è¦†ç›–&#123; if (l &gt; r) return 0; for (int i = l; i &lt;= r; i++) s[i] = p[i]; random_shuffle(s + l, s + r + 1); cirles c(s[l], 0.0); for (int i = l; i &lt;= r; i++) if (zhengfu(sqr(c.o - s[i]) - c.r) &gt; 0) &#123; c = cirles(s[i], 0.0); for (int j = l; j &lt; i; j++) if (zhengfu(sqr(c.o - s[j]) - c.r) &gt; 0) &#123; c.o = (s[i] + s[j]) * 0.5, c.r = sqr(c.o - s[j]); for (int k = l; k &lt; j; k++) if (zhengfu(sqr(c.o - s[k]) - c.r) &gt; 0) &#123; c.o = sanjiaoxing_waixin(s[i], s[j], s[k]), c.r = sqr(c.o - s[k]); &#125; &#125; &#125; return c.r;&#125;int main()&#123; //freopen("txt.txt", "w", stdout); srand(20030719); int n; while (scanf("%d", &amp;n) &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; double ans = INF; for (int i = 1; i &lt;= 181; i++) &#123; sort(p + 1, p + 1 + n); int l = 1, r = n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; double retl = zuixiaoyuan_fugai(1, mid); double retr = zuixiaoyuan_fugai(mid + 1, n); double tmp = max(retl, retr); if (retr + retl - tmp &gt; ans) break; ans = min(tmp, ans); if (retl &gt; retr) r = mid - 1; else l = mid + 1; &#125; for (int i = 1; i &lt;= n; i++) p[i] = xiangliang_xuanzhuan(p[i], alpha); &#125; printf("%.2lf\n", sqrt(ans)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coin Slider]]></title>
    <url>%2F2019%2F09%2F01%2FCoin-Slider%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®å¤§æ„è†œæ‹œä¸€ä½éœ“è™¹å¤§ä½¬%%%% å¹³é¢ä¸Šæœ‰ä¸€å †ä¸é‡å çš„ç¡¬å¸.ç»™å®šç¡¬å¸çš„èµ·ç‚¹å’Œç»ˆç‚¹,é—®æœ€å¤šå¯ä»¥æŠŠå¤šå°‘ä¸ªç¡¬å¸ä»èµ·ç‚¹ç›´çº¿ç§»åŠ¨åˆ°ç»ˆç‚¹,ä¸”ä¸ä¼šä¸å…¶ä»–ç¡¬å¸ç¢°æ’. è§£æçŠ¶å‹$dp$+è®¡ç®—å‡ ä½•ä¸€ä¸ªç¡¬å¸èƒ½å¦ç§»åŠ¨çš„æ¡ä»¶ä¸º:ç¬¬$i$æšç¡¬å¸çš„èµ·ç‚¹å’Œç»ˆç‚¹çš„è¿çº¿L,ä¸ç¬¬$j$ä¸ªç¡¬å¸ä¸­å¿ƒçš„è·ç¦»$d$æ˜¯å¦å¤§äºè¿™ä¿©ä¸ªç¡¬å¸åŠå¾„çš„å’Œ.å³$distance(L,O_j)&lt;r_j+r_i$å°†æ¯ä¸€ä¸ªç¡¬å¸æ˜¯å¦ç§»åŠ¨è¿‡å‹ç¼©ä¸º$0$å’Œ$1$,æ¯æ¬¡è¦ç§»åŠ¨$i_{th}$ç¡¬å¸æ—¶,å…ˆåˆ¤æ–­ç­”æ¡ˆè¿™ä¸€ä½æ˜¯ä¸æ˜¯$1$.å†æ ¹æ®ç­”æ¡ˆæ•°ä¸­çš„äºŒè¿›åˆ¶ä½åˆ¤æ–­$j_{th}$è¿™ä¸ªåœ†æ˜¯åœ¨ç»ˆç‚¹è¿˜æ˜¯èµ·ç‚¹.æœ€åå†åˆ¤æ–­èƒ½å¦ç§»åŠ¨,æ›´æ–°ç­”æ¡ˆå³å¯. ä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100 + 10;const double eps = 1e-5;const double pi = acos(-1.0);typedef struct point vec;struct point &#123; double x, y; point() &#123;&#125; point(double a, double b) &#123; x = a, y = b; &#125; point operator*(const point&amp; i_T) const &#123; return point(x * i_T.x, y * i_T.y); &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; bool operator&gt;(const point a) const &#123; return x == a.x ? y &gt; a.y : x &gt; a.x; &#125; point operator-(const point a) const &#123; return point(x - a.x, y - a.y); &#125; point operator+(const point a) const &#123; return point(x + a.x, y + a.y); &#125; point operator+(double a) const &#123; return point(x + a, y + a); &#125; bool operator&lt;(const point a) const &#123; return y == a.y ? x &lt; a.x : y &lt; a.y; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; cout &lt;&lt; a.x &lt;&lt; ',' &lt;&lt; a.y; return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; in &gt;&gt; a.x &gt;&gt; a.y; return in; &#125;&#125;;typedef struct Line Segment; //çº¿æ®µSegmentstruct Line &#123; //ç›´çº¿ vec a, b; Line(point _a = point(), point _b = point()) : a(_a) , b(_b) &#123; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, Line&amp; a) &#123; cin &gt;&gt; a.a &gt;&gt; a.b; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Line&amp; a) &#123; out &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b; return out; &#125;&#125;;struct cirles &#123; point o; double r; cirles(point _o = point(), double _r = 0.0) : r(_r) , o(_o) &#123; &#125; point Point(double t) //åœ†ä¸Šä»»æ„ä¸€ç‚¹ &#123; return point(o.x + r * cos(t), o.y + r * sin(t)); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, cirles&amp; a) &#123; in &gt;&gt; a.o &gt;&gt; a.r; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, cirles&amp; a) &#123; out &lt;&lt; a.o &lt;&lt; ' ' &lt;&lt; a.r; return out; &#125;&#125;;struct ceshi2 &#123; cirles s, t;&#125;;int dayu_dengyu(double x, double y)&#123; if (fabs(x - y) &lt; eps || x &gt; y) return 1; return 0;&#125;int zhengfu(double x)&#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;double changdu(vec a) //é•¿åº¦&#123; return sqrt(a.x * a.x + a.y * a.y);&#125;double dianji(vec A, vec B) //ç‚¹ç§¯&#123; return A.x * B.x + A.y * B.y;&#125;double dian_dao_xianduan(Segment l, point c) //ç‚¹åˆ°çº¿æ®µçš„è·ç¦»&#123; double L = changdu(l.b - l.a); double r = dianji(l.b - l.a, c - l.a) / (L * L); if (zhengfu(r) == -1) &#123; return changdu(c - l.a); &#125; else if (dayu_dengyu(r, 1)) &#123; return changdu(c - l.b); &#125; else &#123; double L = r * changdu(l.b - l.a), l2 = changdu(c - l.a); return sqrt(l2 * l2 - L * L); &#125;&#125;int query(int x)&#123; int cnt = 0; while (x &gt; 0) &#123; cnt++; x -= (x &amp; -x); &#125; return cnt;&#125;int dp[1 &lt;&lt; 22], N;ceshi2 K[MAXN];int main()&#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; K[i].s.r &gt;&gt; K[i].s.o &gt;&gt; K[i].t.o; K[i].t.r = K[i].s.r; &#125; dp[0] = 1; for (int msk = 0; msk &lt; (1 &lt;&lt; N); msk++) if (dp[msk]) for (int i = 0; i &lt; N; i++) if (!(msk &amp; (1 &lt;&lt; i))) &#123; //å¦‚æœç¡¬å¸è¢«ç§»åŠ¨è¿‡äº† //åˆ¤æ–­å…¶ä»–ç¡¬å¸ä½ç½®æ˜¯åœ¨s,è¿˜æ˜¯åœ¨t vector&lt;cirles&gt; V; for (int j = 0; j &lt; N; j++) if (i != j) if (msk &amp; (1 &lt;&lt; j)) V.push_back(K[j].t); else V.push_back(K[j].s); //åˆ¤æ–­è¯¥ç¡¬å¸èƒ½å¦ç§»åŠ¨ Line l(K[i].s.o, K[i].t.o); int ok = 1, n = V.size(); for (int j = 0; j &lt; n; j++) &#123; double d = dian_dao_xianduan(l, V[j].o); if (d &lt; K[i].s.r + V[j].r - eps) ok = 0; &#125; if (ok) dp[msk + (1 &lt;&lt; i)] = 1; &#125; int ans = 0; for (int msk = 0; msk &lt; (1 &lt;&lt; N); msk++) if (dp[msk]) ans = max(ans, query(msk)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rolling The Polygon]]></title>
    <url>%2F2019%2F08%2F31%2FRolling-The-Polygon%2F</url>
    <content type="text"><![CDATA[2018-2019 ACM-ICPC, China Multi-Provincial Collegiate Programming ContestThe 2018/2019 Asia Yinchuan First Round Online Programmingé¢˜ç›®å¤§æ„ä¸€ä¸ªå‡¸åŒ…,å‡¸åŒ…ä¸Šæœ‰ä¸€ä¸ªç‚¹$G$åœ¨æ°´å¹³é¢ä¸Šæ»šåŠ¨å‡¸åŒ…,é—®ç‚¹$G$çš„æ»šåŠ¨è½¨è¿¹é•¿åº¦æ˜¯å¤šå°‘. ç”»ä¸€ä¸ªå›¾å³æ±‚å¼§é•¿$HHâ€™$æ˜¾ç„¶~$âˆ ABN=âˆ HBHâ€™=âˆ CBI$é‚£ä¹ˆ,æ±‚$âˆ ABN$å°±ç›¸å½“äºæ±‚$\pi-âˆ ABC$è‡³äº$âˆ ABC$æ€ä¹ˆæ±‚,å°±å¾ˆæ˜¾ç„¶å•¦. ç‚¹å‡»æŸ¥çœ‹ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1.0)typedef struct point vec;struct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; double d; point(double _x = 0, double _y = 0) : x(_x) , y(_y) &#123; &#125; point operator*(const point&amp; i_T) const &#123; return point(x * i_T.x, y * i_T.y); &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point&amp; i_T) const &#123; return x == i_T.x &amp;&amp; y == i_T.y; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point&amp; i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point&amp; i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return a.y == b.y ? a.x &lt; b.x : a.y &lt; b.y; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.8f %.8f", a.x, a.y); return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; in &gt;&gt; a.x &gt;&gt; a.y; return in; &#125;&#125; p[100];double changdu(vec a) //å‘é‡é•¿åº¦&#123; return sqrt(a.x * a.x + a.y * a.y);&#125;double dianji(vec A, vec B) //ç‚¹ç§¯&#123; return A.x * B.x + A.y * B.y;&#125;double jiajiao(vec a, vec b)&#123; return pi - acos(dianji(a,b) / (changdu(a) * changdu(b)));&#125;int main()&#123; point p0; int n, t, cas = 1; scanf("%d", &amp;t); for (int k = 1; k &lt;= t; k++) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; cin &gt;&gt; p0; for (int i = 1; i &lt;= n; i++) p[i].d = changdu(p0 - p[i]); p[0] = p[n], p[n + 1] = p[1]; double ans = 0; for (int i = 1; i &lt;= n; i++) ans += p[i].d * jiajiao(p[i - 1]- p[i], p[i + 1]-p[i]); printf("Case #%d: %.3f\n", k, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡ç®—å‡ ä½•æ¨¡æ¿]]></title>
    <url>%2F2019%2F08%2F28%2FAOJ-CGL%2F</url>
    <content type="text"><![CDATA[è®¡ç®—å‡ ä½•æ¨¡æ¿æ­£å¦‚ä¸çŸ¥ä½•æ–¹å¤§ä½¬æ‰€è¨€,è®¡ç®—å‡ ä½•ç²¾å¦™ä¹‹å¤„,å°±æ˜¯ä¸ç”¨è§£æå‡ ä½•çš„æ–¹æ³•å»åšä¸ºäº†æ–¹ä¾¿æŸ¥æ‰¾,é˜²æ­¢è‡ªå·±è¿·è·¯,æˆ‘æŠŠå‡½æ•°åéƒ½å†™æˆäº†æ‹¼éŸ³ç»å¯¹ä¸æ˜¯å› ä¸ºæˆ‘è‹±è¯­ä¸å¥½!!! åŸºæœ¬æ•°æ®ç»“æ„ç‚¹å’Œå‘é‡: ç‚¹å’Œå‘é‡éƒ½å¯ä»¥ç”¨ä¸€ä¸ªåæ ‡$(x,y)$æ¥è¡¨ç¤º. æ•…å‘é‡$Vector$å¯ä»¥å†™ä¸º 1typedef struct point vec; å®Œæ•´å®šä¹‰å¦‚ä¸‹ ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647typedef struct point vec; //å‘é‡vecstruct point &#123; //ç‚¹çš„åŸºæœ¬æ•°æ®ç»“æ„ double x, y; point(double _x=0, double _y=0): x(_x),y(_y) &#123; &#125; point operator*(const point&amp; i_T) const &#123; return point(x * i_T.x, y * i_T.y); &#125; point operator*(double u) const &#123; return point(x * u, y * u); &#125; bool operator==(const point&amp; i_T) const &#123; return x == i_T.x &amp;&amp; y == i_T.y; &#125; point operator/(double u) const &#123; return point(x / u, y / u); &#125; point operator+(const point&amp; i_T) &#123; return point(x + i_T.x, y + i_T.y); &#125; point operator-(const point&amp; i_T) &#123; return point(x - i_T.x, y - i_T.y); &#125; friend bool operator&lt;(point a, point b) &#123; return a.y == b.y ? a.x &lt; b.x : a.y &lt; b.y; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, point&amp; a) &#123; //cout &lt;&lt; a.x &lt;&lt; ' ' &lt;&lt; a.y; printf("%.8f %.8f", a.x, a.y); return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, point&amp; a) &#123; in &gt;&gt; a.x &gt;&gt; a.y; return in; &#125;&#125;; ç›´çº¿å’Œçº¿æ®µ: ç›´çº¿å’Œçº¿æ®µéƒ½å¯ä»¥ç”¨ä¸¤ä¸ªç‚¹çš„åæ ‡æ¥è¡¨ç¤º æ•…çº¿æ®µ$Segment$å¯ä»¥å†™ä¸º 1typedef struct Line Segment; å®Œæ•´å®šä¹‰å¦‚ä¸‹ ä»£ç å†…å®¹ 12345678910111213141516171819typedef struct Line Segment; //çº¿æ®µSegmentstruct Line &#123; //ç›´çº¿ vec a, b; Line(point _a = point(), point _b = point()) : a(_a) , b(_b) &#123; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, Line&amp; a) &#123; cin &gt;&gt; a.a &gt;&gt; a.b; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Line&amp; a) &#123; out &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b; return out; &#125;&#125;; åœ†: åœ†çš„è¡¨ç¤ºæœ‰ä¸€ä¸ªç‚¹åœ†å¿ƒ,ä»¥åŠå…¶åŠå¾„ç»„æˆ å®Œæ•´å®šä¹‰å¦‚ä¸‹ ä»£ç å†…å®¹ 1234567891011121314151617181920212223struct cirles &#123; point o; double r; cirles(point _o = point(), double _r = 0.0) : r(_r) , o(_o) &#123; &#125; point Point(double t) //åœ†ä¸Šä»»æ„ä¸€ç‚¹ &#123; return point(o.x + r * cos(t), o.y + r * sin(t)); &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, cirles&amp; a) &#123; in &gt;&gt; a.o &gt;&gt; a.r; return in; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, cirles&amp; a) &#123; out &lt;&lt; a.o &lt;&lt; ' ' &lt;&lt; a.r; return out; &#125;&#125;; åŸºæœ¬å‡½æ•°ä»¥åŠå¸¸é‡ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const double pi = acos(-1.0);const double eps = 1e-12;int zhengfu(double d) //åˆ¤æ–­æ­£è´Ÿ,å³sign/dcmp&#123; if (fabs(d) &lt; eps) return 0; if (d &gt; 0) return 1; return -1;&#125;int bijiao(double x, double y) //åˆ¤æ–­xå’Œyçš„å¤§å°å…³ç³»&#123; if (fabs(x - y) &lt; eps) return 0; if (x &gt; y) return 1; return -1;&#125;int dayu_dengyu(double x, double y) //x&gt;=yå¦?&#123; if (fabs(x - y) &lt; eps || x &gt; y) return 1; return 0;&#125;double chaji(vec A, vec B) //æ±‚å‘é‡å‰ç§¯,å³cross&#123; return A.x * B.y - A.y * B.x; // æ­£ä¸ºA-&gt;Bå·¦æ—‹&#125;double xuanzhuan(point a, point b, point c) //æ±‚ä¸‰ç‚¹å‰ç§¯,å³side&#123; return chaji(b - a, c - a);&#125;bool cmp(vec a, vec b) //æè§’æ’åº,è¿ç”¨å‰ç§¯çš„æè§’æ’åº,ç›¸æ¯”äºatan2æ…¢,ä½†æ˜¯ç²¾åº¦é«˜&#123; vec c(0, 0); if (chaji(a - c, b - c) == 0) return a.x &lt; b.x; return chaji(a - c, b - c) &gt; 0;&#125;double dianji(vec A, vec B) //ç‚¹ç§¯&#123; return A.x * B.x + A.y * B.y;&#125;double changdu(vec a) //å‘é‡é•¿åº¦&#123; return sqrt(a.x * a.x + a.y * a.y);&#125; AOJç›¸å…³ä¹ é¢˜CGL_1_A:Projectionæ±‚ä¸€ä¸ªç‚¹åœ¨å‘é‡$\overrightarrow{ab}$ä¸Šçš„æŠ•å½±åæ ‡è®¾ç‚¹$c$,æŠ•å½±åœ¨$\overrightarrow{ab}$ä¸Šä¸º$câ€™$,åˆ™$câ€™$çš„åæ ‡å°±æ˜¯:$cos&lt;\overrightarrow{ac},\overrightarrow{ab}&gt;\times |\overrightarrow{ac}|+a$ ä»£ç å†…å®¹ 12345678point touying(Line l, point c) //cæŠ•å½±åœ¨ç›´çº¿abä¸Šçš„ä½ç½®&#123; vec A = l.b - l.a; vec B = c - l.a; double La = changdu(A); double Lc = dianji(A, B) / (La * La); return A * Lc + l.a;&#125; CGL_1_B:Reflectionæ±‚ä¸€ä¸ªç‚¹$c$å…³äºå‘é‡$\overrightarrow{ab}$çš„å¯¹ç§°ç‚¹$câ€™â€™$å…ˆæ±‚å‡º$c$åœ¨$ab$ä¸Šçš„æŠ•å½±,é‚£ä¹ˆ$câ€™â€™=2\times \overrightarrow{ccâ€™}+c$ ä»£ç å†…å®¹ 12345point fanshe(Line l, point c) //æ±‚cå…³äºç›´çº¿abçš„å¯¹ç§°ç‚¹c'&#123; point A = touying(l, c); return (A - c) * 2.0 + c;&#125; CGL_1_C:Counter-Clockwiseå°±æ˜¯..æ ¹æ®å›¾ä¸­çš„åˆ¤æ–­å°±æ˜¯äº† ä»£ç å†…å®¹ 12345678910111213141516171819void Counter_Clockwise(point p,point p1,point p2)&#123; if (zhengfu(chaji(p2 - p1, p - p1)) == 1) cout &lt;&lt; "COUNTER_CLOCKWISE" &lt;&lt; endl; else if (zhengfu(chaji(p2 - p1, p - p1)) == -1) cout &lt;&lt; "CLOCKWISE" &lt;&lt; endl; else &#123; if (zhengfu(dianji(p2 - p1, p - p1)) == -1) cout &lt;&lt; "ONLINE_BACK" &lt;&lt; endl; else &#123; double j = changdu(p2 - p1); double k = changdu(p - p1); if (bijiao(j, k) &gt;= 0) cout &lt;&lt; "ON_SEGMENT" &lt;&lt; endl; else cout &lt;&lt; "ONLINE_FRONT" &lt;&lt; endl; &#125; &#125;&#125; CGL_2_A:Parallel/Orthogonalå…ˆåˆ¤å¹³è¡Œ,å†ç”¨ç‚¹ç§¯åˆ¤å‚ç›´ ä»£ç å†…å®¹ 12345678910111213141516bool pingxing(vec a,vec b)&#123; return bijiao(a.x*b.y,a.y*b.x)==0;&#125;void Parallel/Orthogonal(Line l1,Line l2)&#123; if (pingxing(l1.b-l1.a,l2.b-l2.a)) cout &lt;&lt; "2" &lt;&lt; endl; else &#123; if (zhengfu(dianji(l1.b-l1.a,l2.b-l2.a))==0) cout &lt;&lt; "1" &lt;&lt; endl; else &#123; cout &lt;&lt; "0" &lt;&lt; endl; &#125; &#125;&#125; CGL_2_B:Intersectionçº¿æ®µç›¸äº¤è¦è€ƒè™‘è›®å¤šçš„,é¦–å…ˆ,å…ˆæŒ‰ç…§xåyä»å°åˆ°å¤§æ’ä¸€ä¸‹.æœ€ç®€å•çš„æƒ…å†µ,$ab$ç©¿è¿‡$cd$,é‚£ä¹ˆå¿…å®šæœ‰äº¤ç‚¹.ç¬¬äºŒç§,$a$åœ¨$cd$ä¸Šæˆ–è€…$b$åœ¨$cd$ä¸Šç¬¬ä¸‰ç§,å…±çº¿æ—¶,$a$åœ¨$cd$ä¹‹é—´æˆ–$b$åœ¨$cd$ä¹‹é—´.å¤„ç†å¥½ä»¥ä¸Šé—®é¢˜,å°±è§£å†³äº† ä»£ç å†…å®¹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool bijiao3(vec a, vec b, vec c)&#123; if (a.x &lt;= c.x &amp;&amp; c.x &lt;= b.x &amp;&amp; ((a.y &lt;= c.y &amp;&amp; c.y &lt;= b.y || b.y &lt;= c.y &amp;&amp; c.y &lt;= a.y))) return 1; return 0;&#125;bool xianduan_xiangjiao(Segment l1,Segment l2) //ä¸¤çº¿æ®µæ˜¯å¦æœ‰äº¤ç‚¹&#123; if (l1.a.x == l1.b.x) &#123; if (l1.a.y &gt; l1.b.y) swap(l1.a, l1.b); &#125; else if (l1.a.x &gt; l1.b.x) swap(l1.a, l1.b); if (l2.a.x == l2.b.x) &#123; if (l2.a.y &gt; l2.b.y) swap(l2.a, l2.b); &#125; else if (l2.a.x &gt; l2.b.x) swap(l2.a, l2.b); double c1 = chaji(l1.b - l1.a, l2.a - l1.a), d1 = chaji(l1.b - l1.a, l2.b - l1.a); double c2 = chaji(l2.b - l2.a, l1.a - l2.a), d2 = chaji(l2.b - l2.a, l1.b - l2.a); if (zhengfu(c1 * d1) &lt; 0 &amp;&amp; zhengfu(c2 * d2) &lt; 0) //abæ¨ªç©¿cd return 1; else if (zhengfu(c1 * d1) != 0 &amp;&amp; zhengfu(c2 * d2) == 0) &#123; //abä¸ç©¿è¿‡cd if (zhengfu(c2) == 0) &#123; if (bijiao3(l2.a, l2.b, l1.a)) return 1; &#125; if (zhengfu(d2) == 0) if (bijiao3(l2.a, l2.b, l1.b)) return 1; &#125; else if (zhengfu(c1 * d1) == 0 &amp;&amp; zhengfu(c2 * d2) != 0) &#123; //cdä¸ç©¿è¿‡ab if (c1 == 0) if (bijiao3(l1.a, l1.b, l2.a)) return 1; if (d1 == 0) if (bijiao3(l1.a, l1.b, l2.b)) return 1; &#125; else if (zhengfu(c1 * d1) == 0 &amp;&amp; zhengfu(c2 * d2) == 0) &#123; //å¹³è¡Œ if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return 1; if (bijiao3(l1.a, l1.b, l2.a) == 1) return 1; if (bijiao3(l2.a, l2.b, l1.a) == 1) return 1; &#125; return 0;&#125; CGL_2_C:Cross Pointç»™ä½ ä¸¤ä¸ªå¿…å®šç›¸äº¤çš„çº¿æ®µ,æ±‚äº¤ç‚¹ ä»£ç å†…å®¹ 123456789101112131415point xianduan_jiaodian(Segment l1,Segment l2)//ä¸¤çº¿æ®µäº¤ç‚¹&#123; double tmpLeft, tmpRight, x = inf, y = inf; if (xianduan_xiangjiao(l1,l2)) &#123; tmpLeft = (l2.b.x - l2.a.x) * (l1.a.y - l1.b.y) - (l1.b.x - l1.a.x) * (l2.a.y - l2.b.y); tmpRight = (l1.a.y - l2.a.y) * (l1.b.x - l1.a.x) * (l2.b.x - l2.a.x) + l2.a.x * (l2.b.y - l2.a.y) * (l1.b.x - l1.a.x) - l1.a.x * (l1.b.y - l1.a.y) * (l2.b.x - l2.a.x); x = tmpRight / tmpLeft; tmpLeft = (l1.a.x - l1.b.x) * (l2.b.y - l2.a.y) - (l1.b.y - l1.a.y) * (l2.a.x - l2.b.x); tmpRight = l1.b.y * (l1.a.x - l1.b.x) * (l2.b.y - l2.a.y) + (l2.b.x - l1.b.x) * (l2.b.y - l2.a.y) * (l1.a.y - l1.b.y) - l2.b.y * (l2.a.x - l2.b.x) * (l1.b.y - l1.a.y); y = tmpRight / tmpLeft; &#125; return point(x, y);&#125; CGL_2_D:Distance ç»™å®šä¸¤ä¸ªä¸ç›¸äº¤çº¿æ®µ,æ±‚ä¸¤ä¸ªçº¿æ®µæœ€è¿‘è·ç¦» å¾ˆæ˜æ˜¾,æœ€è¿‘è·ç¦»å°±æ˜¯ä¸¤ä¸ªç«¯ç‚¹åˆ°å¦ä¸€ä¸ªçº¿æ®µçš„è·ç¦». é‚£ä¹ˆä¸¤éç‚¹åˆ°çº¿æ®µè·ç¦»å°±å‡ºæ¥äº†. ç‚¹åˆ°çº¿æ®µè·ç¦»æœ‰ä¸‰ç§ ç¬¬ä¸€ç§æ˜¯ç‚¹åœ¨çº¿æ®µæ­£ä¸Šæ–¹,åˆ™è·ç¦»ä¸ºè¿‡ç‚¹å‘çº¿æ®µä½œå‚çº¿ ç¬¬äºŒç§æ˜¯ç‚¹åœ¨å·¦ä¾§,å°±æ˜¯å·¦ç«¯ç‚¹å’Œè¯¥ç‚¹è¿çº¿ ç¬¬ä¸‰ç§åŒç¬¬äºŒç§,ä¸è¿‡åœ¨å³ä¾§ ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829double dian_dao_xianduan(Segment l, point c) //ç‚¹åˆ°çº¿æ®µçš„è·ç¦»&#123; double L = changdu(l.b - l.a); double r = dianji(l.b - l.a, c - l.a) / (L * L); if (zhengfu(r) == -1) &#123; return changdu(c - l.a); &#125; else if (dayu_dengyu(r, 1)) &#123; return changdu(c - l.b); &#125; else &#123; double L = r * changdu(l.b - l.a), l2 = changdu(c - l.a); return sqrt(l2 * l2 - L * L); &#125;&#125;double xianduanjuli(Segment l1,Segment l2) //ä¸¤çº¿æ®µè·ç¦»&#123; if (xianduan_xiangjiao(l1,l2)) return 0.0; double minn = inf; double l = dian_dao_xianduan(l1, l2.a); minn = dayu_dengyu(minn, l) ? l : minn; l = dian_dao_xianduan(l1, l2.b); minn = dayu_dengyu(minn, l) ? l : minn; l = dian_dao_xianduan(l2, l1.a); minn = dayu_dengyu(minn, l) ? l : minn; l = dian_dao_xianduan(l2, l1.b); minn = dayu_dengyu(minn, l) ? l : minn; return minn;&#125; CGL_3_A:Areaè®¡ç®—å¤šè¾¹å½¢é¢ç§¯çš„æ–¹æ³•è›®å¤šçš„.æœ€æš´åŠ›çš„å½“å±ä»¥åŸç‚¹å’Œå¤šè¾¹å½¢ä¸´è¿‘ä¸¤ç‚¹æ„æˆä¸‰è§’å½¢,ç„¶åè®¡ç®—ä¸‰è§’å½¢çš„æœ‰å‘é¢ç§¯.å¤šè¾¹å½¢å†…å¤–ç¬¦å·ä¸åŒ,æœ€åç•™ä¸‹çš„å°±æ˜¯å¤šè¾¹å½¢é¢ç§¯,ç„¶åfabsä¸€ä¸‹å°±å®Œäº‹äº†.è¿™ä¸ªåœ°æ–¹å»ºè®®â€è„‘æ´å¤§å¼€â€æˆ–è€…æ‹¿çº¸ç”»ç”».ä¸è¿‡è¦æ˜¯ä¼šä¸‰è§’å‰–åˆ†çš„è¯,æŠŠå¤šè¾¹å½¢æŒ‰é¡¶ç‚¹åˆ†å‰²æˆä¸€å †ä¸‰è§’å½¢,ç„¶åæ±‚é¢ç§¯ä¹Ÿé˜”ä»¥. ä»£ç å†…å®¹ 12345678double duobianxingmianji(int n) //å¤šè¾¹å½¢é¢ç§¯&#123; double ans = 0; for (int i = 1; i &lt;= n; i++) ans += chaji(p[i], p[(i + 1) % n]); ans = fabs(ans) * 0.5; return ans;&#125; CGL_3_B:Is-Convexé—®æ‰€ç»™çš„å¤šè¾¹å½¢æ˜¯ä¸æ˜¯å‡¸çš„.é¢˜ç›®ç»™çš„æ–¹æ³•æ˜¯è®¡ç®—å†…è§’å’Œ.å˜›,æ„Ÿè§‰å¥½éº»çƒ¦çš„äºšå­.è¿˜ä¸å¦‚æš´åŠ›æ±‚ä¸ªå‡¸åŒ…,çœ‹çœ‹æ‰€ç»™çš„å¤šè¾¹å½¢çš„ç‚¹æ•°æ˜¯ä¸æ˜¯å’Œå‡¸åŒ…ç‚¹æ•°ç›¸åŒæ¥çš„å¿«. ä»£ç å†…å®¹ 1234567891011121314151617void Andrew(int&amp; tail) //æ±‚å‡¸åŒ…&#123; sort(p + 1, p + 1 + n); tail = 1; q[1] = p[1]; for (int i = 2; i &lt;= n; i++) &#123; while (tail &gt; 1 &amp;&amp; xuanzhuan(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125; int basic = tail; for (int i = n - 1; i &gt;= 1; i--) &#123; while (tail &gt; basic &amp;&amp; xuanzhuan(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125;&#125; CGL_3_C:Polygon-Point Containmentå°±,åˆ¤æ–­ç‚¹å’Œå¤šè¾¹å½¢çš„ä½ç½®å…³ç³».çœ‹ç½‘ä¸Šéƒ½æ˜¯è§’åº¦å’Œæˆ–è€…å°„çº¿æ³•.ç»“æœå°±è®©æˆ‘æ‰¾åˆ°ä¸€ä¸ªçœ‹èµ·æ¥å¾ˆ$nb$çš„è±¡é™è§’åº¦æ³•?ä¸ç”¨è€ƒè™‘è§’åº¦çš„ç²¾åº¦é—®é¢˜,è¿˜ä¸ç”¨åƒå°„çº¿æ³•è€ƒè™‘å¤š?? ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool zaibianshang(point&amp; t,int n) //ç‚¹åœ¨å¤šè¾¹å½¢è¾¹ä¸Šå¦&#123; for (int i = 1; i &lt;=n; i++) if (dian_zai_xianshang(Line(p[i], p[(i + 1)%n]), t)) return 1; return 0;&#125;bool duobianxingnei(point&amp; t,int n) //ç‚¹åœ¨å¤šè¾¹å½¢å†…&#123; int t1, t2, sum, i; double f; p[0] = p[n]; for (i = 0; i &lt;= n; i++) p[i] = p[i] - t; // åæ ‡å¹³ç§» t1 = p[0].x &gt;= 0 ? (p[0].y &gt;= 0 ? 0 : 3) : (p[0].y &gt;= 0 ? 1 : 2); // è®¡ç®—è±¡é™ for (sum = 0, i = 1; i &lt;= n; i++) &#123; if (fabs(p[i].x)&lt;eps &amp;&amp; fabs(p[i].y)&lt;eps) break; // è¢«æµ‹ç‚¹ä¸ºå¤šè¾¹å½¢é¡¶ç‚¹ f = chaji(p[i - 1], p[i - 1]); // è®¡ç®—å‰ç§¯ if (fabs(f)&lt;eps &amp;&amp; p[i - 1].x * p[i].x &lt;= 0 &amp;&amp; p[i - 1].y * p[i].y &lt;= 0) break; // ç‚¹åœ¨è¾¹ä¸Š t2 = p[i].x &gt;= 0 ? (p[i].y &gt;= 0 ? 0 : 3) : (p[i].y &gt;= 0 ? 1 : 2); // è®¡ç®—è±¡é™ if (t2 == (t1 + 1) % 4) sum += 1; // æƒ…å†µ1 else if (t2 == (t1 + 3) % 4) sum -= 1; // æƒ…å†µ2 else if (t2 == (t1 + 2) % 4) // æƒ…å†µ3 if (f &gt; 0) sum += 2; else sum -= 2; t1 = t2; &#125; bool tf = 0; if (i &lt;= n || sum) tf = 1; for (i = 0; i &lt;= n; i++) p[i] = p[i] + t; // æ¢å¤åæ ‡ return tf;&#125; CGL_4_A:Convex Hullå°±æ˜¯â€¦æ±‚å‡¸åŒ…è¿™é‡Œæœ‰ä¸ªè›‹ç–¼çš„åœ°æ–¹,è¦æ±‚æ˜¯å…ˆæ’yå†æ’x ä»£ç å†…å®¹ 1234567891011121314151617void Andrew(int&amp; tail)&#123; sort(p + 1, p + 1 + n); tail = 1; q[1] = p[1]; for (int i = 2; i &lt;= n; i++) &#123; while (tail &gt; 1 &amp;&amp; xuanzhuan(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125; int basic = tail; for (int i = n - 1; i &gt;= 1; i--) &#123; while (tail &gt; basic &amp;&amp; xuanzhuan(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125;&#125; CGL_4_B:Diameter of a Convex Polygonæ‰¾åˆ°å‡¸åŒ…è·ç¦»æœ€è¿œçš„ä¸€å¯¹ç‚¹.å°±æ˜¯æ—‹è½¬å¡å£³å˜›.$O(n)$å¤æ‚åº¦å˜›. ä»£ç å†…å®¹ 1234567891011121314double tubao_zhijing(int tail) //æ±‚å‡ºå‡¸åŒ…ç›´å¾„&#123; double re = 0; if (tail == 2) //ä»…æœ‰ä¸¤ä¸ªç‚¹ return changdu(q[2] - q[1]); q[0] = q[tail]; //æŠŠæœ€åçš„ç‚¹æ”¾åˆ°æœ€å‰é¢ for (int i = 0, j = 2; i &lt; tail; i++) //æšä¸¾è¾¹ &#123; while (xuanzhuan(q[i], q[i + 1], q[j]) &lt; xuanzhuan(q[i], q[i + 1], q[j + 1])) j = (j + 1) % tail; re = max(re, max(changdu(q[j] - q[i]), changdu(q[j] - q[i + 1]))); &#125; return re;&#125; CGL_4_C:Convex Cutç”¨ä¸€æ¡ç›´çº¿åˆ‡å‰²å‡¸åŒ…,è¾“å‡ºå¾—åˆ°å›¾å½¢çš„åæ ‡.å°±æ˜¯é€†æ—¶é’ˆæ‰¾äº¤ç‚¹,æŒ‰ç…§ç›´çº¿çš„æ–¹å‘,$\overrightarrow{p_1p_2}$,å…ˆæ”¾å…¥é è¿‘$p_2$çš„ç‚¹,ç„¶åæŒ‰ç…§å‰ç§¯,å‘å·¦æ—‹è½¬çš„æ”¾å…¥ç‚¹. ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344int zhixian_xianduan_xiangjiao(Line l1, Segment l2) //ç›´çº¿ä¸çº¿æ®µæ˜¯å¦æœ‰äº¤ç‚¹&#123; double c1 = chaji(l1.b - l1.a, l2.a - l1.a), d1 = chaji(l1.b - l1.a, l2.b - l1.a); if (zhengfu(c1) == 0 &amp;&amp; zhengfu(d1) == 0) &#123; //é‡åˆ return -1; &#125; else if (zhengfu(c1 * d1) &lt;= 0) //æœ‰äº¤ç‚¹ return 1; return 0; //å¹³è¡Œ&#125;void qiegetubao(Line l)&#123; int tail = 0; q[0] = q[n]; int tf = -1, x; for (int i = 0; i &lt; n; i++) &#123; if (zhengfu(xuanzhuan(l.a,l.b,q[i])) == 1) p[++tail] = q[i]; int f = zhixian_xianduan_xiangjiao(l,Segment( q[i], q[i + 1])); if (f == 1) &#123; tf = 1; p[++tail] = zhixian_xianduan_jiaodian(l, Segment(q[i], q[i + 1])); &#125; else if (f == -1) &#123; tf = 0; x = i; break; &#125; &#125; if (tf == 0) &#123; //cout&lt;&lt;q[x+1]&lt;&lt;' '&lt;&lt;q[x]&lt;&lt;' '&lt;&lt;endl; if (zhengfu(dianji(l.b - l.a, q[x + 1] - q[x])) == -1) printf("%.8f\n", 0.0); else &#123; for (int i = 1; i &lt;= n; i++) p[i] = q[i]; printf("%.8f\n", duobianxingmianji(n)); &#125; &#125; else &#123; /*for (int i = 1; i &lt;= tail; i++) cout &lt;&lt; p[i] &lt;&lt; endl;*/ printf("%.8f\n", duobianxingmianji(tail)); &#125; q[0] = point(0, 0);&#125; CGL_5_A:Closest Pairåœ¨ç©ºé—´å†…æ‰¾åˆ°æœ€è¿‘çš„ç‚¹å¯¹åˆ†æ²»,å»ºè®®åˆ°æ´›è°·ä¸Šæœç´¢â€å¹³é¢æœ€è¿‘ç‚¹å¯¹(åŠ å¼ºç‰ˆ)â€ ä»£ç å†…å®¹ 123456789101112131415161718192021222324double solve(int l, int r)&#123; if (l == r) return inf; int mid = (l + r) &gt;&gt; 1; double ans = solve(l, mid); ans = min(ans, solve(mid + 1, r)); int tot = 0; for (int i = l; i &lt;= r; i++) if (fabs(p[mid].x - p[i].x) &lt;= ans) temp[tot++] = p[i]; sort(temp,temp+tot, cmp); for (int i = 0; i &lt; tot; i++) for (int j = i + 1; j &lt;tot; j++) &#123; if (temp[j].y - temp[i].y &gt; ans) break; ans = min(ans, changdu(temp[j] - temp[i])); &#125; return ans;&#125; CGL_6_A:Segment Intersections: Manhattan Geometryæ‰«æçº¿ç®—æ³•,ä¾‹é¢˜å¯åœ¨æ´›è°·ä¸Šæœç´¢â€æ‰«æçº¿â€æ±‚å¹³é¢$n$æ¡çº¿æ®µçš„äº¤ç‚¹ä¸ªæ•°.æœ‰ç©ºå•å¼€ä¸€ç« æ¥æ•´ç†è¿™ä¸ªç®—æ³•. ä»£ç å†…å®¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101struct SegTree &#123; int l, r; ll len; // sum: è¢«å®Œå…¨è¦†ç›–çš„æ¬¡æ•°ï¼› // len: åŒºé—´å†…è¢«æˆªçš„é•¿åº¦ã€‚&#125; tree[MAXN &lt;&lt; 2]; void build_tree(int x, int l, int r)&#123; tree[x].l = l, tree[x].r = r; tree[x].len = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build_tree(lson(x), l, mid); build_tree(rson(x), mid + 1, r); return;&#125; void pushup(int x)&#123; tree[x].len = tree[x &lt;&lt; 1].len + tree[x &lt;&lt; 1 | 1].len; // åˆå¹¶å„¿å­ä¿¡æ¯&#125; void edit_tree(int x, ll id, int c)&#123; int l = tree[x].l, r = tree[x].r; if (l == id &amp;&amp; id == r) &#123; tree[x].len += c; return; &#125; int mid = (l + r) &gt;&gt; 1; if (id &lt;= mid) edit_tree(lson(x), id, c); else edit_tree(rson(x), id, c); pushup(x);&#125; int query(int x, int L, int R)&#123; int l = tree[x].l, r = tree[x].r; if (L &lt;= l &amp;&amp; r &lt;= R) return tree[x].len; int mid = (l + r) &gt;&gt; 1; int res = 0; if (L &lt;= mid) res += query(lson(x), L, R); if (R &gt; mid) res += query(rson(x), L, R); return res;&#125;vector&lt;Line&gt; l;vector&lt;int&gt; X;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; point a, b; cin &gt;&gt; a &gt;&gt; b; if (a.x != b.x) &#123; if (a.x &gt; b.x) swap(a, b); X.push_back(a.x), X.push_back(b.x); l.push_back(Line(a, b, 2)); &#125; else &#123; if (a.y &gt; b.y) swap(a, b); X.push_back(a.x); l.push_back(Line(a, a, 1)); l.push_back(Line(b, b, 3)); &#125; &#125; sort(l.begin(), l.end()); sort(X.begin(), X.end()); n = unique(X.begin(), X.end()) - X.begin(); //å»é‡ X.erase(X.begin() + n, X.end()); if(n==1)&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; build_tree(1, 1, n); //æ ¹æ®X[]çš„åæ ‡å»ºç«‹çº¿æ®µæ ‘ int ans = 0; for (int i = 0; i &lt; l.size(); i++) &#123; if (l[i].mark!=2) &#123; int id = lower_bound(X.begin(), X.end(), l[i].a.x) - X.begin(); int c = l[i].mark == 3 ? -1 : 1; edit_tree(1, id+1, c); &#125; else &#123; int id1 = lower_bound(X.begin(), X.end(), l[i].a.x) - X.begin(); int id2 = lower_bound(X.begin(), X.end(), l[i].b.x) - X.begin(); ans += query(1, id1+1, id2+1); &#125; &#125; printf("%d\n", ans); return 0;&#125; CGL_7_A:Intersectionæ±‚åœ†çš„åˆ‡çº¿ä¸ªæ•° ä»£ç å†…å®¹ 12345678910111213141516int yuan_yuan_xiangjiao(cirles a, cirles b) //è¯¢é—®åœ†å’Œåœ†çš„åˆ‡çº¿ä¸ªæ•°&#123; double l = changdu(b.o - a.o); if (bijiao(l, a.r + b.r) == 1) return 4; else if (bijiao(l, a.r + b.r) == 0) return 3; else &#123; if (bijiao(l + min(a.r, b.r), max(a.r, b.r)) == 1) return 2; else if (bijiao(l + min(a.r, b.r), max(a.r, b.r)) == 0) return 1; else return 0; &#125;&#125; CGL_7_D:Cross Points of a Circle and a Lineæ±‚åœ†å’Œç›´çº¿çš„äº¤ç‚¹.å»ºè®®é˜…è¯»â€æŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›2â€ ä»£ç å†…å®¹ 123456789101112pair&lt;point, point&gt; zhixian_yuan_jiaodian(Line l, cirles a) //æ±‚ç›´çº¿ä¸åœ†äº¤ç‚¹&#123; if (dayu_dengyu(a.r, zhixian_yuanxin_juli(l, a))) &#123; vec a_i = touying(l, a.o); double L = changdu(l.b - l.a); double lt = changdu(a.o - a_i); double lr = sqrt(a.r * a.r - lt * lt); vec p = (l.b - l.a) / L * lr + a_i; return make_pair(a_i - (l.b - l.a) / L * lr, a_i + (l.b - l.a) / L * lr); &#125; else return make_pair(0, 0);&#125; CGL_7_E:Cross Points of Circlesæ±‚ä¸¤ä¸ªåœ†äº¤ç‚¹å»ºè®®é˜…è¯»â€æŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›2â€ ä»£ç å†…å®¹ 1234567pair&lt;vec, vec&gt; yuan_yuan_jiaodian(cirles a, cirles b) //æ±‚åœ†å’Œåœ†çš„äº¤ç‚¹&#123; double l = changdu(a.o - b.o); double x = acos((a.r * a.r + l * l - b.r * b.r) / (2.0 * a.r * l)); double t = atan2((b.o - a.o).y, (b.o - a.o).x); return make_pair(a.o + vec(cos(t - x) * a.r, sin(t - x) * a.r), a.o + vec(cos(x + t) * a.r, sin(t + x) * a.r));&#125; CGL_7_F:Tangent to a Circleè¿‡ä¸€ä¸ªç‚¹åšåœ†çš„åˆ‡çº¿æ ¹æ®åŠå¾„å’Œåœ†å¿ƒåˆ°ç‚¹çš„è·ç¦»æ±‚å‡ºå¤¹è§’,æ—‹è½¬è§’åº¦,å¾—åˆ°äº¤ç‚¹ ä»£ç å†…å®¹ 123456789pair&lt;point, point&gt; guodian_yuan_qiedian(cirles a, point p) //è¿‡ä¸€ç‚¹åšåœ†çš„åˆ‡çº¿æ±‚åˆ‡ç‚¹&#123; double l = changdu(a.o - p); double t = asin(a.r / l); double lb = l * cos(t); vec x = a.o - p; x = x / l * lb; return make_pair(p + xiangliang_xuanzhuan(x, t), p + xiangliang_xuanzhuan(x, -t));&#125; CGL_7_G:Common Tangentæ±‚ä¸¤ä¸ªåœ†çš„å…¬åˆ‡çº¿æ ¹æ®åœ†å’Œåœ†çš„ä½ç½®è¿›è¡Œåˆ¤æ–­ ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041int yuanyuan_gongqiexian(cirles a, cirles b, point* u, point* v) //æ±‚åœ†å’Œåœ†å…¬åˆ‡çº¿ä»¥åŠåˆ‡çº¿ä¸ªæ•°&#123; int cnt = 0; if (a.r &lt; b.r) &#123; swap(a, b); swap(u, v); &#125; double l = changdu(a.o - b.o); double rdiff = a.r - b.r; double rsum = a.r + b.r; if (zhengfu(l - rdiff) &lt; 0) return 0; double base = atan2((b.o - a.o).y, (b.o - a.o).x); if (zhengfu(l) == 0) return -1; if (zhengfu(l - rdiff) == 0) &#123; u[cnt] = v[cnt] = a.Point(base); cnt++; return 1; &#125; double ang = acos((a.r - b.r) / l); u[cnt] = a.Point(base + ang); v[cnt] = b.Point(base + ang); cnt++; u[cnt] = a.Point(base - ang); v[cnt] = b.Point(base - ang); cnt++; if (zhengfu(l - rsum) == 0) &#123; u[cnt] = v[cnt] = a.Point(base); cnt++; &#125; else if (zhengfu(l - rsum) &gt; 0) &#123; double ang = acos((a.r + b.r) / l); u[cnt] = a.Point(base + ang); v[cnt] = b.Point(pi + base + ang); cnt++; u[cnt] = a.Point(base - ang); v[cnt] = b.Point(pi + base - ang); cnt++; &#125; return cnt;&#125; CGL_7_H:Intersection of a Circle and a Polygonæ±‚å¤šè¾¹å½¢å’Œåœ†ç›¸äº¤çš„é¢ç§¯å°†å¤šè¾¹å½¢çš„è¾¹çš„é¡¶ç‚¹ä¸åœ†å¿ƒè¿æ¥è¡Œæˆä¸‰è§’å½¢.é‚£ä¹ˆé¢ç§¯ä¾¿æ˜¯ä¸‰è§’å½¢åœ¨åœ†å†…çš„æœ‰å‘é¢ç§¯.å¯¹æ¯ä¸ªä¸‰è§’å½¢åœ¨åœ†å†…è¿›è¡Œåˆ¤æ–­æ¥è®¡ç®—. ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677point zhixian_zhixian_jiaodian(Line l1, Line l2) //ä¸¤ç›´çº¿äº¤ç‚¹&#123; double t = ((l1.a.x - l2.a.x) * (l2.a.y - l2.b.y) - (l1.a.y - l2.a.y) * (l2.a.x - l2.b.x)) / ((l1.a.x - l1.b.x) * (l2.a.y - l2.b.y) - (l1.a.y - l1.b.y) * (l2.a.x - l2.b.x)); return l1.a + (l1.b - l1.a) * t;&#125;point xianduan_duandian_dian(point p, Segment l) //çº¿æ®µè·ç¦»ç‚¹pæœ€è¿‘çš„ç«¯ç‚¹&#123; point t = p; t.x += l.a.y - l.b.y; t.y += l.b.x - l.a.x; if (chaji(l.a - p, t - p) * chaji(l.b - p, t - p) &gt; eps) return changdu(p - l.a) &lt; changdu(p - l.b) ? l.a : l.b; return zhixian_zhixian_jiaodian(Line(p, t), l);&#125;double distp(Line l) //é•¿åº¦çš„å¹³æ–¹&#123; return (l.a.x - l.b.x) * (l.a.x - l.b.x) + (l.a.y - l.b.y) * (l.a.y - l.b.y);&#125;double yuanxin_dian_sanjiao(Line l, cirles c) //æ±‚åœ†å¿ƒä¸ä¸¤ç‚¹æ‰€æˆä¸‰è§’å½¢æœ‰å‘é¢ç§¯&#123; double sign = 1.0; l.a = l.a - c.o; l.b = l.b - c.o; c.o = point(0.0, 0.0); if (fabs(chaji(l.a - c.o, l.b - c.o)) &lt; eps) return 0.0; if (distp(Line(l.a, c.o)) &gt; distp(Line(l.b, c.o))) &#123; swap(l.a, l.b); sign = -1.0; &#125; if (distp(Line(l.a, c.o)) &lt; c.r * c.r + eps) &#123; //aåœ¨åœ†å†… if (distp(Line(l.b, c.o)) &lt; c.r * c.r + eps) //bä¹Ÿåœ¨åœ†å†…,è¿”å›å‰ç§¯/2 return chaji(l.a - c.o, l.b - c.o) / 2.0 * sign; point p1, p2; pair&lt;point, point&gt; q = zhixian_yuan_jiaodian(l, c); //oaå’Œobä¸åœ†çš„äº¤ç‚¹ p1 = q.first; p2 = q.second; if (changdu(p1 - l.b) &gt; changdu(p2 - l.b)) swap(p1, p2); double ret1 = fabs(chaji(l.a - c.o, p1 - c.o)); double ret2 = acos((p1.x * l.b.x + p1.y * l.b.y) / changdu(p1) / changdu(l.b)) * c.r * c.r; double ret = (ret1 + ret2) / 2.0; if (chaji(l.a - c.o, l.b - c.o) &lt; eps &amp;&amp; sign &gt; 0.0 || chaji(l.a - c.o, l.b - c.o) &gt; eps &amp;&amp; sign &lt; 0.0) ret = -ret; return ret; &#125; point ins = xianduan_duandian_dian(c.o, l); if (distp(Line(c.o, ins)) &gt; c.r * c.r - eps) &#123; double ret = acos((l.a.x * l.b.x + l.a.y * l.b.y) / changdu(l.a) / changdu(l.b)) * c.r * c.r / 2.0; if (chaji(l.a - c.o, l.b - c.o) &lt; eps &amp;&amp; sign &gt; 0.0 || chaji(l.a - c.o, l.b - c.o) &gt; eps &amp;&amp; sign &lt; 0.0) ret = -ret; return ret; &#125; point p1, p2; pair&lt;point, point&gt; q = zhixian_yuan_jiaodian(l, c); //oaå’Œobä¸åœ†çš„äº¤ç‚¹ p1 = q.first; p2 = q.second; double cm = c.r / (changdu(c.o - l.a) - c.r); point m = point((c.o.x + cm * l.a.x) / (1 + cm), (c.o.y + cm * l.a.y) / (1 + cm)); double cn = c.r / (changdu(c.o - l.b) - c.r); point n = point((c.o.x + cn * l.b.x) / (1 + cn), (c.o.y + cn * l.b.y) / (1 + cn)); double ret1 = acos((m.x * n.x + m.y * n.y) / changdu(m) / changdu(n)) * c.r * c.r; double ret2 = acos((p1.x * p2.x + p1.y * p2.y) / changdu(p1) / changdu(p2)) * c.r * c.r - fabs(chaji(p1 - c.o, p2 - c.o)); double ret = (ret1 - ret2) / 2.0; if (chaji(l.a - c.o, l.b - c.o) &lt; eps &amp;&amp; sign &gt; 0.0 || chaji(l.a - c.o, l.b - c.o) &gt; eps &amp;&amp; sign &lt; 0.0) ret = -ret; return ret;&#125;double duobianxing_yuan_xiangjiao(cirles c, point p[], int n) //å¤šè¾¹å½¢ä¸åœ†ç›¸äº¤é¢ç§¯&#123; double sum = 0; for (int i = 0; i &lt; n; i++) sum += yuanxin_dian_sanjiao(Line(p[i], p[i + 1]), c); return sum;&#125; å…¶ä»–ç›¸å…³è¾›æ™®æ£®æ³•åˆ™è¯æ˜å¾…è¡¥ ä»£ç å†…å®¹ 1234567891011121314151617double fun(double x)//åŸç§¯åˆ†å‡½æ•°&#123; return x;&#125;double simpson(double l,double r) //è¾›æ™®æ£®æ³•åˆ™&#123; double mid=(l+r)/2.0; return (fun(l)+fun(r)+4*fun(mid))*(r-l)/6.0;&#125;double solve(double l,double r,double ans) //è°ƒæ•´ç²¾åº¦æ±‚ç­”æ¡ˆ&#123; double mid=(l+r)/2.0; double ls=simpson(l,mid),rs=simpson(mid,r); if(fabs(ls+rs-ans)&lt;=15.0*eps) return ls+rs+(ls+rs-ans)/15.0; return solve(l,mid,ls)+solve(mid,r,rs);&#125; æœ€å°åœ†è¦†ç›–ä»£ç å†…å®¹ 1234567891011121314151617181920212223242526272829303132333435363738point zhixian_zhixian_jiaodian(Line l1, Line l2) //ä¸¤ç›´çº¿äº¤ç‚¹&#123; double t = ((l1.a.x - l2.a.x) * (l2.a.y - l2.b.y) - (l1.a.y - l2.a.y) * (l2.a.x - l2.b.x)) / ((l1.a.x - l1.b.x) * (l2.a.y - l2.b.y) - (l1.a.y - l1.b.y) * (l2.a.x - l2.b.x)); return l1.a + (l1.b - l1.a) * t;&#125;point sanjiaoxing_waixin(point a, point b, point c) //ä¸‰è§’å½¢å¤–å¿ƒ&#123; Line u, v; u.a.x = (a.x + b.x) / 2; u.a.y = (a.y + b.y) / 2; u.b.x = u.a.x - a.y + b.y; u.b.y = u.a.y + a.x - b.x; v.a.x = (a.x + c.x) / 2; v.a.y = (a.y + c.y) / 2; v.b.x = v.a.x - a.y + c.y; v.b.y = v.a.y + a.x - c.x; return zhixian_zhixian_jiaodian(u, v);&#125;cirles zuixiaoyuan_fugai(point p[], int n) //æœ€å°åœ†è¦†ç›–&#123; random_shuffle(p + 1, p + 1 + n); cirles c(p[1], 0.0); for (int i = 2; i &lt;= n; i++) if (zhengfu(changdu(c.o - p[i]) - c.r) &gt; 0) &#123; c = cirles(p[i], 0.0); for (int j = 1; j &lt; i; j++) if (zhengfu(changdu(c.o - p[j]) - c.r) &gt; 0) &#123; c.o = (p[i] + p[j]) / 2; c.r = changdu(c.o - p[i]); for (int k = 1; k &lt; j; k++) if (zhengfu(changdu(c.o - p[k]) - c.r) &gt; 0) &#123; c.o = sanjiaoxing_waixin(p[i], p[j], p[k]); c.r = changdu(c.o - p[i]); &#125; &#125; &#125; return c;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm2014-I.The Queenâ€™s Super-circular Patio]]></title>
    <url>%2F2019%2F08%2F13%2Facm2014-I%2F</url>
    <content type="text"><![CDATA[I: The Queenâ€™s Super-circular Patioé¢˜ç›®æè¿°The queen wishes to build a patio paved with of a circular center stone surrounded by circular rings of circular stones. All the stones in a ring will be the same size with the same number of stones in each ring. The stones in the innermost ring will be placed touching (tangent to) the adjacent stones in the ring and the central stone. The stones in the other rings will touch the two adjacent stones in the next inner ring and their neighbors in the same ring. The figures below depict a patio with one ring of three stones and a patio with $5$ rings of $11$ stones. The patio is to be surrounded by a fence that goes around the outermost stones and straight between them (the heavier line in the figures).The queen does not yet know how many stones there will be in each circle nor how many circles of stones there will be. To be prepared for whatever she decides, write a program to calculate the sizes of the stones in each circle and the length of the surrounding fence. The radius of the central stone is to be one queenly foot. è¾“å…¥The first line of input contains a single integer $P$, ($1 â‰¤ P â‰¤ 1000$), which is the number of data sets that follow. Each data set should be processed identically and independently.Each data set consists of a single line of input. It contains the data set number, $K$, the number, $N$ ($3 â‰¤ N â‰¤ 20$), of stsones in each circle and the number, $M$ ($1 â‰¤ M â‰¤ 15$), of circles of stones around the central stone. è¾“å‡ºFor each data set there is a single line of output. It contains the data set number, $K$, followed by a single space which is then followed by the radius (in queenly feet) of the stones in the outermost ring (to $3$ decimal places) which is followed by a single space which is then followed by the length (in queenly feet) of the fence (to $3$ decimal places). æ ·ä¾‹è¾“å…¥31 3 12 7 33 11 5 æ ·ä¾‹è¾“å‡º1 6.464 79.4002 3.834 77.7603 2.916 82.481 è§£æ$t$ç»„æ•°æ®,ç¬¬ä¸€ä¸ªæ˜¯ç¼–å·,ç¬¬äºŒä¸ªæ˜¯ä¸€å±‚æœ‰å‡ ä¸ª,ç¬¬ä¸‰ä¸ªæ˜¯æœ‰å‡ å±‚.é—®ä½ æœ€å¤–å±‚çš„åœ†çš„åŠå¾„$r$å’Œå›´æ é•¿åº¦$l$.é¦–å…ˆ,æœ€å¤–å›´çš„å›´æ é•¿åº¦$l$å¿…å®šæ˜¯æœ€å¤–å›´$1$ä¸ªåœ†çš„å‘¨é•¿$+n\times 2\times$æœ€å¤–å›´åœ†çš„åŠå¾„$r$.é‚£ä¹ˆé—®é¢˜å˜ä¸ºå¦‚ä½•æ±‚æœ€å¤–å›´åœ†çš„åŠå¾„$r$.å¯¹äºç¬¬ä¸€ä¸ªå›¾,å¾ˆæ˜æ˜¾,æœ€å¤–å±‚,å³ç¬¬ä¸€å±‚çš„åŠå¾„ä¸º$\frac{\sin\theta}{(1.0 - \sin\theta)}$,è¿™é‡Œ$\theta=\frac{\pi}{n}$å°±åƒè¿™æ ·,ç†è§£ä¸€ä¸‹.æˆ‘ä»¬æ”¹ä¸€ä¸‹å›¾,è®©ç¬¬äºŒä¸ªå›¾åªæœ‰ä¸¤å±‚é‚£ä¹ˆé—®é¢˜å˜ä¸ºå¦‚ä½•æ±‚$r_2$.æˆ‘ä»¬è¿æ¥ä¸¤çƒçš„åœ†å¿ƒ,å¤–åˆ‡åœ†å’Œå¤–åˆ‡åœ†çš„å¤–åˆ‡åœ† ç”±$r_1=R_1\times\sin\theta,r_2=R_2\times\sin\theta$æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªå…¬å¼:ä¸€ç³»åˆ—åŒ–ç®€å¾—åˆ° $$r_2=R_2*\sin\theta$$ ä¹‹åæ¯ä¸ª$R_i=f(i-1)$é€’æ¨æ±‚å¾—. ä»£ç å¦‚ä¸‹ 12345678910111213141516171819202122232425int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; int opt, n, k; cin &gt;&gt; opt &gt;&gt; n &gt;&gt; k; double alpha = pi / (double)n; double si=sin(alpha),ci=cos(alpha),ti=tan(alpha); double r1 = si / (1.0 - si); double R1=1.0+r1,R2,r2; for (int i = 2; i &lt;= k; i++) &#123; R2=R1*ci+r1*si+sqrt(r1*r1+2*r1*R1*ci*si); R2=R2/(ci*ci); r2=R2*si; R1=R2; r1=r2; &#125; double r=r1; double ans=2.0*r*(pi+(double)(n)); printf("%d %.3f %.3f\n", opt, r, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>è®¡ç®—å‡ ä½•</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡ç®—å‡ ä½•ç›¸å…³çŸ¥è¯†]]></title>
    <url>%2F2019%2F08%2F12%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[å‘é‡æ—‹è½¬å…¶ä¸€ç»™å®šç‚¹å‘é‡$\overrightarrow{A}$,ä»¤å…¶æŒ‰èµ·ç‚¹æ—‹è½¬ä¸€ä¸ªè§’åº¦$\alpha$é—®ç»ˆç‚¹çš„ä½ç½®.æˆ‘ä»¬å®šä¹‰é€†æ—¶é’ˆä¸ºæ­£å‘.å‡è®¾,å‘é‡$\overrightarrow{A}$ç»ˆç‚¹ä¸º$(x,y)$æ—‹è½¬åä¸º$(xâ€™,yâ€™)$.æˆ‘ä»¬å¯ä»¥çŸ¥é“,è¿™ä¸ªå‘é‡çš„èµ·ç‚¹ä¸º$(0,0)$,ç»ˆç‚¹åœ¨$r=\sqrt{x^2+y^2}$ä¸ºåŠå¾„å¾—åœ†ä¸Š.é‚£ä¹ˆ,æ ¹æ®$x=r\cdot cosÎ²,y=r\cdot sinÎ²$åˆ™æ—‹è½¬åçš„$xâ€™=r\cdot cos(Î±+Î²)$,$yâ€™=r\cdot sin(Î±+Î²)$æ‹†å¼€å:$xâ€™=r\cdot cosÎ±\cdot cosÎ²-r\cdot sinÎ±\cdot sinÎ²$$yâ€™=r\cdot sinÎ±\cdot cosÎ²+r\cdot cosÎ±\cdot sinÎ²$å†å°†$x$å’Œ$y$å›ä»£å¾—:$xâ€™=cosÎ±\cdot x-sinÎ±\cdot y$$yâ€™=sinÎ±\cdot x+cosÎ±\cdot y$]]></content>
      <categories>
        <category>çŸ¥è¯†ç‚¹</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‡¸åŒ…çš„å‡ ç§æ±‚æ³•]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[å‰ç½®çŸ¥è¯†å‡¸åŒ… ä¸ä¸¥è°¨çš„è¯æ¥è®²ï¼Œç»™å®šäºŒç»´å¹³é¢ä¸Šçš„ç‚¹é›†ï¼Œå‡¸åŒ…å°±æ˜¯å°†æœ€å¤–å±‚çš„ç‚¹è¿æ¥èµ·æ¥æ„æˆçš„å‡¸å¤šè¾¹å½¢ï¼Œå®ƒèƒ½åŒ…å«ç‚¹é›†ä¸­æ‰€æœ‰çš„ç‚¹ã€‚ åˆ—å¦‚ä¸‹å›¾:ç”¨çº¢è‰²çš„ç›´çº¿,å°†é»‘è‰²çš„ç‚¹åŒ…è£¹èµ·æ¥. å‘é‡æ—‹è½¬å®šä¹‰ä¸¤ä¸ªåŒä¸€èµ·ç‚¹çš„å‘é‡:åˆ†åˆ«ä¸ºå‘é‡$\overrightarrow{ab}$å’Œå‘é‡$\overrightarrow{ac}$å®šä¹‰å‘é‡æ—‹è½¬,$\overrightarrow{ab}$æ—‹è½¬ä¸º$\overrightarrow{ac}$ä¸ºå³æ—‹,å³é¡ºæ—¶é’ˆæ—‹è½¬.$\overrightarrow{ac}$æ—‹è½¬ä¸º$\overrightarrow{ab}$ä¸ºå·¦æ—‹,å³é€†æ—¶é’ˆæ—‹è½¬.å¦‚ä½•è®¡ç®—: åˆ¤æ–­å‘é‡$\overrightarrow{ab}.x*\overrightarrow{ac}.y-\overrightarrow{ab}.y*\overrightarrow{ac}.x$çš„å€¼. è‹¥ä¸ºæ­£,åˆ™ä¸º$\overrightarrow{ab}$å³æ—‹å˜ä¸º$\overrightarrow{ac}$. è‹¥ä¸ºè´Ÿ,åˆ™ä¸º$\overrightarrow{ab}$å·¦æ—‹å˜ä¸º$\overrightarrow{ac}$. è‹¥ä¸º$0$,åˆ™ä¸ºå…±çº¿. æ­£é¢˜å‰ç¯‡æˆ‘ä»¬çŸ¥é“,ä¸€ä¸ªå‡¸åŒ…,å®ƒè¦åŒ…å«æ‰€æœ‰ç‚¹é›†ä¸­çš„ç‚¹.é‚£ä¹ˆå¦‚å›¾:ä¸ºäº†ç¬¦åˆå‡¸åŒ…å®šä¹‰,åªæœ‰$1,2,3,4$å››ç‚¹æ—¶,æˆ‘ä»¬çš„å‡¸åŒ…å¦‚å›¾æ‰€ç¤º(åœ¨è¿™é‡Œ,æˆ‘ä»¬å‡è®¾æ‰€æœ‰çš„ç‚¹æŒ‰ç…§$x$ä»å°åˆ°å¤§ç»™å‡º)é‚£ä¹ˆ,å¯¹äºç¬¬$5$ä¸ªç‚¹,æˆ‘ä»¬åº”è¯¥æ€ä¹ˆå¤„ç†å‘¢? è¾¹$2\rightarrow4$åº”è¯¥æ–­å¼€,ç„¶åå°†$2\rightarrow5$è¿æ¥ å†å°†$3\rightarrow4$æ–­å¼€.ç„¶åå°†$3\rightarrow5$è¿æ¥å˜æˆè¿™æ ·:æˆ‘ä»¬å¯ä»¥ç®€å•æŠŠè¿™ä¸ªå‡¸åŒ…åˆ’åˆ†ä¸ºä¸ŠåŠéƒ¨åˆ†å’Œä¸‹åŠéƒ¨åˆ†. å¯¹äºä¸ŠåŠéƒ¨åˆ†çš„$1,2,4,5$ ä¸ºä»€ä¹ˆæ–­å¼€$2\rightarrow4$è€Œè¿æ¥$2\rightarrow5$? å› ä¸º$4$åœ¨$2\rightarrow5$çš„å†…ä¾§? è¿™æ˜¯ä¸€ä¸ªåŸå› ,ä½†æœ¬è´¨æ˜¯ å‘é‡$\overrightarrow{2\rightarrow4}$æ˜¯éœ€è¦å·¦æ—‹æ‰èƒ½æˆä¸º$\overrightarrow{2\rightarrow5}$ åŒç†å¯ä»¥å¾—åˆ°,å¯¹äº$3\rightarrow4$å˜$3\rightarrow5$ å‘é‡$\overrightarrow{3\rightarrow4}$æ˜¯éœ€è¦å³æ—‹æ‰èƒ½æˆä¸º$\overrightarrow{3\rightarrow5}$ ä¸­ç¯‡ç”±ä¸Šé¢å¾—åˆ°çš„è¿™æ¡æ€§è´¨.æˆ‘ä»¬èƒ½åšä»€ä¹ˆ? åœ¨ç¦»çº¿,æ‰€ç»™çš„ç‚¹é›†æ— åºæ—¶,æˆ‘ä»¬æœ‰äº†$O(n\log{n})$çš„ç®—æ³•. å½“æ‰€ç»™çš„ç‚¹é›†æ˜¯æœ‰åºæ—¶,æˆ‘ä»¬æœ‰$O(n)$çš„ç®—æ³•. åç¯‡æˆ‘ä»¬åˆ†ä¸ºä¸¤ç§ç±»å‹è¿›è¡Œè®¨è®º. æœ‰åºçš„ä¸”ç¬¦åˆç®€å•å¤šè¾¹å½¢çš„ç‚¹é›† ä»€ä¹ˆæ˜¯ç®€å•å¤šè¾¹å½¢? é¡¶ç‚¹ä¸é¡¶ç‚¹ä¸é‡åˆã€‚ é¡¶ç‚¹ä¸åœ¨è¾¹ä¸Šã€‚ è¾¹ä¸è¾¹ä¸ç›¸äº¤çš„å¤šè¾¹å½¢ã€‚ æœ‰åºæ˜¯ä»€ä¹ˆ? æŒ‰ç…§$X$,$Y$åæ ‡æ’åºçš„æœ‰åº æŒ‰ç…§é€†æ—¶é’ˆæˆ–é¡ºæ—¶é’ˆç»™å‡ºçš„æœ‰åº,å½“ç„¶ä¹Ÿé˜”ä»¥ç§°ä¹‹ä¸ºæè§’æ’åºçš„æœ‰åº. é¦–å…ˆå…ˆçœ‹ç¬¬ä¸€ç§æ’åº,æŒ‰ç…§é€†æ—¶é’ˆæˆ–é¡ºæ—¶é’ˆç»™å‡ºçš„æœ‰åº,(æè§’æ’åºçš„æœ‰åº). å½“ä»ä¸è®©$Graham$ç®—æ³• ç®—æ³•æ€è·¯: 1.æ ˆå$q$,æ ˆå°¾æŒ‡é’ˆ$tail$,åˆå§‹åŒ–åœ¨æ ˆä¸­åŠ å…¥æœ€å·¦ä¸‹è§’çš„ç‚¹,å’Œç¬¬äºŒä¸ªç‚¹ 2.å‡è®¾å³å°†åŠ å…¥çš„ç‚¹$c$ 3.åˆ¤æ–­å‘é‡$\overrightarrow{q_{tail-1}q_{tail}}$å’Œå‘é‡$\overrightarrow{q_{tail-1}c}$çš„æ—‹è½¬å…³ç³». 1).å¦‚æœæ˜¯$\overrightarrow{q_{tail-1}q_{tail}}$å³æ—‹å˜ä¸º$\overrightarrow{q_{tail-1}c}$,å°†æ ˆé¡¶å…ƒç´ $q_{tail}$å¼¹å‡º,è¿›è¡Œæ­¥éª¤$3$,ç›´åˆ°è¿›è¡Œæ­¥éª¤$2)$ä¸æˆç«‹æˆ–æ ˆå†…åªå‰©$2$ä¸ªå…ƒç´ . 2).å¦‚æœæ˜¯$\overrightarrow{q_{tail-1}q_{tail}}$å·¦æ—‹å˜ä¸º$\overrightarrow{q_{tail-1}c}$,å°†$c$å‹å…¥æ ˆ,å›åˆ°æ­¥éª¤$2$. å¦‚æœå‘ç°ä¸‰ç‚¹å…±çº¿çš„æƒ…å†µï¼Œç®—æ³•å¯ä»¥è€ƒè™‘å°†å…¶è§†ä¸ºå·¦è½¬æˆ–è€…å³è½¬ã€‚è¿™å–å†³äºç©¶ç«Ÿåªæ˜¯è¦æ±‚å‡¸åŒ…çš„è¾¹ç•Œï¼Œè¿˜æ˜¯è¦æ‰¾åˆ°åœ¨å‡¸åŒ…è¾¹ç•Œä¸Šæ‰€æœ‰çš„ç‚¹ã€‚ ç¤ºæ„å›¾: è¢«å¤§å®¶å¹çš„å¾ˆå‰å®³çš„$Melkman$ç®—æ³• æ´å¼•ä¸€ä¸‹$Melkman$åœ¨è®ºæ–‡ä¸­è¯´çš„: It is the purpose of this short article to show that a slightly modified version of their algorithm constructs, on-line, the convex hull of any simple polyline in $O(n)$ time. åœ¨è®ºæ–‡ä¸­,$Melkman$ä½¿ç”¨çš„æ˜¯:é¡ºæ—¶é’ˆ. å½“ç„¶,é€†æ—¶é’ˆä¹Ÿé˜”ä»¥. ç®—æ³•æ€è·¯: æ ¹æ®ç®€å•å¤šè¾¹å½¢çš„æ€§è´¨,æˆ‘ä»¬çŸ¥é“è¾¹å’Œè¾¹æ˜¯ä¸ç›¸äº¤çš„. 1.ç¡®ç«‹ä¸€æ¡è¾¹,ä½¿å…¶ä»–æ‰€æœ‰çš„ç‚¹éƒ½åœ¨è¿™æ¡è¾¹çš„ä¸€ä¾§ 2.åœ¨ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—çš„é˜Ÿå°¾æ”¾å…¥è¾¹çš„ä¸¤ç‚¹, 3.å†åœ¨é˜Ÿåˆ—å¤´å’Œå°¾éƒ½æ”¾å…¥ç¬¬ä¸‰ä¸ªç‚¹. 4.ä¾æ¬¡è¯»å…¥æ¯ä¸€ä¸ªç‚¹$p$,å¹¶ä¸$q_{tail},q_{tail-1},q_{head},q_{head+1}$æ¯”è¾ƒ. 1).å¦‚æœæ˜¯$\overrightarrow{q_{tail-1}q_{tail}}$å³æ—‹å˜ä¸º$\overrightarrow{q_{tail-1}p}$,å°†é˜Ÿå°¾å…ƒç´ $q_{tail}$å¼¹å‡º,è¿›è¡Œæ­¥éª¤$4$,ç›´åˆ°è¿›è¡Œæ­¥éª¤$1)$ä¸æˆç«‹æˆ–æ ˆå†…åªå‰©$3$ä¸ªå…ƒç´ . 2).å¦‚æœæ˜¯$\overrightarrow{q_{tail-1}q_{tail}}$å·¦æ—‹å˜ä¸º$\overrightarrow{q_{tail-1}c}$,å°†$c$å‹å…¥é˜Ÿå°¾,å›åˆ°æ­¥éª¤$3$. 3).å¦‚æœæ˜¯$\overrightarrow{q_{head+1}q_{head}}$å³æ—‹å˜ä¸º$\overrightarrow{q_{head+1}p}$,å°†é˜Ÿé¦–å…ƒç´ $q_{head}$å¼¹å‡º,è¿›è¡Œæ­¥éª¤$4$,ç›´åˆ°è¿›è¡Œæ­¥éª¤$3)$ä¸æˆç«‹æˆ–é˜Ÿå†…åªå‰©$3$ä¸ªå…ƒç´ . 4).å¦‚æœæ˜¯$\overrightarrow{q_{head+1}q_{head}}$å·¦æ—‹å˜ä¸º$\overrightarrow{q_{head+1}p}$,å°†$p$å‹å…¥é˜Ÿå°¾,å›åˆ°æ­¥éª¤$3$. æˆ‘ä»¬æ¥è¿›ä¸€æ­¥ç†è§£è¿™ä¸ªç®—æ³• çœ‹å›¾ å› ä¸ºæ‰€ç»™çš„ç‚¹æ˜¯æœ‰åºçš„,é‚£ä¹ˆç‚¹åªèƒ½è½åœ¨$I,II,III$è¿™ä¸‰ä¸ªä½ç½®. åœ¨è¿™é‡Œ,æˆ‘ä»¬çš„$q[head]$å’Œ$q[tail]$éƒ½æ˜¯$3$. åŠ å…¥ç‚¹$4$ä¾¿åˆ¤æ–­,åœ¨$I$,é‚£ä¹ˆ$head++$,ç„¶åå‹å…¥$4$ è‹¥åœ¨$III$,é‚£ä¹ˆ$tailâ€“$,å‹å…¥$4$. è‹¥åœ¨$II$,åˆ™$head++,tailâ€“$,å†åˆ†åˆ«å‹å…¥$4$. é‡å¤ä¸Šè¿°æ­¥éª¤,ç›´åˆ°æ‰€æœ‰ç‚¹éå†ç»“æŸ. å¯¹äºæ•°æ®æ˜¯æŒ‰$x$ä»å°åˆ°å¤§,$x$ç›¸ç­‰æ—¶$y$ä»å°åˆ°å¤§çš„æ’åˆ—çš„ç‚¹é›† å‡çº§ç‰ˆçš„$Graham$ç®—æ³•:$Andrew$ç®—æ³• å½“ä½¿ç”¨æè§’æ’åºæ—¶çš„ç²¾åº¦ä¸¢å¤±åˆæ˜¯ä¸€ä¸ªæŠ˜ç£¨äººçš„äº‹æƒ…. å¯¹äº$Graham$ç®—æ³•,å¯¹äºåˆ¤æ–­ä¸‰ç‚¹å…±çº¿æ—¶æœ‰å¯èƒ½å‡ºç°é”™è¯¯: ç®—æ³•æ€è·¯: æˆ‘ä»¬ç»“åˆ$Graham$æ¥çœ‹. åœ¨$Andrew$ç®—æ³•ä¸­,æ•°æ®è¦æŒ‰ç…§$x$åæ ‡æ¥æ’åˆ—. ä¹‹å,å…ˆä»ç‚¹$1$æ‰«åˆ°$n$,æŒ‰ç…§$Gramham$çš„å¤„ç†,å¾—åˆ°ä¸Šå‡¸åŒ… å†ä»$n$æ‰«åˆ°$1$,å¾—åˆ°ä¸‹å‡¸åŒ…,ç»“æŸ. æ— åºçš„ç‚¹é›†å…¶å®ç†è§£äº†ä¸Šé¢æœ‰åºçš„ç‚¹é›†å¦‚ä½•æ±‚è§£,æ— åºçš„ç‚¹é›†ä¹Ÿå°±éå¸¸æ˜äº†äº†.å¯¹äº:$Graham$ç®—æ³•å’Œ$Melkman$ç®—æ³•,æˆ‘ä»¬éœ€è¦æŒ‰ç…§æè§’æ’åº.å¯¹äº:$Andrew$ç®—æ³•,æˆ‘ä»¬è¦æŒ‰ç…§$x$ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—.ä¹Ÿå°±æ˜¯è¯´,ç›®å‰,æ®æˆ‘æ‰€çŸ¥,å¯¹äºæ— åºçš„ç‚¹é›†,æˆ‘ä»¬éƒ½éœ€è¦$O(n\log n)$çš„æ—¶é—´å¯»æ‰¾å‡¸åŒ…. ä»£ç $Graham$ç®—æ³•123456789101112131415161718192021222324252627282930313233double Cross(vec A, vec B)&#123; return A.x * B.y - A.y * B.x; // æ­£ä¸ºA-&gt;Bå·¦æ—‹&#125;double side(vec a, vec b, vec p) // ç¥–çˆ¶ç‚¹a,çˆ¶ç‚¹b,æ–°å¢å„¿å­ç‚¹p&#123; vec A = vec(b.x - a.x, b.y - a.y); // å‘é‡ab vec B = vec(p.x - a.x, p.y - a.y); // å‘é‡ap return Cross(A, B);&#125;void Graham(int&amp; tail)&#123; int zz = 0; for (int i = 0; i &lt; n; i++) if (p[i].y &lt; p[zz].y || (p[i].y == p[zz].y &amp;&amp; p[zz].x &gt; p[i].x)) zz = i; swap(p[0], p[zz]); for (int i = 1; i &lt; n; i++) &#123; p[i] = p[i] - p[0]; p[i].p = atan2(p[i].y, p[i].x); &#125; p[0].x = p[0].y = 0; sort(p + 1, p + n); q[0] = p[0]; tail = 0; for (int i = 1; i &lt; n; i++) &#123; while (tail&gt;0 &amp;&amp; side(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125;&#125; $Andrew$ç®—æ³•12345678910111213141516171819202122232425262728double Cross(vec A, vec B)&#123; return A.x * B.y - A.y * B.x; //æ­£ä¸ºA-&gt;Bå·¦æ—‹&#125;double side(vec a, vec b, vec p) //ç¥–çˆ¶ç‚¹a,çˆ¶ç‚¹b,æ–°å¢å„¿å­ç‚¹p&#123; vec A = vec(b.x - a.x, b.y - a.y, 0); //å‘é‡ab vec B = vec(p.x - a.x, p.y - a.y, 0); //å‘é‡ap return Cross(A, B);&#125;void Andrew(int&amp; tail)&#123; sort(p, p + n); tail = 0; q[0] = p[0]; for (int i = 1; i &lt; n; i++) &#123; while (tail &gt; 0 &amp;&amp; side(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125; int basic = tail; for (int i = n - 2; i &gt;= 0; i--) &#123; while (tail &gt; basic &amp;&amp; side(q[tail - 1], q[tail], p[i]) &lt; 0) tail--; q[++tail] = p[i]; &#125;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‰å‘æ˜Ÿ]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[æ¬¢è¿å„å¤§ä½¬ï¼Œå¤§ç‰›å¯¹æœ¬æ–‡æŒ‡æ­£ï¼Œä¹Ÿå¸Œæœ›æœ¬æ–‡èƒ½å¯¹å„ä½æœ‰æ‰€å¸®åŠ© ä¸€.åŸºæœ¬æ¦‚å¿µ&emsp;&emsp;å‰å‘æ˜Ÿæ˜¯ä»€ä¹ˆ??&emsp;&emsp;å‰å‘æ˜Ÿæ˜¯ä¸€ä¸ªè¾¹é›†æ•°ç»„.å•¥ç©æ„å•Š,æ‹½ä»€ä¹ˆä¸“ä¸šè¯æ±‡å•Š.ä¹Ÿå°±æ˜¯è¯´,ä¸é‚»æ¥çŸ©é˜µç›¸æ¯”,å‰å‘æ˜Ÿæ›´åƒæ˜¯ç”¨vectorå‚¨å­˜çš„é‚»æ¥é“¾è¡¨,æ˜¯å‚¨å­˜è¾¹çš„æ•°ç»„.&emsp;&emsp;è¿™ä¸ªæ•°ç»„å‚¨å­˜çš„æ˜¯å›¾é‡Œçš„æ¯ä¸€æ¡è¾¹.(ä¸‹é¢ä¸Šå›¾)&emsp;&emsp;ä¸‹é¢æ˜¯ä¸€ç»„å›¾çš„æ•°æ®&emsp;&emsp;$4$ä¸ªé¡¶ç‚¹,$6$æ¡è¾¹,èµ·ç‚¹,ç»ˆç‚¹,è¿™æ¡è¾¹çš„é•¿åº¦4 61 2 22 3 22 4 11 3 53 4 31 4 4 &emsp;&emsp;å‰å‘æ˜Ÿå‚¨å­˜ä»€ä¹ˆå‘¢,å­˜çš„æ˜¯ ç¬¬iæ¡è¾¹ èµ·ç‚¹ ç»ˆç‚¹ é•¿åº¦ 1 1 2 2 2 2 3 2 3 2 4 1 4 1 3 5 5 3 4 3 6 1 4 4 äºŒ.ä»£ç å®ç°&emsp;&emsp;çœ‹äº†ä¸€ä¸‹å­˜å‚¨æ–¹å¼æ˜¯ä¸æ˜¯æ„Ÿè§‰so~~easy,ç¡®å®å¦‚æ­¤.&emsp;&emsp;ä½†æ˜¯ä¾ç„¶æ”¹å˜ä¸äº†è¿™æ˜¯ä¸€ä¸ªå¾ˆä¼˜ç§€çš„æ•°æ®ç»“æ„(é›¾) 1.æ ¸å¿ƒä»£ç 123struct edge &#123; int star, end, cost;&#125;p[100000]; 2.ä¿å­˜å’Œè¾“å‡º123456789101112131415bool operator &lt;(edge a, edge b)&#123; return a.star &lt; b.star;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i].star &gt;&gt; p[i].end&gt;&gt;p[i].cost; sort(p, p + m); for (int i = 0; i &lt; m; i++) printf("%d %d %d\n",p[i].star,p[i].end,p[i].cost); return 0;&#125; &emsp;&emsp;å½“ä¸€ä¸ªå·¨å¤§çš„å›¾å´åªæœ‰å‡ ä¸ªè¾¹çš„æ—¶å€™,è¿™ç§ä¿å­˜æ–¹å¼çš„ä¼˜åŠ¿å°±å¤§å¤§çš„ä½“ç°äº†å‡ºæ¥.ä½†æ˜¯å‚¨å­˜åéœ€è¦æŒ‰ç…§èµ·ç‚¹æ’åº.æ‰èƒ½è¿›è¡Œæœç´¢æˆ–è€…æ±‚æœ€çŸ­è·¯.&emsp;&emsp;äºæ˜¯å¤æ‚åº¦å°±è¦åŠ ä¸Šäº†æ’åºçš„è€—æ—¶. ä¸‰.ä¼˜åŒ–â€“é“¾å¼å‰å‘æ˜Ÿ1.åŸºæœ¬æ¦‚å¿µ&emsp;&emsp;æ²¡é”™,å°±æ˜¯ä¼˜åŒ–,è®©æˆ‘ä»¬æ¥è€ƒè™‘å¦‚ä½•å»æ‰è¿™ä¸ªé¬¼ç•œçš„æ’åº$å‘¢^å‘¢$??&emsp;&emsp;åªéœ€è¦ç¨å¾®æ”¹å˜ä¸€ç‚¹ç‚¹å‚¨å­˜æ–¹å¼,å†åŠ å…¥ä¸€ä¸ªnextå°±å¯ä»¥äº†.äºæ˜¯å°±åƒæ˜¯ä»ä¸€ä¸ªç‚¹å‘å‡ºå»çš„é“¾å­ä¸€æ ·.æ‰€ä»¥ç§°ä¸ºé“¾å¼å‰å‘æ˜Ÿ(é›¾).&emsp;&emsp;æ€ä¹ˆå¼„å‘¢?&emsp;&emsp;$head[i]$ä¿å­˜çš„æ˜¯ç¬¬iä¸ªç‚¹çš„å§‹è¾¹çš„ä½ç½®,edgeä¿å­˜çš„æ˜¯ç¬¬iç‚¹çš„ä¸€æ¡è¾¹çš„ç»ˆç‚¹ä¸é•¿åº¦,ä»¥åŠç¬¬iä¸ªç‚¹çš„ä¸‹ä¸€æ¡è¾¹çš„ä½ç½®.åˆ†åˆ«ç”¨$end$,$cost$,$next$è¡¨ç¤º.&emsp;&emsp;äºæ˜¯å°±è¿™æ ·å­äº†&emsp;&emsp;è¿˜æ˜¯è¿™ä¸ªæ•°æ®,ä¼šå˜æˆä»€ä¹ˆæ ·å­å‘¢?? ç¬¬iæ¡è¾¹ èµ·ç‚¹ ç»ˆç‚¹ é•¿åº¦ 1 1 2 2 2 2 3 2 3 2 4 1 4 1 3 5 5 3 4 3 6 1 4 4 &emsp;&emsp;ä½¿$next=0$è¡¨ç¤ºæœ¨æœ‰å‡ºè¾¹ ä¸ºä»€ä¹ˆè¾¹åºå·æ˜¯å€’ç€çš„??(è¿™é‡Œå…ˆå–ä¸ªå…³å­,åé¢ä¼šè¯´) 2.ä»£ç å®ç°(è¾¹çš„å‚¨å­˜ä»¥åŠè¾“å‡º)(1).æ•°ç»„å®ç°123456789101112131415161718192021222324struct edge &#123; int end, cost,next;&#125;p[500001];int head[10001];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int s,e, c; cin &gt;&gt; s &gt;&gt; e &gt;&gt; c; p[i].end = e, p[i].cost = c; p[i].next=head[s]; head[s] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; int f = head[i]; while (f) &#123; printf("%d %d %d\n", i, p[f].end, p[f].cost); f = p[f].next; &#125; &#125; return 0;&#125; &emsp;&emsp;ä¸ºä»€ä¹ˆè¾¹çš„ä½ç½®æ˜¯å€’ç€çš„,æœ¨æª,å°±æ˜¯å› ä¸ºè¿™ä¸¤è¡Œ,ä¿å­˜æ–¹å¼ä¸ºä¸‹å›¾æ¼”ç¤º. 12p[i].next=head[s];head[s] = i; &emsp;&emsp;è®©$head[i]$å‚¨å­˜è¾“å…¥çš„è¾¹çš„ä½ç½®,å†è®©è¿™æ¡è¾¹çš„æŒ‡å‘å˜ä¸º$head[i]$å‚¨å­˜çš„ä½ç½®.é‚£ä¹ˆå°±æ„å‘³ç€,è¶Šæ™šè¾“å…¥çš„è¾¹,å®ƒè¶Šé è¿‘$head[i]$. (2).æŒ‡é’ˆå®ç°&emsp;&emsp;ä½œä¸ºä¸€ä¸ªå¿ äºæŒ‡é’ˆå†™æ•°æ®ç»“æ„çš„äºº,æ€ä¹ˆå¯èƒ½ä¸ç”¨æŒ‡é’ˆå†™ä¸€ä¸‹è¿™ä¸ªå®¶ä¼™å‘¢(é›¾).&emsp;&emsp;çœ‹æ‡‚ä¸Šé¢çš„,è¿™ä¸ªåº”è¯¥æ²¡ä»€ä¹ˆé—®é¢˜å§(é€ƒ) 1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct edge* nd;struct edge &#123; int end, cost; nd next;&#125;;nd head[10001];void close(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; nd p = head[i]; while (p != NULL) &#123; nd f = p-&gt;next; delete(p); //free(p); p = f; &#125; &#125;&#125; int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; memset(head, NULL, sizeof(head)); for (int i = 1; i &lt;= m; i++) &#123; int s, e, c; cin &gt;&gt; s &gt;&gt; e &gt;&gt; c; nd p = new(edge); //nd p=(nd) malloc(sizeof(edge)); p-&gt;end = e, p-&gt;cost = c; p-&gt;next = head[s]; head[s] = p; &#125; for (int i = 1; i &lt;= n; i++) &#123; nd f = head[i]; while (f!=NULL) &#123; printf("%d %d %d\n", i, f-&gt;end, f-&gt;cost); f = f-&gt;next; &#125; &#125; close(n); return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å›¾è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çº¿æ€§åŸº]]></title>
    <url>%2F2019%2F08%2F09%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[å®šä¹‰å³ä½¿çº¿æ€§ä»£æ•°è¯¾ç»“æŸ,ä¾ç„¶é€ƒä¸è¿‡çº¿æ€§ä»£æ•°çº¿æ€§åŸº,ç±»ä¼¼äºçº¿ä»£é‡Œé¢çš„çŸ©é˜µæ±‚æœ€å¤§çº¿æ€§æ— å…³ç»„.çœ‹ä¸€ä¸‹å¤§ä½¬çš„è¯´æ³•:é”µé”µ,ä¼ é€é—¨%%%% é¦–å…ˆæ¥çœ‹ä¸€ä¸ªé—®é¢˜ï¼š ç»™å‡ºNä¸ªæ•°,è¦ä»ä¸­é€‰å‡ºä¸€ä¸ªæœ€å¤§çš„å­é›†,ä½¿å¾—å­é›†ä¸­çš„ä»»æ„ä¸ªå…ƒç´ å¼‚æˆ–å€¼ä¸ä¸º0.è¿™ä¸ªå’Œæå¤§çº¿æ€§æ— å…³ç»„æœ‰äº›ç±»ä¼¼ã€‚å¼‚æˆ–å¯ä»¥çœ‹å‡ºæ˜¯æ¨¡2åŸŸä¸‹çš„åŠ æ³•è¿ç®—,å¦‚æœæŠŠä¸€ä¸ªæ•°è½¬åŒ–ä¸ºäºŒè¿›åˆ¶,å¯¹åº”æˆä¸€ä¸ªç”±01æ„æˆçš„å‘é‡,æ‰€æœ‰è¿™äº›å‘é‡å°±æ„æˆäº†ä¸€ä¸ªçº¿æ€§ç©ºé—´ã€‚ åŸé—®é¢˜å°±è½¬åŒ–ä¸ºæ±‚è¿™ä¸ªå‘é‡ç»„çš„æå¤§çº¿æ€§æ— å…³ç»„,æŠŠè¿™æ ·ä¸€ä¸ªæå¤§çº¿æ€§æ— å…³ç»„æˆä¸ºçº¿æ€§åŸºã€‚å¯ä»¥ç”¨$O(60*60*n)$çš„é«˜æ–¯æ¶ˆå…ƒæ¥è§£å†³ã€‚ ä½†æ˜¯è¿˜æœ‰æ›´åŠ å¿«é€Ÿçš„æ„é€ çº¿æ€§åŸºçš„æ–¹æ³•ï¼š å¤æ‚åº¦æ˜¯$O(60*n)$ æ€æƒ³&emsp;&emsp;å¯ä»¥è¿™ä¹ˆçœ‹,æˆ‘ä»¬æœ‰nå¤šä¸ªæ•°.è¿™äº›æ•°xç›¸äº’xor(å¼‚æˆ–)å¾—åˆ°çš„ä¸€äº›æ•°y,æˆ‘ä»¬ç§°yæ˜¯ä»–ä»¬xçš„å€¼åŸŸ.ä½†æ˜¯nå¤šä¸ªæ•°å¯èƒ½éƒ½å¤ªå¤§,ä¸å¥½ç»´æŠ¤æˆ–è€…å‚¨å­˜.äºæ˜¯æˆ‘ä»¬æƒ³ç”¨å°½é‡å°çš„æ•°,å‡ä½¿æœ‰kä¸ªæ¯”è¾ƒå°çš„æ•°,ç›¸äº’xoråŒæ ·èƒ½æ±‚å‡ºå€¼åŸŸy.è€Œè¿™äº›kä¸ªæ•°,æˆ‘ä»¬å°±ç§°ä¹‹ä¸ºçº¿æ€§åŸº.åˆæœ‰xoræ˜¯åœ¨(0,1)ä¸ºåŸºåº•çš„ç©ºé—´é‡Œçš„è¿ç®—.æ‰€ä»¥æˆ‘ä»¬è¦æŠŠnå¤šä¸ªæ•°,è§£æˆäºŒè¿›åˆ¶.ä¸¾ä¸ªæ —å­:æˆ‘ä»¬æœ‰é›†åˆ{x}={2,9,10,17}ä»–ä»¬ç›¸äº’å¼‚æˆ–å¯ä»¥å¾—åˆ°å€¼åŸŸ{y}.ä½†æ˜¯è¿™4ä¸ªæ•°,å¤ªå¤§äº†å¤¸å¼ ä¸€ä¸‹.æˆ‘ä»¬å°±è¦æƒ³åŠæ³•ç¼©å°xå¾—åˆ°é›†åˆ{k}.äºæ˜¯,æˆ‘ä»¬æŠŠè¿™å››ä¸ªæ•°å†™æˆçŸ©é˜µ,å°±æˆäº†çŸ©é˜µA..æˆ‘ä»¬è€ƒè™‘æŠŠè¿™ä¸ªå˜æˆä¸Šä¸‰è§’å½¢,é‚£ä¹ˆå¯ä»¥r3-r2+r4,ç„¶år3å’Œr4äº’æ¢.å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªè¡Œé˜¶æ¢¯å‹çš„çŸ©é˜µ.äºæ˜¯é›†åˆ{x}-&gt;{k}={1,2,10,17}.å—¯,æ²¡é”™,{k}å°±æ˜¯æˆ‘ä»¬è¦æ±‚å¾—çš„çº¿æ€§åŸº.å½“ç„¶,æˆ‘ä»¬ä¹Ÿå¯ä»¥å¤„ç†æ‰10,ä¿ç•™9å¦‚æœè®¡ç®—ä¸€ä¸‹çš„è¯,ä¼šå‘ç°,å¾—åˆ°çš„å€¼åŸŸ{y}æ˜¯ç›¸åŒçš„.äºæ˜¯,æˆ‘ä»¬å°±å¯ä»¥ç§°{k}ä¸ºçº¿æ€§åŸº. æ±‚è§£çº¿æ€§ç­›ç”±å›¾3,å¾ˆæ˜æ˜¾æˆ‘ä»¬çŸ¥é“äº†ä¸€ä¸ªæ±‚çº¿æ€§åŸºçš„æ–¹æ³•,æ˜¯é«˜æ–¯æ¶ˆå…ƒ.ä½†æ˜¯å¤ªéº»çƒ¦,ç¹ç,è€—æ—¶.å¸¸ç”¨çš„æ˜¯å¦ä¸€ç§.ä¸€å¥è¯ä»‹ç»å°±æ˜¯: å°†xè½¬æ¢ä¸ºäºŒè¿›åˆ¶,ä»é«˜ä½å‘ä½ä½æ‰«,å¦‚æœç¬¬ä¸€ä¸ª1æ˜¯ç¬¬pä½,å¦‚æœ$k_p=0$,å°±ä»¤$k_p=x$;å¦‚æœ$k_p!=0$,å°±ä»¤$x$XOR$k_p$å,é‡å¤ä¸Šè¿°é˜¶æ®µ. 12345678for(int i = Bit ; i &gt;= 0 ; i-- ) //Bitæ˜¯äºŒè¿›åˆ¶çš„ä½æ•°,å¸¸è§é¢˜ç›®å¤§å¤šä¸º62. if( 1 &lt;&lt; i &amp; Num ) if( !Base[i] ) &#123; Base[i] = Num ; break ; &#125; else Num ^= Base[i] ; å¸¸ç”¨æ“ä½œä¸€.æŸ¥è¯¢æœ€å€¼è´ªå¿ƒ,ä»é«˜ä½å‘ä½ä½è´ªå¿ƒ,å¯çŸ¥,ä»é«˜åˆ°åº•,åé¢çš„æ— æ³•æ”¹å˜é«˜ä½,åªè¦é«˜ä½å˜ä¸ºæœ€å¤§çš„å³å¯ 12for (int i = 62; i &gt;= 0; i--) ans = max(ans, ans^p[i]); äºŒ.æŸ¥è¯¢æœ€å°å€¼è´ªå¿ƒ,ä»é«˜ä½å‘ä½ä½è´ªå¿ƒ,å¯çŸ¥,ä»é«˜åˆ°åº•,åé¢çš„æ— æ³•æ”¹å˜é«˜ä½,åªè¦é«˜ä½å˜ä¸ºæœ€å°çš„å³å¯ 12for (int i = 62; i &gt;= 0; i--) ans = min(ans, ans^p[i]); å¸¸è§é¢˜ç›®ä¸€.P3812 ã€æ¨¡æ¿ã€‘çº¿æ€§åŸºè¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜ã€‚ é¢˜ç›®æè¿°ç»™å®šnä¸ªæ•´æ•°ï¼ˆæ•°å­—å¯èƒ½é‡å¤ï¼‰ï¼Œæ±‚åœ¨è¿™äº›æ•°ä¸­é€‰å–ä»»æ„ä¸ªï¼Œä½¿å¾—ä»–ä»¬çš„å¼‚æˆ–å’Œæœ€å¤§ã€‚ è¾“å…¥è¾“å‡ºæ ¼å¼è¾“å…¥æ ¼å¼:ç¬¬ä¸€è¡Œä¸€ä¸ªæ•°nï¼Œè¡¨ç¤ºå…ƒç´ ä¸ªæ•°æ¥ä¸‹æ¥ä¸€è¡Œnä¸ªæ•°è¾“å‡ºæ ¼å¼ï¼šä»…ä¸€è¡Œï¼Œè¡¨ç¤ºç­”æ¡ˆã€‚ è¾“å…¥è¾“å‡ºæ ·ä¾‹è¾“å…¥æ ·ä¾‹#1:21 1è¾“å‡ºæ ·ä¾‹#1:1 è¯´æ˜$1â‰¤nâ‰¤50,0â‰¤S_iâ‰¤2^{50}$ è§£ææ¨¡æ¿é¢˜ç›® 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std; typedef long long ll;const int maxn = 1e5 + 10;ll a[maxn], p[maxn], dp[maxn];int main()&#123; int n; ll ans=0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt;n ; i++) for (int j = 62; j &gt;= 0; j--) if (1ll &lt;&lt; j &amp; a[i]) if (!p[j]) &#123; p[j] = a[i]; break; &#125; else a[i] ^= p[j]; for (int i = 62; i &gt;= 0; i--) ans = max(ans, ans^p[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; äºŒ.å°aä¸æ˜Ÿé™…æ¢ç´¢é“¾æ¥ï¼šhttps://ac.nowcoder.com/acm/contest/317/C æ¥æºï¼šç‰›å®¢ç½‘é¢˜ç›®æè¿°&emsp;&emsp;å°aæ­£åœ¨ç©ä¸€æ¬¾æ˜Ÿé™…æ¢ç´¢æ¸¸æˆï¼Œå°aéœ€è¦é©¾é©¶ç€é£èˆ¹ä»1å·æ˜Ÿçƒå‡ºå‘å‰å¾€nå·æ˜Ÿçƒã€‚å…¶ä¸­æ¯ä¸ªæ˜Ÿçƒæœ‰ä¸€ä¸ªèƒ½é‡æŒ‡æ•°pã€‚æ˜Ÿçƒièƒ½åˆ°è¾¾æ˜Ÿçƒjå½“ä¸”ä»…å½“$p_i&gt;p_j$ã€‚&emsp;&emsp;åŒæ—¶å°açš„é£èˆ¹è¿˜æœ‰ä¸€ä¸ªè€ä¹…åº¦tï¼Œåˆå§‹æ—¶ä¸º1å·ç‚¹çš„èƒ½é‡æŒ‡æ•°ï¼Œè‹¥å°aå‰å¾€æ˜Ÿçƒjï¼Œé‚£ä¹ˆé£èˆ¹çš„è€ä¹…åº¦ä¼šå˜ä¸º$t$âŠ•$p_j$(å³$t$å¼‚æˆ–$p_j$ï¼Œå…³äºå…¶å®šä¹‰è¯·è‡ªè¡Œç™¾åº¦)&emsp;&emsp;å°aæƒ³çŸ¥é“åˆ°è¾¾nå·æ˜Ÿçƒæ—¶è€ä¹…åº¦æœ€å¤§ä¸ºå¤šå°‘.æ³¨æ„ï¼šå¯¹äºæ¯ä¸ªä½ç½®æ¥è¯´ï¼Œä»å®ƒå‡ºå‘å¯ä»¥åˆ°è¾¾çš„ä½ç½®ä»…ä¸ä¸¤è€…çš„pæœ‰å…³ï¼Œä¸ä¸‹æ ‡æ— å…³ è¾“å…¥æè¿°:&emsp;&emsp;ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºæ˜Ÿçƒæ•°&emsp;&emsp;æ¥ä¸‹æ¥ä¸€è¡Œæœ‰nä¸ªæ•´æ•°ï¼Œç¬¬iä¸ªæ•´æ•°è¡¨ç¤ºpi è¾“å‡ºæè¿°:&emsp;&emsp;ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºåˆ°è¾¾nå·æ˜Ÿçƒæ—¶æœ€å¤§çš„è€ä¹…åº¦&emsp;&emsp;è‹¥ä¸èƒ½åˆ°è¾¾nå·æ˜Ÿçƒæˆ–åˆ°è¾¾æ—¶çš„æœ€å¤§è€ä¹…åº¦ä¸º0åˆ™è¾“å‡ºâˆ’1 ç¤ºä¾‹è¾“å…¥3457 456 23è¾“å‡º478è¯´æ˜&emsp;&emsp;å°aæœ‰ä¸¤ç§æ–¹æ³•åˆ°è¾¾3å·æ˜Ÿçƒ&emsp;&emsp;ç¬¬ä¸€ç§ï¼š1â†’2â†’3ï¼Œæœ€ç»ˆè€ä¹…åº¦ä¸º457âŠ•456âŠ•23=22&emsp;&emsp;ç¬¬äºŒç§ï¼š1â†’3ï¼Œæœ€ç»ˆè€ä¹…åº¦ä¸º457âŠ•23=478è¾“å…¥42 4 4 2è¾“å‡º-1è¾“å…¥5234 233 123 2333 23è¾“å‡º253å¤‡æ³¨:1â©½n,âˆ€piâ©½3000 è§£æ&emsp;&emsp;æ±‚ä»$p_1$åˆ°$p_n$çš„å¼‚æˆ–å’Œæœ€å¤§å€¼,å¥—æ¿å­â€¦.ç„¶åæ³¨æ„çš„æ˜¯$p_i$åˆ°$p_j$çš„è¯éœ€è¦$p_i&gt;p_j$.æ‰€ä»¥ä¸ç¬¦åˆçš„æ•°ç›´æ¥æ‰”æ‰å°±å¯ä»¥äº†.&emsp;&emsp;æœ€åå†åˆ¤æ–­ä¸€ä¸‹$p_1$å’Œ$p_n$ä¹‹é—´çš„å¤§å°å…³ç³»å°±å¥½äº†. 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;const int maxn = 1e5 + 10;int a[maxn], p[maxn];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; p[i]; for (int i = 0; i &lt;n ; i++) for (int j = 12; j &gt;= 0; j--) if (1ll &lt;&lt; j &amp; p[i]&amp;&amp;p[0]&gt;p[i]&amp;&amp;p[i]&gt;p[n]) if (!a[j]) &#123; a[j] = p[i]; break; &#125; else p[i] ^= a[j]; int ans = p[0] ^ p[n - 1]; for (int i = 12; i &gt;= 0; i--) ans = max(ans, ans^a[i]); cout &lt;&lt; (p[0]&gt;p[n-1]?ans:-1) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>äºŒè¿›åˆ¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŒˆç‰™åˆ©ç®—æ³•]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å‚æ‹œå¤§ä½¬%%% äºŒåˆ†å›¾å®šä¹‰&emsp;&emsp;ä¸¥æ ¼çš„å®šä¹‰è¯·å‚åŠ ç™¾åº¦ç™¾ç§‘ä»€ä¹ˆçš„.è¿™é‡Œç®€å•è®²ä¸€ä¸‹æˆ‘çš„ç†è§£.å°±æ˜¯ç»™ä½ ä¸€ä¸ªå›¾,æœ‰nä¸ªç‚¹.ä½ å¯ä»¥æŒ‰ç…§è¾¹çš„å…³ç³»,å°†è¿™nä¸ªç‚¹åˆ†æˆä¸¤éƒ¨åˆ†,è€Œä¸”è¿™ä¸¤éƒ¨åˆ†ä¹‹é—´æœ‰è¾¹ç›¸è¿.ä½†æ˜¯æ¯ä¸€éƒ¨åˆ†é‡Œé¢çš„ç‚¹äº’ä¸ç›¸è¿.&emsp;&emsp;å¦‚å›¾1,å·¦å³ä¸¤éƒ¨åˆ†çš„ç‚¹éšæ„ç›¸è¿,ä½†æ˜¯æ¯éƒ¨åˆ†é‡Œçš„æ¯ä¸€ä¸ªç‚¹äº’ä¸ç›¸è¿. åŒ¹é…&emsp;&emsp;é¦–å…ˆæ˜¯æå¤§åŒ¹é…(Maximal Matching),æ˜¯æŒ‡åœ¨å½“å‰å·²å®Œæˆçš„åŒ¹é…ä¸‹,æ— æ³•å†é€šè¿‡å¢åŠ æœªå®ŒæˆåŒ¹é…çš„è¾¹çš„æ–¹å¼æ¥å¢åŠ åŒ¹é…çš„è¾¹æ•°ã€‚&emsp;&emsp;è€Œæœ€å¤§åŒ¹é…(maximum matching)æ˜¯æ‰€æœ‰æå¤§åŒ¹é…å½“ä¸­è¾¹æ•°æœ€å¤§çš„ä¸€ä¸ªåŒ¹é…ã€‚é€‰æ‹©è¿™æ ·çš„è¾¹æ•°æœ€å¤§çš„å­é›†ç§°ä¸ºå›¾çš„æœ€å¤§åŒ¹é…é—®é¢˜ã€‚&emsp;&emsp;å¦‚æœä¸€ä¸ªåŒ¹é…ä¸­ï¼Œå›¾ä¸­çš„æ¯ä¸ªé¡¶ç‚¹éƒ½å’Œå›¾ä¸­æŸæ¡è¾¹ç›¸å…³è”ï¼Œåˆ™ç§°æ­¤åŒ¹é…ä¸ºå®Œå…¨åŒ¹é…ï¼Œä¹Ÿç§°ä½œå®Œå¤‡åŒ¹é…ã€‚&emsp;&emsp;æ±‚äºŒåˆ†å›¾åŒ¹é…å¯ä»¥ç”¨æœ€å¤§æµ(Maximal Flow)æˆ–è€…åŒˆç‰™åˆ©ç®—æ³•(Hungarian Algorithm).&emsp;&emsp;å½“ç„¶æœ¬è’Ÿè’»è¿˜æ²¡æœ‰å­¦æœ€å¤§æµ åŒˆç‰™åˆ©ç®—æ³•&emsp;&emsp;æˆ‘ä»¬æ¥çœ‹å›¾äºŒ,å¯ä»¥çŸ¥é“äº†è¿™ä¸ªäºŒåˆ†å›¾å„ç‚¹ä¹‹é—´çš„è”ç³».é‚£ä¹ˆè¯¥ç®—æ³•å¦‚ä½•å®ç°æœ€å¤§åŒ¹é…å‘¢.&emsp;&emsp;æ ¹æ®å­—å…¸åº,æ˜¾ç„¶æ˜“è§,æˆ‘ä»¬å¯ä»¥çŸ¥é“,A-&gt;E.&emsp;&emsp;éšå,æˆ‘ä»¬çœ‹Bç‚¹,å®ƒè¦è¿E,ä½†æ˜¯Eè¢«å ç”¨äº†,æˆ‘ä»¬è¯¥æ€ä¹ˆåŠ?æˆ‘ä»¬æŠŠA-&gt;Eä¹‹é—´çš„è¾¹æš‚æ—¶å»æ‰,å˜æˆé»„è‰²,ç„¶åè®©B-&gt;Eé“¾æ¥,ä½†æ˜¯Aä¸èƒ½æ²¡æœ‰,äºæ˜¯è¿™é‡Œä»Aå†èµ°,Eä¸è¡Œ,ä½†æ˜¯æœ‰ä¸ªF.æ‰€ä»¥A-&gt;F.&emsp;&emsp;äºæ˜¯C-&gt;Gä¹ŸæŒ‰æ­¤æ³•åŠ ä¸Š,è½®åˆ°D,æˆ‘ä»¬å‘ç°Gå·²ç»è¢«è¿äº†.æ€ä¹ˆåŠ?å°†C-&gt;Gçš„è¾¹æš‚æ—¶å»æ‰.å†ä»Cèµ°,çœ‹æ˜¯å¦å¯ä»¥æ‰¾åˆ«çš„è¾¹.ä½†æ˜¯æˆ‘ä»¬å‘ç°,Cåªæœ‰åˆ°Gçš„ä¸€æ¡è¾¹.æ‰€ä»¥C-&gt;Gä¿ç•™,Dåªèƒ½å­¤ç«‹ä¸€äºº,æˆ‘ä»¬æ— èƒ½ä¸ºåŠ›. æ ¸å¿ƒä»£ç 12345678910bool find(int x)&#123; for (int i = 1; i &lt;= ny; i++) if (!used[i] &amp;&amp; m[x][i]) &#123; //used[]æŒ‡çš„æ˜¯,è¿™ä¸ªç‚¹æ˜¯å¦è¢«å¤„ç†è¿‡.m[][]æ˜¯æŒ‡ä¸¤è€…ä¹‹é—´æ˜¯å¦ç›¸è¿ used[i] = 1; if (!y[i] || find(y[i])) //å¦‚æœè¿™ä¸ªç‚¹æ²¡æœ‰è¢«é“¾æ¥,æˆ–è€…å¯ä»¥è°ƒæ•´ return y[i] = x; &#125; return 0;&#125; å®Œæ•´ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endif#define maxn 10000using namespace std;typedef long long ll;int m[maxn][maxn], used[maxn],y[maxn],nx, ny;bool find(int x)&#123; for (int i = 1; i &lt;= ny; i++) if (!used[i] &amp;&amp; m[x][i]) &#123; used[i] = 1; if (!y[i] || find(y[i])) return y[i] = x; &#125; return 0;&#125;int main()&#123; int ans = 0,d; cin &gt;&gt; nx &gt;&gt; ny&gt;&gt;d; for (int i = 0; i &lt; d; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; m[x][y] = 1; &#125; for (int i = 1; i &lt;= nx; i++) &#123; memset(used, 0, sizeof(used)); if (find(i)) ans++; &#125; for (int i = 1; i &lt;= ny; i++) cout &lt;&lt; y[i] &lt;&lt; ':' &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å­—å…¸æ ‘]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ä¸€ã€ä½•ä¸ºå­—å…¸æ ‘&emsp;&emsp;ç®€å•è®²ï¼Œå°±æ˜¯æŠŠä¸€ä¸²å­—ç¬¦ï¼Œå°†æ¯ä¸ªå­—ç¬¦å½“åšä¸€ä¸ªèŠ‚ç‚¹ï¼Œå»ºç«‹æˆä¸€æ£µæ ‘&emsp;&emsp;ä¸¾ä¸ªæ —å­ï¼Œæˆ‘ä»¬æœ‰ï¼ša,ahat,hat,hatword,hziee,wordã€‚è¿™ä¹ˆä¸€æ’®å•è¯ï¼Œå»ºæˆä»€ä¹ˆæ ·å­å‘¢ï¼Ÿ&emsp;&emsp;å¦‚ä¸‹å›¾ï¼š äºŒã€ä»£ç å®ç°ï¼ˆä¸€ï¼‰æ ‘æœ¬ä½“1234567typedef struct TreeNode* tn;struct TreeNode&#123; int cnt; tn next[54]; bool exist;&#125;;tn root; &emsp;&emsp;rootæ˜¯æ ¹ï¼ŒnextæŒ‡å‘ä¸‹ä¸€ä¸ªå­—æ¯ã€‚cntæŒ‡è¯¥å­—æ¯å‡ºç°çš„ä¸ªæ•°ï¼ŒexistæŒ‡åœ¨è¿™é‡Œæ˜¯å¦å¯ä»¥å½¢æˆä¸€ä¸ªå•è¯ã€‚&emsp;&emsp;åƒè¿™æ ·ï¼š ï¼ˆäºŒï¼‰å»ºæ ‘1234567891011121314151617181920212223tn New(tn p)&#123; p = new(TreeNode); memset(p-&gt;next, NULL, sizeof(p-&gt;next)); return p;&#125;void CreatTree(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) p-&gt;next[x]=New(p-&gt;next[x]); p=p-&gt;next[x]; p-&gt;cnt++; &#125; p-&gt;exist=1;&#125; &emsp;&emsp;ç®€å•ç²—æš´ï¼Œç›´æ¥æŠŠä¸€ä¸ªå­—ç¬¦ä¸²ä»å¤´åˆ°å°¾æ’¸è¿›å»å³å¯ï¼Œé€’å½’éƒ½ä¸ç”¨å†™ã€‚ ï¼ˆä¸‰ï¼‰æŸ¥æ‰¾123456789101112131415int Query(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) return 0; p=p-&gt;next[x]; &#125; return p-&gt;exist&amp;1; //return p-&gt;cnt;&#125; &emsp;&emsp;ä»ä¸Šå¾€ä¸‹æ‰¾ï¼Œå¦‚æœæ²¡æœ‰ç›´æ¥è¿”å›ï¼Œæœ‰ç›¸åº”å­—ç¬¦åˆ™ç»§ç»­ã€‚ç›´åˆ°æ‰¾åˆ°å­—ç¬¦ä¸²çš„æœ«å°¾ï¼Œè¿”å›å­—ç¬¦ä¸²æœ«å°¾çš„existï¼Œåˆ¤æ–­è¿™ä¸ªå•è¯æ˜¯å¦å‡ºç°è¿‡ã€‚ ï¼ˆå››ï¼‰åˆ é™¤æ ‘==å¿…å†™==1234567void close(tn p)&#123; for(int i=0;i&lt;54;i++) if(p-&gt;next[i]!=NULL&amp;&amp;p-&gt;next[i]-&gt;cnt) close(p-&gt;next[i]); delete(p);&#125; ä¸‰ã€ä¾‹é¢˜Hatâ€™s Words&emsp;&emsp;A hatâ€™s word is a word in the dictionary that is the concatenation of exactly two other words in the dictionary.&emsp;&emsp;You are to find all the hatâ€™s words in a dictionary. Input&emsp;&emsp;Standard input consists of a number of lowercase words, one per line, in alphabetical order. There will be no more than 50,000 words.&emsp;&emsp;Only one case. Output&emsp;&emsp;Your output should contain all the hatâ€™s words, one per line, in alphabetical order. Sample Inputaahathathatwordhzieeword Sample Outputahathatword è§£æ&emsp;&emsp;å­—ç¬¦ä¸²æ•°ç»„å¼€å¤ªå°æ˜¯ç½ª&emsp;&emsp;æ¯”è¾ƒå…¸å‹çš„é¢˜ï¼Œé—®ä½ èƒ½ä¸èƒ½æ‰¾åˆ°ä¸¤ä¸ªè¯ï¼Œç»„æˆä¸€ä¸ªè¯ã€‚å­—å…¸æ ‘å‚¨å­˜ï¼Œç„¶åæš´åŠ›æ‹†ä¸€éæ‰€æœ‰å­—ç¬¦ä¸²æ¥åˆ¤æ–­ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;typedef struct TreeNode* tn;struct TreeNode&#123; int cnt; tn next[54]; bool exist;&#125;;tn root;string s[50000];tn New(tn p)&#123; p=new(TreeNode); memset(p-&gt;next,NULL,sizeof(p-&gt;next)); return p;&#125;void CreatTree(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) p-&gt;next[x]=New(p-&gt;next[x]); p=p-&gt;next[x]; p-&gt;cnt++; &#125; p-&gt;exist=1;&#125;int Query(tn p,string s)&#123; int len=s.length(); for(int i=0;i&lt;len;i++)&#123; int x; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='z') x=s[i]-'a'; else x=s[i]-'A'+26; if(p-&gt;next[x]==NULL) return 0; p=p-&gt;next[x]; &#125; return p-&gt;exist&amp;1; //return p-&gt;cnt;&#125;void find(string s)&#123; int len=s.length(); for(int i=1;i&lt;len-1;i++) if(Query(root,s.substr(0,i))&amp;&amp;Query(root,s.substr(i,len-i)))&#123; cout&lt;&lt;s&lt;&lt;endl; break; &#125;&#125;void close(tn p)&#123; for(int i=0;i&lt;54;i++) if(p-&gt;next[i]!=NULL&amp;&amp;p-&gt;next[i]-&gt;cnt) close(p-&gt;next[i]); delete(p);&#125;int main()&#123; int tot=0; root=New(root); while(cin&gt;&gt;s[tot])&#123; CreatTree(root,s[tot]); tot++; &#125; for(int i=0;i&lt;tot;i++) find(s[i]); close(root);&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å­—å…¸æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å•è°ƒé˜Ÿåˆ—å’Œå•è°ƒæ ˆ]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[ä¸€.æ¦‚å¿µç›®çš„æ˜¯:ç»´æŒæ•°æ®ç»“æ„å†…çš„ä¸€ç»„çº¿æ€§æ•°æ®å¹¶ä¿è¯å…¶æŒ‰ç…§å•è°ƒé€’å‡æˆ–å•è°ƒé€’å¢.å•è°ƒé˜Ÿåˆ—/æ ˆçš„å®ç°å¾ˆç®€å•,åªç”¨ä¸€ä¸ªæ•°ç»„å³å¯,å¤šç”¨äºä¸å…¶ä»–ç®—æ³•ç­‰æ­é…,äº§ç”Ÿéå¸¸å¥½çš„æ•ˆæœ. äºŒ.å®ç°123456789101112int q[MAX],head,tail; //é˜Ÿåˆ—æˆ–è€…æ ˆ,å¤´,å°¾void built(int &amp;head,int &amp;tail,int *q) //åˆå§‹åŒ–&#123; memset(q,0,sizeof(q)); head=1,tail=0;&#125;void update(int x,int &amp;head,int &amp;tail,int *q) //æ’å…¥æ•°æ®&#123; while(tail&gt;=head&amp;&amp;x ? q[tail]) //ç»´æŠ¤é˜Ÿåˆ—/æ ˆçš„å•è°ƒæ€§ tail--; q[++tail] = x;&#125; ä¸‰.é¢˜ç›®å•è°ƒé˜Ÿåˆ—æ´›è°·P1886 æ»‘åŠ¨çª—å£https://www.luogu.org/problemnew/show/P1886ç°åœ¨æœ‰ä¸€å †æ•°å­—å…±$N$ä¸ªæ•°å­—ï¼ˆ$N&lt;=10^6$ï¼‰ï¼Œä»¥åŠä¸€ä¸ªå¤§å°ä¸º$k$çš„çª—å£ã€‚ç°åœ¨è¿™ä¸ªä»å·¦è¾¹å¼€å§‹å‘å³æ»‘åŠ¨ï¼Œæ¯æ¬¡æ»‘åŠ¨ä¸€ä¸ªå•ä½ï¼Œæ±‚å‡ºæ¯æ¬¡æ»‘åŠ¨åçª—å£ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚ä¾‹å¦‚ï¼šThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$.è¾“å…¥è¾“å‡ºæ ¼å¼è¾“å…¥æ ¼å¼ï¼šè¾“å…¥ä¸€å…±æœ‰ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä¸º$n$,$k$ã€‚ç¬¬äºŒè¡Œä¸º$n$ä¸ªæ•°($&lt;MAX$).è¾“å‡ºæ ¼å¼ï¼šè¾“å‡ºå…±ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å°å€¼ç¬¬äºŒè¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å¤§å€¼è¾“å…¥è¾“å‡ºæ ·ä¾‹è¾“å…¥æ ·ä¾‹#1ï¼š8 31 3 -1 -3 5 3 6 7è¾“å‡ºæ ·ä¾‹#1ï¼š-1 -3 -3 -3 3 33 3 5 5 6 7è¯´æ˜50%çš„æ•°æ®ï¼Œ$n&lt;=10^5$100%çš„æ•°æ®ï¼Œ$n&lt;=10^6$ è§£æç»™ä½ ä¸€ç»„æ•°æ®,å’Œä¸€ä¸ª$k$å¤§å°çš„æ¡†å­,æ¡†æ•°,é—®æ¡†é‡Œçš„æœ€å¤§å€¼å’Œæœ€å°å€¼å„æ˜¯å¤šå°‘.å¯ä»¥ç”¨dpåšæˆ‘ä»¬å¯ä»¥å‡è£…æœ‰ä¸€ä¸ªå•è°ƒé˜Ÿåˆ—æ¥è£…è¿™$k$ä¸ªæ•°.ç„¶åå¦‚æœä¿è¯è¿™ä¸ªé˜Ÿåˆ—æ˜¯å•å¢çš„è¯,é‚£ä¹ˆé˜Ÿé¦–è¿™ä¸ªæ•°åœ¨è¿™$k$ä¸ªæ•°é‡Œ,ä¸€å®šæ˜¯æœ€å°çš„.åŒç†å¯ä»¥å¾—åˆ°æœ€å¤§çš„æ•°. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAXN = 1e6 + 1;using namespace std;int n, a[MAXN], q[MAXN], p[MAXN], MAX[MAXN], MIN[MAXN];int read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x*f;&#125;int maxx(int n, int k)&#123; int head = 1, tail = 0, tot = 0; //åˆå§‹åŒ–é˜Ÿåˆ— for (int i = 1; i &lt;= n; i++) &#123; while (tail &gt;= head &amp;&amp; a[i] &gt; q[tail]) //ç»´æŒé˜Ÿåˆ—å•è°ƒæ€§ tail--; q[++tail] = a[i]; //å…¥é˜Ÿ p[tail] = i; //åŒæ—¶å­˜ä¸‹æ•°çš„ä¸‹æ ‡ if (p[head] &lt;= i-k) //ä¿è¯é˜Ÿé‡Œçš„æ•°æ˜¯æœ€æ–°çš„ head++; if(i&gt;=k) //åœ¨æ»¡è¶³å¾€æ¡†é‡Œæ‰”è¿›kä¸ªæ•°å,å†å–æœ€å€¼ MAX[++tot] = q[head]; &#125; return tot;&#125;int minn(int n, int k)&#123; int head = 1, tail = 0, ans = 0; for (int i = 1; i &lt;= n; i++) &#123; while (tail &gt;= head&amp;&amp;a[i] &lt; q[tail]) tail--; q[++tail] = a[i]; p[tail] = i; if (p[head] &lt;= i - k) head++; if(i&gt;=k) MIN[++ans] = q[head]; &#125; return ans;&#125;int main()&#123; int n = read(), k = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); int tot = maxx(n, k); int ans = minn(n, k); for (int i = 1; i &lt;= ans; i++) cout &lt;&lt; MIN[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for (int i = 1; i &lt;= tot; i++) cout &lt;&lt; MAX[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; return 0;&#125; å•è°ƒæ ˆ[GXOI/GZOI2019]ä¸æˆ–å’Œhttps://www.luogu.org/problemnew/show/P5300é¢˜ç›®æè¿°Freda å­¦ä¹ äº†ä½è¿ç®—å’ŒçŸ©é˜µä»¥åï¼Œå†³å®šå¯¹è¿™ç§ç®€æ´è€Œä¼˜ç¾çš„è¿ç®—ï¼Œä»¥åŠè•´å«æ·±é‚ƒç©ºé—´çš„ç»“æ„è¿›è¡Œæ›´åŠ æ·±å…¥çš„ç ”ç©¶ã€‚å¯¹äºä¸€ä¸ªç”±éè´Ÿæ•´æ•°æ„æˆçš„çŸ©é˜µï¼Œå¥¹å®šä¹‰çŸ©é˜µçš„AND å€¼ä¸ºçŸ©é˜µä¸­æ‰€æœ‰æ•°äºŒè¿›åˆ¶AND(&amp;) çš„è¿ç®—ç»“æœï¼›å®šä¹‰çŸ©é˜µçš„OR å€¼ä¸ºçŸ©é˜µä¸­æ‰€æœ‰æ•°äºŒè¿›åˆ¶OR(|) çš„è¿ç®—ç»“æœã€‚ ç»™å®šä¸€ä¸ªNÃ—N çš„çŸ©é˜µï¼Œå¥¹å¸Œæœ›æ±‚å‡ºï¼š è¯¥çŸ©é˜µçš„æ‰€æœ‰å­çŸ©é˜µçš„ AND å€¼ä¹‹å’Œï¼ˆæ‰€æœ‰å­çŸ©é˜µ AND å€¼ç›¸åŠ çš„ç»“æœï¼‰ã€‚è¯¥çŸ©é˜µçš„æ‰€æœ‰å­çŸ©é˜µçš„OR å€¼ä¹‹å’Œï¼ˆæ‰€æœ‰å­çŸ©é˜µ OR å€¼ç›¸åŠ çš„ç»“æœï¼‰ã€‚æ¥ä¸‹æ¥çš„å‰§æƒ…ä½ åº”è¯¥å·²ç»çŒœåˆ°â€”â€”Freda å¹¶ä¸æƒ³èŠ±è´¹æ—¶é—´è§£å†³å¦‚æ­¤ç®€å•çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™ä¸ªé—®é¢˜å°±äº¤ç»™ä½ äº†ã€‚ ç”±äºç­”æ¡ˆå¯èƒ½éå¸¸çš„å¤§ï¼Œä½ åªéœ€è¦è¾“å‡ºç­”æ¡ˆå¯¹ ($10^9 + 7$)$1000000007$å–æ¨¡åçš„ç»“æœã€‚ è¾“å…¥è¾“å‡ºæ ¼å¼è¾“å…¥æ ¼å¼ï¼šè¾“å…¥æ–‡ä»¶çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ­£æ•´æ•° $N$ï¼Œè¡¨ç¤ºçŸ©é˜µçš„å°ºå¯¸ã€‚ æ¥ä¸‹æ¥ $N$ è¡Œï¼Œæ¯è¡Œ $N$ ä¸ªè‡ªç„¶æ•°ï¼Œä»£è¡¨çŸ©é˜µçš„ä¸€è¡Œã€‚ç›¸é‚»ä¸¤ä¸ªè‡ªç„¶æ•°ä¹‹é—´ç”±ä¸€ä¸ªæˆ–å¤šä¸ªç©ºæ ¼éš”å¼€ã€‚ è¾“å‡ºæ ¼å¼ï¼šè¾“å‡ºåªæœ‰ä¸€è¡Œï¼ŒåŒ…å«ä¸¤ä¸ªç”¨ç©ºæ ¼éš”å¼€çš„æ•´æ•°ï¼Œç¬¬ä¸€ä¸ªåº”ä¸ºæ‰€æœ‰å­çŸ©é˜µ AND å€¼ä¹‹å’Œé™¤ä»¥ $10^9+7$çš„ä½™æ•°ï¼Œç¬¬äºŒä¸ªåº”ä¸ºæ‰€æœ‰å­çŸ©é˜µ OR å€¼ä¹‹å’Œé™¤ä»¥ $10^9+7$çš„ä½™æ•°ã€‚ è¾“å…¥è¾“å‡ºæ ·ä¾‹è¾“å…¥æ ·ä¾‹#1ï¼š31 0 00 0 00 0 0è¾“å‡ºæ ·ä¾‹#1ï¼š1 9è¾“å…¥æ ·ä¾‹#2ï¼š31 2 34 5 67 8 9è¾“å‡ºæ ·ä¾‹#2ï¼š73 314è¯´æ˜æ ·ä¾‹1è§£é‡Šè¯¥ $3Ã—3$ çŸ©é˜µå…±æœ‰ $9$ä¸ª $1Ã—1$ å­çŸ©é˜µã€$6$ ä¸ª $1Ã—2$ å­çŸ©é˜µã€$6$ ä¸ª $2Ã—1$ å­çŸ©é˜µã€$4$ ä¸ª$2Ã—2$ å­çŸ©é˜µã€$3$ ä¸ª $1Ã—3$ å­çŸ©é˜µã€$3$ ä¸ª $3Ã—1$ å­çŸ©é˜µã€$2$ ä¸ª $2Ã—3$ å­çŸ©é˜µã€$2$ ä¸ª $3Ã—2$ å­çŸ©é˜µå’Œ $1$ ä¸ª $3Ã—3$ å­çŸ©é˜µã€‚åªæœ‰ä¸€ä¸ªå­çŸ©é˜µï¼ˆä»…ç”±ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„é‚£ä¸ªå…ƒç´ æ„æˆçš„ $1Ã—1$ çŸ©é˜µï¼‰AND å€¼ä¸º $1$ï¼Œå…¶ä½™å­çŸ©é˜µçš„AND å€¼å‡ä¸º $0$ï¼Œæ€»å’Œä¸º $1$ã€‚åŒ…å«ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—é‚£ä¸ªå…ƒç´ çš„å­çŸ©é˜µæœ‰ $9$ ä¸ªï¼Œå®ƒä»¬çš„ OR å€¼ä¸º $1$ï¼Œå…¶ä½™å­çŸ©é˜µçš„ OR å€¼ä¸º $0$ï¼Œæ€»å’Œä¸º $9$ã€‚æ•°æ®èŒƒå›´ æµ‹è¯•ç‚¹ç¼–å·$n$ çš„è§„æ¨¡çŸ©é˜µä¸­çš„è‡ªç„¶æ•° $10$$1â‰¤nâ‰¤1000$$â‰¤2^{31} - 1$ è§£æ&emsp;&emsp;1.å¯¹äºä¸¤ä¸ªæ•°a,bè¿›è¡Œä½è¿ç®—,æ¯ä¸€ä½çš„ä½è¿ç®—æ˜¯å•ç‹¬çš„.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä½å°†æ•´ä¸ªçŸ©é˜µåˆ†å±‚ä¸ºå¤šä¸ª0,1çŸ©é˜µ.æ¯ä¸€ä½çš„0,1çŸ©é˜µçš„ä½è¿ç®—å’ŒæŒ‰äºŒè¿›åˆ¶çš„æ–¹å¼åŠ èµ·æ¥,ä¾¿æ˜¯a,bçš„çŸ©é˜µä½è¿ç®—å’Œ.&emsp;&emsp;2.äºæ˜¯,é¢˜ç›®å˜æˆåªæœ‰0,1ä¸¤ä¸ªæ•°çš„é—®é¢˜.&emsp;&emsp;å¯¹äºä½è¿ç®—å’Œ,åªæœ‰å½“ä¸€ä¸ªå­çŸ©é˜µä¸­æ‰€æœ‰æ•°ä¸º1æ—¶,è¯¥å­çŸ©é˜µçš„&amp;å’Œä¸º1,å¦åˆ™ä¸º0,ä¹Ÿå°±æ˜¯è¯´,æˆ‘ä»¬æ±‚ä¸€ä¸ªçŸ©é˜µä¸­å­çŸ©é˜µçš„&amp;å’Œçš„å’Œ,åªéœ€è¦ç»Ÿè®¡å…±æœ‰å¤šå°‘ä¸ªå…¨æ˜¯1çš„çŸ©é˜µå³å¯.&emsp;&emsp;å½“ä¸€ä¸ªå­çŸ©é˜µä¸­çš„æ‰€æœ‰æ•°ä¸º0æ—¶,è¯¥å­çŸ©é˜µçš„|å’Œä¸º0.å½“æˆ‘ä»¬æ±‚ä¸€ä¸ªçŸ©é˜µä¸­å­çŸ©é˜µçš„|å’Œ,åªéœ€è¦åœ¨æ€»|å’Œä¸­å‡å»å…¨ä¸º0çš„çŸ©é˜µä¸ªæ•°å³å¯.&emsp;&emsp;3.äºæ˜¯é—®é¢˜å˜ä¸ºæ±‚ç¬¦åˆæ¡ä»¶çš„å­çŸ©é˜µçš„ä¸ªæ•°.&emsp;&emsp;å¼•å…¥ä¸€ä¸ªç»“è®º: åœ¨ä¸€ä¸ª NÃ—M çš„çŸ©é˜µä¸­ï¼Œä»¥(n,m)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µå…±æœ‰ NÃ—M ä¸ª &emsp;&emsp;4.æ‰€ä»¥ç­”æ¡ˆå°±å˜æˆäº†,ä»¥(n,m)ä¸ºå³ä¸‹è§’çš„ç¬¦åˆæ¡ä»¶çš„å­çŸ©é˜µæœ‰å¤šå°‘ä¸ª.&emsp;&emsp;é‚£ä¹ˆ,å¦‚ä½•å¾—åˆ°ä»¥(n,m)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µæœ€å¤§çš„ä¸ªæ•°å‘¢?&emsp;&emsp;æˆ‘ä»¬è½¬æ¢ä¸€ä¸‹æ€ç»´,é—®é¢˜ä¾¿å¯ä»¥å˜ä¸º:åœ¨i-thå¤„ä»¥é«˜ä¸ºh-içš„çŸ©é˜µå‘å·¦çš„æœ€å¤§æ‰©å±•é•¿åº¦ä¸ºå¤šå°‘.ä¹Ÿå°±æ˜¯å•è°ƒæ ˆ.&emsp;&emsp;äºæ˜¯é—®é¢˜å°±è§£å†³å•¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;set&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int mod = 1e9 + 7;ll ans1, ans2, n, sum;int a[1010][1010], mx[1010];bool b[1010][1010];struct vec &#123; int h, len;&#125;q[1000 + 10];ll f1(int f)&#123; memset(mx, 0, sizeof(mx)); ll res = 0; for (int i = 1; i &lt;= n; i++) &#123; ll num = 0, tail = 0, head = 1; for (int j = 1; j &lt;= n; j++) &#123; mx[j] = f^(!b[i][j])?mx[j]+1:0; int len = 1; while (tail &gt;= head &amp;&amp; q[tail].h &gt;= mx[j]) &#123; num -= q[tail].h*q[tail].len; len += q[tail].len; tail--; &#125; num += mx[j] * len; res = (res%mod + num % mod) % mod; tail++; q[tail].h = mx[j]; q[tail].len = len; &#125; &#125; return res;&#125;int main()&#123; scanf("%lld", &amp;n); sum = (n*(n + 1) / 2 * n*(n + 1) / 2) % mod; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf("%d", &amp;a[i][j]); for (int k = 0; k &lt;= 31; k++) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i][j] &amp; (1 &lt;&lt; k)) b[i][j] = 1; else b[i][j] = 0; ans1 = (ans1%mod + (1LL &lt;&lt; k) % mod*f1(1) % mod) % mod; ans2 = (ans2%mod + (1LL &lt;&lt; k) % mod*(sum - f1(0) + mod) % mod) % mod; &#125; printf("%lld %lld", ans1, ans2);&#125;` POJ3250 Bad Hair DayDescriptionSome of Farmer Johnâ€™s N cows (1 â‰¤ N â‰¤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cowsâ€™ heads.Each cow i has a specified height hi (1 â‰¤ $h_i$ â‰¤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow i can see the tops of the heads of cows in front of her (namely cows i+1, i+2, and so on), for as long as these cows are strictly shorter than cow i.Consider this example: = = = = - = Cows facing right --&gt; = = = = - = = = = = = = = = 1 2 3 4 5 6 Cow#1 can see the hairstyle of cows #2, 3, 4Cow#2 can see no cowâ€™s hairstyleCow#3 can see the hairstyle of cow #4Cow#4 can see no cowâ€™s hairstyleCow#5 can see the hairstyle of cow 6Cow#6 can see no cows at all!Let ci denote the number of cows whose hairstyle is visible from cow i; please compute the sum of c1 through cN.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5.InputLine 1: The number of cows, N.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i.Output Line 1: A single integer that is the sum of c1 through cN.Sample Input610374122Sample Output5SourceUSACO 2006 November Silver è§£æç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„æ ˆ,æ¯”taçŸ®çš„éƒ½èƒ½çœ‹åˆ°,è€Œè¿›å»çš„ç‰›é™¤äº†é˜Ÿå°¾çš„éƒ½ä¼šåŠ ä¸€,æ‰€ä»¥ç›´æ¥ans+=tail 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;const int INF = 0x3f3f3f3f;const int MAX = 80000 + 10;using namespace std;long long p[MAX];long long read()&#123; long long x = 0, f = 1; char c = getchar(); while (c&lt;'0'&amp;&amp;c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x;&#125;int main()&#123; int n = read(), head = 1, tail = 0; long long ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int x = read(); while (head &lt;= tail &amp;&amp; x &gt;= p[tail]) tail--; ans += tail; p[++tail] = x; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; POJ 2559 Largest Rectangle in a HistogramDescriptionA histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles: Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.InputThe input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1&lt;=n&lt;=100000. Then follow n integers h1,â€¦,hn, where 0&lt;=$h_i$&lt;=1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case.OutputFor each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.Sample Input7 2 1 4 5 1 3 34 1000 1000 1000 10000Sample Output84000HintHuge input, scanf is recommended.SourceUlm Local 2003 è§£æç§ä»¥ä¸ºä¸å¦‚è¯¥åšä¸»è®²å¾—å¥½:https://www.cnblogs.com/violet-acmer/p/9780638.html#commentform 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAX = 1e6 + 1;using namespace std;long long n, q[MAX], l[MAX], r[MAX], a[MAX];long long read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x;&#125;int main()&#123; while (n = read(), n) &#123; int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); while (tail &gt;= head&amp;&amp;a[i] &lt;= a[q[tail]]) //ç»´æŒå•è°ƒæ€§,æ³¨æ„ä¿å­˜çš„æ˜¯ä¸‹æ ‡ tail--; l[i] = tail &lt; head ? 1 : q[tail] + 1; //å¦‚æœå®ƒä¸æ˜¯æ ˆé¦–,æˆ‘ä»¬å°±è®¤ä¸ºå®ƒå·¦è¾¹æœ‰çŸ©å½¢ q[++tail] = i; &#125; head =1, tail = 0; for (int i = n; i &gt; 0; i--) &#123; while (tail &gt;= head&amp;&amp;a[i] &lt;= a[q[tail]]) tail--; r[i] = tail &lt; head ? n : q[tail] - 1; q[++tail] = i; &#125; long long res = 0; for (int i = 1; i &lt;= n; i++) res = max(res, a[i] * (r[i] - l[i] + 1)); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; POJ2796 Feel GoodDescriptionBill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent peopleâ€™s memories about some period of life.A new idea Bill has recently developed assigns a non-negative integer value to each day of human life.Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it. This schema reflects that good on average period can be greatly spoiled by one very bad day.Now Bill is planning to investigate his own life and find the period of his life that had the greatest value. Help him to do so.InputThe first line of the input contains n - the number of days of Billâ€™s life he is planning to investigate(1 &lt;= n &lt;= 100000). The rest of the file contains n integer numbers a1, a2, â€¦ an ranging from 0 to 106 - the emotional values of the days. Numbers are separated by spaces and/or line breaks.OutputPrint the greatest value of some period of Billâ€™s life in the first line. And on the second line print two numbers l and r such that the period from $l_{th}$ to $r_{th}$ day of Billâ€™s life(inclusive) has the greatest possible value. If there are multiple periods with the greatest possible value,then print any one of them.Sample Input63 1 6 4 5 2Sample Output603 5SourceNortheastern Europe 2005 è§£æè°œä¸€æ ·çš„waç‚¹â€¦..å·¦è¾¹æ‰«ä¸€é,å³è¾¹æ‰«ä¸€é.æˆ‘è¿˜æ˜¯ä¸çŸ¥é“å’‹waçš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;stack&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define MAX 100010using namespace std;typedef long long LL;LL a[MAX], sum[MAX];int le[MAX], ri[MAX],p[MAX];int main() &#123; int n; cin &gt;&gt; n; memset(le, -1, sizeof(le)); memset(ri, -1, sizeof(ri)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); sum[i] = sum[i - 1] + a[i]; &#125; int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; while (head&lt;=tail &amp;&amp; a[p[tail]] &gt; a[i]) &#123; ri[p[tail]] = i; tail--; &#125; p[++tail] = i; &#125; head = 1, tail = 0; for (int i = n; i &gt;= 1; i--) &#123; while (head &lt;= tail &amp;&amp; a[p[tail]] &gt; a[i]) &#123; le[p[tail]] = i; tail--; &#125; p[++tail] = i; &#125; LL ans = -1; int ans_l = -1, ans_r = -1; for (int i = 1; i &lt;= n; i++) &#123; int l = le[i] == -1 ? 0 : le[i],r = ri[i] == -1 ? n : ri[i] - 1; LL cur = (sum[r] - sum[l]) * a[i]; if (cur &gt; ans) &#123; ans_l = l + 1; ans_r = r; ans = cur; &#125; &#125; printf("%lld\n%d %d\n", ans, ans_l, ans_r); return 0;&#125; è®¡è’œå®¢ Max answerhttps://nanti.jisuanke.com/t/38228Alice has a magic array. She suggests that the value of a interval is equal to the sum of the values in the interval, multiplied by the smallest value in the interval.Now she is planning to find the max value of the intervals in her array. Can you help her? InputFirst line contains an integer $n$($1â‰¤nâ‰¤5Ã—10^5$).Second line contains nn integers represent the array $a(âˆ’10 ^5 â‰¤a_i â‰¤10^5)$. OutputOne line contains an integer represent the answer of the array.æ ·ä¾‹è¾“å…¥51 2 3 4 5æ ·ä¾‹è¾“å‡º36 è§£ææ±‚åŒºé—´$(l,r)*min(l,r)$,åœ¨$(l,r)$åŒºé—´å†…å–ä¸€ä¸ªæœ€å°å€¼,ä¹˜è¯¥åŒºé—´å†…å€¼çš„å’Œ,é—®æ€æ ·å–æ‰èƒ½å–åˆ°æœ€å¤§å€¼.é¦–å…ˆ,å› ä¸ºæ•°æ®è¿‡å¤§,è¦ç”¨å•è°ƒæ ˆ.å¦‚æœå•å¥—æ¨¡æ¿,ä¼šwa,å› ä¸ºä¼šæœ‰è´Ÿæ•°.æ•…è¦å¯¹è´Ÿæ•°è¿›è¡Œç‰¹åˆ¤.å¦‚æœæ˜¯è´Ÿæ•°â€¦å°±æŒ‰$o(n^2)$çš„ç®—æ³•åšä¸€éâ€¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifconst int MAX = 1e6 + 1;using namespace std;long long n, q[MAX], l[MAX], r[MAX], a[MAX], num[MAX],maxl[MAX];long long read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int main()&#123; n = read(); int head = 1, tail = 0; for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); num[i] = num[i - 1] + a[i]; while (tail &gt;= head &amp;&amp; a[i] &lt;= a[q[tail]]) tail--; l[i] = tail &lt; head ? 1 : q[tail] + 1; q[++tail] = i; &#125; head = 1, tail = 0; for (int i = n; i &gt; 0; i--) &#123; while (tail &gt;= head &amp;&amp; a[i] &lt;= a[q[tail]]) tail--; r[i] = tail &lt; head ? n : q[tail] - 1; q[++tail] = i; &#125; long long ans = 0; for (int i = 1; i &lt;= n; i++) if (a[i] &lt; 0) &#123; long long set = 0; for (int j = l[i]; j &lt;= i; j++) maxl[i]= min(maxl[i],num[i] - num[j-1]); set=max(set,maxl[i]*a[i]); for (int j = i + 1; j &lt;= r[i]; j++) set = max(set, a[i] * (maxl[i] + num[j] - num[i])); ans = max(ans, set); &#125; else ans = max(ans, a[i] * (num[r[i]] - num[l[i] - 1])); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*5-8 -7 1 -7 -8*/]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å•è°ƒé˜Ÿåˆ—</tag>
        <tag>å•è°ƒæ ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å·¦åå †]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%B7%A6%E5%81%8F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[ä¸€.åºå¼ºçƒˆå®‰åˆ©&lt;æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ-cè¯­è¨€æè¿°&gt;è¿™æœ¬ä¹¦!!!æ›´å¥½çš„è®²è§£å¯é˜…è¯»è¯¥ä¹¦.æˆ–è€…çœ‹è¿™ä½å¤§ä½¬çš„åšå®¢%% äºŒ.ç”¨å¤„è¿™ä¸ªå·¦å¼å †å•Š~ç›´æ¥å½“ä½œå¯ä»¥åˆå¹¶çš„äºŒå‰å †æ¥ç†è§£,è¿™æ˜¯å†æœ€å¥½ä¸è¿‡çš„äº†,å…¶ä»–å’Œå †æ²¡å•¥åŒºåˆ«. ä¸‰.åŸºæœ¬æ¦‚å¿µ é›¶è·¯å¾„é•¿ï¼ˆ$null\ pathength$ï¼‰$Npl(X)$ï¼šç»“ç‚¹$X$åˆ°ä¸€ä¸ªæ²¡æœ‰ä¸¤ä¸ªå„¿å­çš„ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚è¿™é‡Œæˆ‘ä»¬å®šä¹‰æ²¡æœ‰ä¸¤ä¸ªå„¿å­çš„ç»“ç‚¹çš„$Npl(x)=1$ï¼›$Npl(NULL) = 0$ã€‚ å·¦å †å’Œå †ä¸€æ ·ï¼Œä¹Ÿå…·æœ‰ç»“æ„æ€§è´¨å’Œå †åºæ€§è´¨ã€‚å·¦å †çš„ç»“æ„æ€§è´¨æ˜¯æŒ‡ï¼šå¯¹äºå †ä¸­çš„æ¯ä¸€ä¸ªç»“ç‚¹$X$ï¼Œå®ƒçš„å·¦å„¿å­çš„é›¶è·¯å¾„é•¿è¦ä¸å°äºå…¶å³å„¿å­çš„é›¶è·¯å¾„é•¿ã€‚å †åºä¿¡æ¯ä¸å †çš„ä¸€æ ·ï¼Œå³ï¼šæœ€å°çš„ç»“ç‚¹åº”è¯¥æ˜¯æ ¹èŠ‚ç‚¹ï¼Œé‰´äºæˆ‘ä»¬å¸Œæœ›å­æ ‘ä¹Ÿæ˜¯å †ï¼Œé‚£ä¹ˆæ¯ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹ä¹Ÿåº”è¯¥æ˜¯æœ€å°çš„è¿™ä¸€æ€§è´¨å¿…ç„¶ä¼šå¯¼è‡´å·¦å †æ˜¯ä¸€ä¸ªæå…¶ä¸å¹³è¡¡çš„æ ‘ã€‚ä¹¦ä¸ŠåŸè¯ å››.åˆå¹¶æ¯æ¬¡åˆå¹¶éƒ½ä»å³å­æ ‘å¼€å§‹åˆå¹¶.è¿™å›¾æˆ‘ä¹Ÿçœ‹ä¸å¤§æ‡‚,å¤§è‡´ç†è§£å°±å¥½äº†.åæ­£ä»£ç å†™å‡ºæ¥,æ„Ÿè§‰å’Œå›¾çš„æ–¹æ³•æ²¡å¤§å…³ç³» äº”.ä»£ç å®ç°(ä¸€).ç»“æ„12345typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root; 1234567891011121314151617181920### (äºŒ).åˆå¹¶```cppnd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //å †,å°æ ¹&lt;,å¤§æ ¹&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) //ä¿è¯æ€§è´¨ä¸å˜ swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; //åˆå¹¶å,æ ¹èŠ‚ç‚¹çš„nplè·ç¦»å–å³å„¿å­çš„è·ç¦»+1 &#125; return p;&#125; (ä¸‰).æ’å…¥æ’å…¥è¿™ä¸ªå‘½ä»¤,å¯ä»¥ç†è§£ä¸º,ä¸€ä¸ªå•ä¸ªæ•°çš„å †,ä¸å¤§å †åˆå¹¶.å³æŠŠè¦æ’å…¥çš„æ•°å½“ä½œä¸€ä¸ªå †,ä¸è¦æ’å…¥çš„å †åˆå¹¶å³å¯. 1234567891011nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; (å››).åˆ é™¤åˆ é™¤å †é¦–çš„å€¼,å¯ä»¥ç†è§£ä¸º,å°†å †æ ¹èŠ‚ç‚¹çš„å·¦å³å„¿å­åˆ†æˆä¸¤ä¸ªå †,ç„¶åå†åˆå¹¶æˆä¸€ä¸ªæ–°çš„å †. 12345678910nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125; (äº”).æ ·ä¾‹ä»£ç æŒ‡é’ˆå®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson),close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //å †çš„å°æ ¹&lt;,å¤§æ ¹&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125; æ•°ç»„å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define MAXN 150010#define lson(x) S[x].Son[0]#define rson(x) S[x].Son[1]struct Tree &#123; int dis, val, Son[2], fa;&#125; S[MAXN];inline int Merge(int x, int y)&#123; if (!x || !y) return x + y; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y); rson(x) = Merge(rson(x), y); if (S[lson(x)].dis &lt; S[rson(x)].dis) swap(lson(x), rson(x)); S[lson(x)].fa = S[rson(x)].fa = S[x].fa = x; S[x].dis = S[rson(x)].dis + 1; return x;&#125;inline int ffa(int x)&#123; return S[x].fa == x ? x : S[x].fa = ffa(S[x].fa);&#125;inline void Pop(int x)&#123; S[x].val = -1; S[lson(x)].fa = lson(x), S[rson(x)].fa = rson(x); S[x].fa = Merge(lson(x), rson(x));&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; S[0].dis = -1; for (int i = 1; i &lt;= n; ++i)&#123; S[i].fa = i; scanf("%d", &amp;S[i].val); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int t,x,y; cin&gt;&gt;t; if (t == 1) &#123; cin&gt;&gt;x&gt;&gt;y; if (S[x].val == -1 || S[y].val == -1) continue; int fx = ffa(x), fy = ffa(y); if (fx != fy) S[fx].fa = S[fy].fa = Merge(fx, fy); &#125; else &#123; cin&gt;&gt;x; if (S[x].val == -1) printf("-1\n"); else printf("%d\n", S[ffa(x)].val), Pop(ffa(x)); &#125; &#125; return 0;&#125; ä¾‹é¢˜(hdu 1512) Monkey Kinghttp://acm.hdu.edu.cn/showproblem.php?pid=1512 Problem DescriptionOnce in a forest, there lived $N$ aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys canâ€™t avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, $10$ will be reduced to $5$ and $5$ will be reduced to $2$).And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel. InputThere are several test cases, and each case consists of two parts.First part: The first line contains an integer $N$($N\leq100000$), which indicates the number of monkeys. And then $N$ lines follows. There is one number on each line, indicating the strongness value of ith monkey($\leq32768$).Second part: The first line contains an integer $M$($M\leq100000$), which indicates there are $M$ conflicts happened. And then $M$ lines follows, each line of which contains two integers $x$ and $y$, indicating that there is a conflict between the $X_{th}$ monkey and $Y_{th}$. OutputFor each of the conflict, output $-1$ if the two monkeys know each other, otherwise output the strongness value of the strongest monkey in all friends of them after the duel. Sample Input520161010452 33 43 54 51 5Sample Output855-110AuthorJIANG, YanyanSourceZOJ 3rd Anniversary ContestRecommendlinle è§£æ ä¸€å¼€å§‹æœ‰$n$åªå­¤ç‹¬çš„çŒ´å­ï¼Œç„¶åä»–ä»¬è¦æ‰“$m$æ¬¡æ¶ï¼Œæ¯æ¬¡æ‰“æ¶å‘¢ï¼Œéƒ½ä¼šæ‹‰ä¸Šè‡ªå·±æœ‹å‹æœ€ç‰›å‰çš„å‡ºæ¥è·Ÿåˆ«äººæ‰“ï¼Œæ‰“å®Œä¹‹åæˆ˜æ–—åŠ›å°±ä¼šå‡åŠï¼Œæ¯æ¬¡æ‰“å®Œæ¶å°±ä¼šæˆä¸ºæœ‹å‹ï¼ˆæ­£æ‰€è°“ä¸æ‰“ä¸ç›¸è¯†o(âˆ©_âˆ©)oï¼‰ã€‚é—®æ¯æ¬¡æ‰“å®Œæ¶ä¹‹åé‚£ä¿©çŒ´å­æœ€ç‰›å‰çš„æœ‹å‹æˆ˜æ–—åŠ›è¿˜æœ‰å¤šå°‘ï¼Œè‹¥æœ‹å‹æ‰“æ¶å°±è¾“å‡º$-1$. å¹¶æŸ¥é›†+å¯å¹¶å †æ¯æ¬¡çŒ´å­å’ŒçŒ´å­æ‰“æ¶åšæœ‹å‹,å°±å¹¶åœ¨ä¸€èµ·.æ¯æ¬¡è¦æ‰“æ¶å°±æŸ¥ä¸€ä¸‹æ˜¯ä¸æ˜¯åœ¨ä¸€èµ·çš„æœ‹å‹,ä¸æ˜¯å°±æ‰“æ¶,æ˜¯å°±è¾“å‡º$-1$. åœ¨ç»å†äº†æ— æ•°æ¬¡$re$å’Œ$mle$å,æˆ‘æŠŠ$close$å‡½æ•°åˆ äº†==,é—ç•™çš„æŒ‡é’ˆé—ç•™å°±é—ç•™å§.å°±$ac$äº†â€¦â€¦.$wtf$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;cstdio&gt;#ifndef NULL#define NULL 0;#endifusing namespace std;typedef struct heap* nd;struct heap &#123; int d, npl; nd lson, rson;&#125;*root;struct vec &#123; int d,fa; nd p; vec() &#123; d = 0, p = NULL; &#125;&#125;a[101000];void close(nd p)&#123; if (p == NULL) return; close(p-&gt;lson); close(p-&gt;rson); delete(p);&#125;nd merge(nd p, nd ip)&#123; if (p == NULL) return ip; if (ip == NULL) return p; if (ip-&gt;d &gt; p-&gt;d) //å †çš„å°æ ¹&lt;,å¤§æ ¹&gt; swap(p, ip); if (p-&gt;lson == NULL) p-&gt;lson = ip; else &#123; p-&gt;rson = merge(p-&gt;rson, ip); if (p-&gt;lson-&gt;npl &lt; p-&gt;rson-&gt;npl) swap(p-&gt;lson, p-&gt;rson); p-&gt;npl = p-&gt;rson-&gt;npl + 1; &#125; return p;&#125;nd pop(nd p)&#123; if (p == NULL) &#123; cout &lt;&lt; "error pop" &lt;&lt; endl; exit(65530); &#125; nd lp = p-&gt;lson, rp = p-&gt;rson; free(p); return merge(lp, rp);&#125;nd insert(nd p, int x)&#123; nd ip = (nd)malloc(sizeof(struct heap)); if (ip == NULL) &#123; cout &lt;&lt; "error insert" &lt;&lt; endl; exit(65530); &#125; ip-&gt;lson = ip-&gt;rson = NULL; ip-&gt;npl = 0, ip-&gt;d = x; return p = merge(p, ip);&#125;int top(nd p)&#123; return p-&gt;d;&#125;int ffa(int x)&#123; if (x == a[x].fa) return x; return a[x].fa=ffa(a[x].fa);&#125;int read()&#123; int x = 0, f = 1; char c = getchar(); while (c&lt;'0' || c&gt;'9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x * f;&#125;int main()&#123; int n, m; while (~scanf("%d",&amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; a[i].d=read(); a[i].fa = i; a[i].p = insert(a[i].p, a[i].d); &#125; m=read(); for (int i = 1; i &lt;= m; i++) &#123; int x, y, fx, fy; x=read(),y=read(); fx = ffa(x), fy = ffa(y); if (fx != fy) &#123; a[fy].fa = fx; int num1 = top(a[fx].p) / 2, num2 = top(a[fy].p) / 2; a[fx].p = pop(a[fx].p); a[fy].p = pop(a[fy].p); a[fx].p = a[fy].p = merge(a[fx].p, a[fy].p); a[fx].p = a[fy].p = insert(a[fx].p, num1); a[fx].p = a[fy].p = insert(a[fx].p, num2); cout &lt;&lt; top(a[fx].p) &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; for (int i = 1; i &lt;= n; i++) a[i].p = NULL; &#125; return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å·¦åå †</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STè¡¨]]></title>
    <url>%2F2019%2F08%2F09%2FST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[å¼•ä¾‹æ´›è°·P3865$RMQ$çš„ä¸­æ–‡ç¿»è¯‘ä¸º:é™æ€åŒºé—´æœ€å€¼æŸ¥è¯¢.è‹±æ–‡æˆ‘ä¸çŸ¥é“æ‰€ä»¥ä¸å†™ç»™ä½ $n$ä¸ªæ•°,$m$æ¬¡æŸ¥è¯¢,æŸ¥è¯¢çš„å†…å®¹ä¸ºåŒºé—´$[l,r]$ä¸­çš„æœ€å¤§å€¼.$RMQ$æœ‰è§£æ³•è›®å¤šçš„,$st$è¡¨,çº¿æ®µæ ‘,æ ‘çŠ¶æ•°ç»„,åˆ’åˆ†æ ‘éƒ½å¯ä»¥åš.$st$è¡¨çš„å¤æ‚åº¦ä¸ºé¢„å¤„ç†$O(n*{\log_2} n)$+æŸ¥è¯¢$O(m)$è€Œçº¿æ®µæ ‘åˆ™éœ€è¦é¢„å¤„ç†$O(n*{\log_2} n)$+æŸ¥è¯¢$O(m*{\log_2} n)$æ ‘çŠ¶æ•°ç»„æ²¡å­¦,ä¸æ¸…æ¥šçº¿æ®µæ ‘å¯ä»¥çœ‹æˆ‘ä¹‹å‰çš„åšå®¢. å®šä¹‰è¿™ä¸ªç®—æ³•å°±æ˜¯åŸºäº$DP$å’Œä½è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬ç”¨$dp[i][j]$è¡¨ç¤ºä»ç¬¬ $i$ ä½å¼€å§‹ï¼Œåˆ°ç¬¬ $i + 2^j -1$ ä½çš„æœ€å¤§å€¼æˆ–è€…æœ€å°å€¼ã€‚ é‚£ä¹ˆæˆ‘æ±‚$dp[i][j]$çš„æ—¶å€™å¯ä»¥æŠŠå®ƒåˆ†æˆä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†ä» $i$ åˆ° $i + 2 ^{(j-1)} - 1$ ï¼Œç¬¬äºŒéƒ¨åˆ†ä» $i + 2 ^{(j-1)}$ åˆ°$i + 2^j- 1$,é‚£ä¹ˆå¯ä»¥å¾—åˆ°$$dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1])$$å½“$j=0$æ—¶,æ±‚çš„æ˜¯é•¿åº¦ä¸º1çš„åŒºé—´çš„æœ€å°å€¼,$j=1$æ—¶,æ±‚çš„æ˜¯é•¿åº¦ä¸º2çš„åŒºé—´æœ€å°å€¼$j=2$æ—¶,æ±‚çš„æ˜¯é•¿åº¦ä¸º4çš„åŒºé—´æœ€å°å€¼ä»¥æ­¤ç±»æ¨,æ•…å¯åœ¨$O(n\log_2 n)$çš„å¤æ‚åº¦å¤„ç†å®Œ.å¦‚å›¾æ‰€ç¤ºæŸ¥è¯¢çš„è¯,åªéœ€è¦åè¿‡æ¥å°±é˜”ä»¥äº†. å®Œæ•´ä»£ç è¿™é‡Œmm[i] = mm[i - 1] +((i&(i - 1)) == 0);123456789101112131415161718192021222324252627282930313233343536373839```cppconst int MAXN = 1e5 + 10;int dp[MAXN][31],a[MAXN],mm[MAXN];void initRMQ(int n)&#123; mm[0] = -1; for (int i = 1; i &lt;= n; i++) &#123; mm[i] = mm[i - 1] +((i&amp;(i - 1)) == 0); dp[i][0] = a[i]; &#125; for (int j = 1; j &lt;= mm[n]; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int rmq(int x, int y)&#123; int k = mm[y - x + 1]; return max(dp[x][k], dp[y - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m;//scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initRMQ(n); while (m--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; rmq(x, y) &lt;&lt; &apos;\n&apos;; &#125; return 0;&#125; äºŒç»´stè¡¨æš‚å­˜https://blog.csdn.net/VictoryCzt/article/details/83684082 çº¦æŸRMQhttps://www.cnblogs.com/ghostcai/p/9280720.htmlhttps://blog.csdn.net/VictoryCzt/article/details/83348579 ç»ƒä¹ é¢˜ç›®æ´›è°·P2251è£¸çš„$RMQ$é—®é¢˜æ´›è°·P3865$st$è¡¨æ¨¡æ¿é¢˜ç›®æ´›è°·P2048$st$è¡¨+å‰ç¼€å’Œ+è´ªå¿ƒ+å †ä¼˜åŒ–]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>STè¡¨</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQåˆ†æ²»]]></title>
    <url>%2F2019%2F08%2F09%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[ä¸å¾—ä¸è¯´&emsp;&emsp;æœ¬æ¥æ ‡é¢˜æƒ³å†™åˆ†æ²»,ä½†æ˜¯æƒ³äº†æƒ³å‘ç°è‡ªå·±åˆ†æ²»èƒ½è¯´çš„ä¸å¤š,ä¸»è¦çš„å†…å®¹å°±æ˜¯$CDQ$åˆ†æ²».ä¾¿å–äº†è¿™ä¸ªæ ‡é¢˜. é¢„å¤‡çŸ¥è¯† å…³äºä»€ä¹ˆæ˜¯åˆ†æ²»&emsp;&emsp;åˆ†æ²»ï¼Œå­—é¢ä¸Šçš„è§£é‡Šæ˜¯â€œåˆ†è€Œæ²»ä¹‹â€ï¼Œå°±æ˜¯æŠŠä¸€ä¸ªå¤æ‚çš„é—®é¢˜åˆ†æˆä¸¤ä¸ªæˆ–æ›´å¤šçš„ç›¸åŒæˆ–ç›¸ä¼¼çš„å­é—®é¢˜ï¼Œå†æŠŠå­é—®é¢˜åˆ†æˆæ›´å°çš„å­é—®é¢˜â€¦â€¦ç›´åˆ°æœ€åå­é—®é¢˜å¯ä»¥ç®€å•çš„ç›´æ¥æ±‚è§£ï¼ŒåŸé—®é¢˜çš„è§£å³å­é—®é¢˜çš„è§£çš„åˆå¹¶ã€‚åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œåˆ†æ²»æ³•å°±æ˜¯è¿ç”¨åˆ†æ²»æ€æƒ³çš„ä¸€ç§å¾ˆé‡è¦çš„ç®—æ³•ã€‚åˆ†æ²»æ³•æ˜¯å¾ˆå¤šé«˜æ•ˆç®—æ³•çš„åŸºç¡€ï¼Œå¦‚æ’åºç®—æ³•ï¼ˆå¿«é€Ÿæ’åºï¼Œå½’å¹¶æ’åºï¼‰ï¼Œå‚…ç«‹å¶å˜æ¢ï¼ˆå¿«é€Ÿå‚…ç«‹å¶å˜æ¢ï¼‰ç­‰ç­‰ã€‚ ä¸€èˆ¬æ­¥éª¤ åˆ’åˆ†æ­¥ï¼šæŠŠè¾“å…¥çš„é—®é¢˜åˆ’åˆ†ä¸º$k$ä¸ªå­é—®é¢˜ï¼Œå¹¶å°½é‡ä½¿è¿™$k$ä¸ªå­é—®é¢˜çš„è§„æ¨¡å¤§è‡´ç›¸åŒã€‚ æ²»ç†æ­¥ï¼šå½“é—®é¢˜çš„è§„æ¨¡å¤§äºæŸä¸ªé¢„å®šçš„é˜ˆå€¼$n_0$æ—¶ï¼Œæ²»ç†æ­¥ç”±$k$ä¸ªé€’å½’è°ƒç”¨ç»„æˆã€‚ ç»„åˆæ­¥ï¼šç»„åˆæ­¥æŠŠå„ä¸ªå­é—®é¢˜çš„è§£ç»„åˆèµ·æ¥ï¼Œå®ƒå¯¹åˆ†æ²»ç®—æ³•çš„å®é™…æ€§èƒ½è‡³å…³é‡è¦ï¼Œç®—æ³•çš„æœ‰æ•ˆæ€§å¾ˆå¤§åœ°ä¾èµ–äºç»„åˆæ­¥çš„å®ç°ã€‚ æ—¶é—´å¤æ‚åº¦ ç›´è§‚ä¼°è®¡ åˆ†æ²»ç”±ä»¥ä¸Šä¸‰éƒ¨åˆ†æ„æˆï¼Œæ•´ä½“æ—¶é—´å¤æ‚åº¦åˆ™ç”±è¿™ä¸‰éƒ¨åˆ†çš„æ—¶é—´å¤æ‚åº¦ä¹‹å’Œæ„æˆ. ç”±äºé€’å½’ï¼Œæœ€ç»ˆçš„å­é—®é¢˜å˜å¾—æä¸ºç®€å•ï¼Œä»¥è‡³äºå…¶æ—¶é—´å¤æ‚åº¦åœ¨æ•´ä¸ªåˆ†æ²»ç­–ç•¥ä¸Šçš„æ¯”é‡å¾®ä¹å…¶å¾®. ç»å…¸ä¾‹é¢˜ å½’å¹¶æ’åº,å¿«æ’ç­‰ æ±‚é€†åºå¯¹ç­‰ç»å…¸ä¾‹é¢˜$Atcoder\ A\ -\ Colorful\ Subsequence$https://atcoder.jp/contests/agc031/tasks/agc031_a é¢˜ç›®ç®€æ: é—®å¤šå°‘ç§å­åºåˆ—,å­åºåˆ—ä¸­çš„å­—æ¯ä¸åŒ. åˆ—å¦‚$baa$,åŒ…æ‹¬:$b,a,a,$ä¸¤ä¸ªä¸åŒä½ç½®$a$çš„$ba$,æ€»è®¡$5$ä¸ª,$baa$æ’é™¤æ˜¯å› ä¸º$a$æ˜¯é‡å¤çš„. è§£æ³• å…ˆå°†æ¯ä¸ªå­—æ¯çš„ä¸ªæ•°ç»Ÿè®¡ä¸‹æ¥,ç„¶ååˆ†æ²»è®¡ç®—,ä¸€ä¸ªå­—æ¯çš„æ—¶å€™,ç­”æ¡ˆæ˜¯è¯¥å­—æ¯å‡ºç°çš„æ¬¡æ•°. åªæœ‰ä¸¤ä¸ªå­—æ¯çš„æ—¶å€™,å¦‚$ab$,åŒ…å«çš„æ’åˆ—æœ‰$a,b,ab$,ç›¸å½“äºâ€™$a$çš„ä¸ªæ•°,$b$çš„ä¸ªæ•°,$a$å’Œ$b$ç»„åˆä¸ªæ•°â€™çš„åŠ å’Œ,è€Œ$a$å’Œ$b$ç»„åˆä¸ªæ•°,åˆ™æ˜¯$a$çš„ä¸ªæ•°$\times b$çš„ä¸ªæ•° åŒç†å¯å¾—,$ans$å³ä¸º$ansL+ansR+ansL\times ansR$.1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e5 + 10;const int MOD = 1e9 + 7;typedef long long ll;char s[INF];int num[27];string s1="0";ll solve(int L, int R)&#123; if (L == R) return num[s1[L] - 'a']; int mid = (L + R) &gt;&gt; 1; ll nL = solve(L, mid), nR = solve(mid + 1, R); return (nL%MOD + nR%MOD + (nL%MOD * nR%MOD)%MOD)%MOD;&#125;int main()&#123; int n; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (!num[s[i] - 'a']) s1 = s1 + s[i]; num[s[i] - 'a']++; &#125; cout &lt;&lt; solve(1, s1.length() - 1)&lt;&lt;endl; return 0;&#125; CDQåˆ†æ²»å‰é¢çµ®çµ®å¨å¨çš„ç®€å•ä»‹ç»äº†ä¸‹åˆ†æ²»,æƒ³å¿…å„ä½å¯¹åˆ†æ²»æœ‰äº†ä¸€å®šè®¤è¯†.ä¸‹é¢æ˜¯é‡å¤´æˆ:$CDQ$åˆ†æ²».è¿™ä¸ªç®—æ³•,æ˜¯ç”±é™ˆä¸¹ç¦å¤§ç‰›åœ¨è®ºæ–‡ä¸­æå‡ºçš„%%%.é¦–å…ˆ,æˆ‘ä»¬éœ€è¦çŸ¥é“ä¸€äº›äº‹æƒ…: ä¼˜åŠ¿åœ¨äºå¯ä»¥é¡¶æ›¿å¤æ‚çš„é«˜çº§æ•°æ®ç»“æ„ï¼Œè€Œä¸”å¸¸æ•°æ¯”è¾ƒå° ç¼ºç‚¹åœ¨äºå¿…é¡»ç¦»çº¿æ“ä½œ ç”¨æ¥è§£å†³ä»€ä¹ˆé—®é¢˜å‘¢? é¦–å…ˆ,åˆ†æ²»é—®é¢˜2333 åˆ†æ²»åçš„ç­”æ¡ˆ,ä¸ä»…å•å•è€ƒè™‘å­é—®é¢˜${L,mid}$å’Œå­é—®é¢˜${mid+1,R}$. è¿˜éœ€è¦è€ƒè™‘å­é—®é¢˜${L,mid}$å¯¹å­é—®é¢˜${mid+1,R}$çš„å½±å“$/$è”ç³»äº§ç”Ÿçš„ç­”æ¡ˆ. åˆ—å¦‚: äºŒç»´ååºé—®é¢˜ ç»™å®šä¸€ä¸ªäºŒå…ƒç»„${x,y}$,è¦æ±‚é—®æœ‰å¤šå°‘å¯¹${x_i,y_i},{x_j,y_j}$æ»¡è¶³$x_i&gt;x_j$&&$y_i&gt;y_j$ è§£æ³•ä¸º: å…ˆå°†äºŒå…ƒç»„æŒ‰ç…§$x$çš„å¤§å°æ’åˆ—. åˆ†æ²»å,æˆ‘ä»¬åˆ†åˆ«çŸ¥é“${L,mid}$åŒºé—´å’Œ${mid+1,R}$åŒºé—´å†…çš„è§£ å†è®¡ç®—è·¨è¿‡$mid$çš„ä¸¤å¯¹ç‚¹,å¯¹${L,mid}$å’Œ${mid+1,R}$ä¸­çš„äºŒå…ƒç»„æŒ‰ç…§$y$çš„å¤§å°æ’åº ç”±äºå…ˆå‰åˆ†ç»„ä¾¿å·²ç»å¯¹$x$è¿›è¡Œæ’åº,æ‰€ä»¥,åªéœ€è¦äºŒåˆ†ä¾¿å¯ä»¥æ±‚å¾—å·¦åŒºé—´ç›¸å¯¹äºå³åŒºé—´çš„ç‚¹çš„ä¸ªæ•°. ä¸‰ç»´ååºé—®é¢˜ å’ŒäºŒç»´ååºé—®é¢˜ç±»ä¼¼,ä½†æœ‰ä¸€å®šä¸åŒ ç»™å®šä¸€ä¸ªä¸‰å…ƒç»„${x,y,z}$,è¦æ±‚é—®æœ‰å¤šå°‘å¯¹${x_i,y_i,z_i},{x_j,y_j,z_j}$æ»¡è¶³$x_i&gt;x_j$&&$y_i&gt;y_j$&&$z_i&gt;z_j$ è§£æ³•ä¸º: å…ˆå°†ä¸‰å…ƒç»„æŒ‰ç…§$x$çš„å¤§å°æ’åˆ—. åˆ†æ²»å,æˆ‘ä»¬åˆ†åˆ«çŸ¥é“${L,mid}$åŒºé—´å’Œ${mid+1,R}$åŒºé—´å†…çš„è§£ å†è®¡ç®—è·¨è¿‡$mid$çš„ä¸¤å¯¹ç‚¹,å¯¹${L,mid}$å’Œ${mid+1,R}$ä¸­çš„ä¸‰å…ƒç»„æŒ‰ç…§$y$çš„å¤§å°æ’åº ç”±äºå…ˆå‰åˆ†ç»„ä¾¿å·²ç»å¯¹$x$è¿›è¡Œæ’åº,æ‰€ä»¥,åªéœ€è¦äºŒåˆ†ä¾¿å¯ä»¥æ±‚å¾—æ»¡è¶³$y$æ¡ä»¶çš„ç‚¹. å†å»ºç«‹ä¸€ä¸ªæƒå€¼æ ‘çŠ¶æ•°ç»„$/$çº¿æ®µæ ‘,å†å°†ä¸Šé¢ç¬¦åˆçš„${x,y,z}$å¯¹åº”ä¸­æ»¡è¶³ä¸ç­‰å¼çš„$z$çš„ç‚¹æ±‚å‡º. ä¾‹é¢˜ BZOJ3262: é™Œä¸ŠèŠ±å¼€ BZOJ4237: ç¨»è‰äººæˆ–è€…è¿™ä¸ªLibreOJç¨»è‰äºº ä¼ªä»£ç 123456789101112void cdq(int left,int right)&#123; if(left==right) return ; int mid=(left+right)&gt;&gt;1; cdq(left,mid),cdq(mid+1,right); sort(a+l,a+mid+1,cmp); sort(a+mid+1,a+right+1,cmp); /** *å¤„ç†å·¦åŒºé—´å¯¹äºå³åŒºé—´å½±å“çš„ä»£ç  */ ä¾‹é¢˜:ç¨»è‰äººé—®é¢˜ç®€è¿°é“¾æ¥https://loj.ac/problem/2880 &emsp;&emsp;ç»™å®š$n$ä¸ªç¨»è‰äººï¼ˆæ¨ªçºµåæ ‡æ˜¯ä¸å¤§äº$10^9$çš„éè´Ÿæ•´æ•°ä¸”ä¸¤ä¸¤$x,y$éƒ½ä¸ç›¸åŒï¼‰æ±‚æœ‰å¤šå°‘ä¸ªçŸ©å½¢æ»¡è¶³ï¼š è¾¹å¹³è¡Œäºæ¨ªã€çºµè½´ å·¦ä¸‹è§’ã€å³ä¸Šè§’éƒ½æ˜¯ç»™å®šçš„ç¨»è‰äºº å†…éƒ¨ä¸åŒ…å«å…¶å®ƒç¨»è‰äººè§£æ&emsp;&emsp;$Step\ 1.{\ }$&emsp;&emsp;é¦–å…ˆè€ƒè™‘,å¦‚æœæ— è§†ç¬¬ä¸‰æ¡,é‚£ä¹ˆ,è¯¥é¢˜å˜ä¸ºäº†ä»€ä¹ˆ?&emsp;&emsp;ç»™å®šäºŒå…ƒç»„é›†åˆ,$A={x,y}$,é‚£ä¹ˆå¯¹äºä»»ä½•${x_i,y_i}$,${x_j,y_j}$,é—®æœ‰å¤šå°‘å¯¹ç‚¹æ»¡è¶³:$y_j&gt;y_i$&&$x_j&gt;x_i$&emsp;&emsp;å¯¹äºè¿™æ ·çš„ä¸€ä¸ªå¼å­,æˆ‘ä»¬å¾ˆå®¹æ˜“å¾—åˆ°ä¸¤ç§è§£æ³•,ç¬¬ä¸€ç§:æ ‘çŠ¶æ•°ç»„/ä¸‡èƒ½çš„çº¿æ®µæ ‘.ç¬¬äºŒç§:$cdq$åˆ†æ²».å½“ç„¶,æœ¬è’Ÿè’»é€‰æ‹©ç¬¬äºŒç§.(ä¸ºä»€ä¹ˆ?æ ‘çŠ¶æ•°ç»„å’±è¿˜æ²¡å­¦,çº¿æ®µæ ‘ä¸ä¼šä½¿)&emsp;&emsp;ç„¶åå‘¢,$cdq$åˆ†æ²»çš„æ ‡å‡†æ“ä½œä¸º?12345678910void solve(int left, int right)&#123; if (left == right) return; int mid = (left + right) &gt;&gt; 1; solve(left, mid), solve(mid+1 , right);//åˆ†æ²»å¤„ç†å·¦åŠè¾¹å’Œå³åŠè¾¹ /** *å¤„ç†ä¸¤è¾¹å…³ç³»çš„ä»£ç  */&#125; å¥½çš„,æœ¬é¢˜å®Œç»“ &emsp;&emsp;$Step\ 2.{\ }$&emsp;&emsp;äºæ˜¯,æˆ‘ä»¬åŠ ä¸Šæ¡ä»¶ä¸‰.&emsp;&emsp;å¦‚ä½•å¤„ç†ä¸¤è¾¹ç‚¹ä¹‹é—´çš„å…³ç³»?&emsp;&emsp;å¯¹äºå·¦åŠè¾¹,æˆ‘ä»¬å‡è®¾å³åŠè¾¹çš„ç‚¹éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„. æˆ‘ä»¬å¯ä»¥çŸ¥é“,å¦‚æœå·¦åŠè¾¹çš„ä¸€ä¸ªç‚¹$A$æ˜¯ç¬¦åˆæ¡ä»¶çš„,é‚£ä¹ˆç­”æ¡ˆ$ans+=$å³åŠè¾¹å¯¹äº$A$ç¬¦åˆæ¡ä»¶çš„ç‚¹. æˆ‘ä»¬åœ¨å·¦åŠè¾¹åŠ å…¥$B$ç‚¹,è‹¥$B$ç‚¹çš„å­˜åœ¨æ˜¯ä¸$A$ç‚¹ä¸å†²çªçš„,é‚£ä¹ˆç­”æ¡ˆ$ans+=$å³åŠè¾¹å¯¹äº$B$ç¬¦åˆæ¡ä»¶çš„ç‚¹. è‹¥,$B$ç‚¹ä¸$A$ç‚¹çš„å­˜åœ¨æœ‰çŸ›ç›¾,å³ä¸ç¬¦åˆæ¡ä»¶ä¸‰,åˆ—å¦‚$x_b&lt;x_a,y_b&gt;y_a$è¿™ç§æƒ…å†µ,æˆ‘ä»¬åº”:å°†$A$ç‚¹å¯¹åº”çš„å€¼åˆ å»,åŠ å…¥å³åŠè¾¹å¯¹äº$B$ç¬¦åˆæ¡ä»¶çš„ç‚¹ &emsp;&emsp;$Step\ 3.{\ }$&emsp;&emsp;ç»“åˆ$Step\ 1$å’Œ$Step\ 2$.æˆ‘ä»¬å·²çŸ¥çš„æœ‰:&emsp;&emsp;å‡è®¾æˆ‘ä»¬æ˜¯å¯¹$x$æŒ‰ç…§ä»å°åˆ°å¤§æ’åºçš„,å³å¯¹ç‚¹æŒ‰ç…§$x$ç¦»æ•£åŒ–å. æˆ‘ä»¬çŸ¥é“,å·¦è¾¹çš„$x$å¿…å®šå°äºå³è¾¹çš„$x$. æˆ‘ä»¬è¦æŒ‰ç…§yçš„å¤§å°å¯¹å·¦å³åˆ†åˆ«æ’åº. å¯¹äºå³è¾¹,æˆ‘ä»¬è¦ç»´æŠ¤ä¸€ä¸ªæŒ‰ç…§$x$å•è°ƒé€’å¢çš„å•è°ƒæ ˆ.(å³æŒ‰ç…§$y$é€’å‡) å¯¹äºå·¦è¾¹,æˆ‘ä»¬è¦ç»´æŠ¤ä¸€ä¸ªæŒ‰ç…§$x$å•è°ƒé€’å‡çš„å•è°ƒæ ˆ.(å³æŒ‰ç…§$y$é€’å¢) æ¯æ¬¡å·¦è¾¹æ–°å¢ä¸€ä¸ª$i$ç‚¹,æˆ‘ä»¬éƒ½è¦è®©ç­”æ¡ˆ$ans+=$å³è¾¹ç»´æŠ¤çš„å•è°ƒæ ˆé•¿åº¦.ç­”æ¡ˆ$ans-=$å³è¾¹æ¯”$y_i$å°çš„ç‚¹. æˆ‘ä»¬çŸ¥é“å•è°ƒæ ˆæ˜¯å•è°ƒçš„â€¦.å—¯,æ‰€ä»¥å¯¹äºå¯»ç‚¹,æˆ‘ä»¬å¯ä»¥äºŒåˆ†æŸ¥æ‰¾. &emsp;&emsp;åˆ†æç»“æŸ,ç»¼ä¸Š,ç»†èŠ‚è¯·å‚é˜…åˆ†æ²»çš„ä»£ç æ¥ç†è§£,æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€éå°±éå¸¸æ˜äº†äº†. æ¥è‡ªLibreOJçš„æ•°æ®,éå¸¸é€‚åˆæ¨¡æ‹Ÿè¾“å…¥102 13 06 310 216 40 88 1211 1414 1118 10è¾“å‡º15ç¤ºä¾‹å›¾: ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef null#define null -1#endifusing namespace std;const int MAXN = 2e5 + 10;const int INF = 1e9 + 10;typedef long long ll;struct vec &#123; int x, y,len;&#125;tp[MAXN];int q_R[MAXN], q_L[MAXN], n,tail_L, tail_R;ll ans = 0;bool cmpx(vec a, vec b)&#123; return a.x &lt; b.x;&#125;bool cmpy(vec a, vec b)&#123; return a.y &gt; b.y;&#125;int find(int y)&#123; int left= 1, right= tail_R, mid=(left + right) &gt;&gt; 1; while(left &lt; right)&#123; if (tp[q_R[mid]].y &lt; y) right = mid; else left = mid + 1; mid = (left + right) &gt;&gt; 1; &#125; if (!tail_R || tp[q_R[left]].y &lt; y) left--; return left;&#125; void solve(int left, int right)&#123; if (left == right) return; int mid = (left + right) &gt;&gt; 1; solve(left, mid), solve(mid+1 , right); sort(tp+left, tp + mid+1, cmpy); sort(tp + mid + 1, tp + right + 1, cmpy); int i = left, j = mid + 1; tail_L = tail_R = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) if (tp[i].y &gt; tp[j].y) &#123; while(tail_L &gt; 0 &amp;&amp; tp[q_L[tail_L]].x &lt; tp[i].x) tail_L--; ans += tail_R; if (tail_L &gt; 0) ans -= find(tp[q_L[tail_L]].y); q_L[++tail_L] = i; i++; &#125; else &#123; while(tail_R &gt; 0 &amp;&amp; tp[q_R[tail_R]].x &gt; tp[j].x) tail_R--; q_R[++tail_R] = j; j++; &#125; for (; i &lt;= mid; i++) &#123; while(tail_L &gt; 0 &amp;&amp; tp[q_L[tail_L]].x &lt; tp[i].x) tail_L--; ans += tail_R; if (tail_L &gt; 0) ans -= find(tp[q_L[tail_L]].y); q_L[++tail_L] = i; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; tp[i].x &gt;&gt; tp[i].y; sort(tp+1, tp + n+1, cmpx); solve(1, n); cout&lt;&lt; ans &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>CDQåˆ†æ²»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é«˜ç²¾åº¦]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[æˆ‘å¥½ç¾¡æ…•ä¼šç”¨javaçš„äººä¸ºä»€ä¹ˆè¦ç”¨åˆ°é«˜ç²¾åº¦å‘¢?æˆ‘ä»¬çŸ¥é“,$int$çš„èŒƒå›´æ˜¯$\pm2^{31}-1$,$long,long$çš„èŒƒå›´æ˜¯$\pm2^{63}-1$,é‚£ä¹ˆå½“æˆ‘ä»¬æƒ³è¦è¡¨ç¤ºæ›´å¾€ä¸Šçš„æ•°å­—,åº”è¯¥æ€ä¹ˆåš?è™½ç„¶,æˆ‘å·²ç»å­¦ä¼šäº† æˆ‘ä¸Šå°å­¦å¾ˆè®¡ç®—æœºçš„ä¸€ç§æ–¹å¼,å°†æ¯ä¸€ä½æ”¾åœ¨ä¸€ä¸ª$a[i]$ä¸­,è¿™æ ·,ä¸€ä¸ªæ•°å­—å°±å˜æˆä¸€ä¸ªæ•°ç»„,å¯¹æ•°å­—çš„å››åˆ™è¿ç®—,ä¹Ÿå°±å˜æˆäº†å¯¹æ•°ç»„çš„æ“ä½œ. é«˜ç²¾åº¦åŠ æ³•é—®:$1234+5678$ç­”æ¡ˆæ˜¯å¤šå°‘?ç­”:$æˆ‘ä¸çŸ¥é“$å’³å’³,æŒ‰ç…§å°å­¦çš„æ•™æ³•,æˆ‘ä»¬çŸ¥é“,è¦åˆ—ä¸ªç«–å¼,å¯¹é½æ•°ä½,ä¸€ä½ä¸€ä½ç›¸åŠ ,æ»¡$10$è¿›$1$.äºæ˜¯:$$\quad\quad1234\\underline{,\quad+5678}\\quad\quad6912$$åˆ†æä¸€ä¸‹è®¡ç®—è¿‡ç¨‹,æˆ‘ä»¬å‘ç°,å½“æˆ‘ä»¬ç”¨æ•°ç»„$a$,æ•°ç»„$b$,åˆ†åˆ«å­˜ä¸‹$1234$å’Œ$5678$å,ä»æ•°ç»„çš„æœ€åä¸€ä½å¼€å§‹$for$å¾ªç¯,ç”¨æ•°ç»„$S$ä¿å­˜å’Œ,$temp$ä¿å­˜è¿›ä½å¯ä»¥å¾—åˆ°å†å°†è¿™ä¸ªè¿‡ç¨‹è½¬åŒ–ä¸ºä»£ç ,é«˜ç²¾åº¦åŠ æ³•å°±å†™å‡ºæ¥äº† 123456789101112131415BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125; é«˜ç²¾åº¦å‡æ³•ä¼—æ‰€å‘¨çŸ¥,å‡æ³•æ˜¯åŠ æ³•çš„é€†è¿ç®—.æ‰€ä»¥,æˆ‘ä»¬å°†åŠ æ³•çš„è¿‡ç¨‹åè¿‡æ¥å°±æ˜¯å‡æ³•. ä»å¤´å¾€åå¤„ç† $temp$ä¿å­˜å‘åä¸€ä½çš„å€Ÿä½ å¤„ç†è´Ÿæ•°çš„å·æ‡’æ–¹å¼ä¸º,å°†ç¬¬ä¸€ä½å‰åŠ ä¸ªç¬¦å·,è¾“å‡ºçš„æ—¶å€™å°±åŠ ä¸Šäº†ç¬¦å·1234567891011121314151617181920212223242526272829303132333435363738BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; é«˜ç²¾åº¦ä¹˜æ³•æˆ‘ä»¬ç°åœ¨è¿˜æ˜¯å°å­¦æé—®:$1234\times5678$ç­”æ¡ˆæ˜¯å¤šå°‘æˆ‘ä»¬æ¥åˆ—ä¸ªå¼æ‚$\quad\quad\quad1234$$;\quad\underline{\quad\times5678}$$\quad\quad\quad9872$$\quad\quad8638$$\quad;;7404$$\underline{\quad6170\quad;}$$\quad7006652$é‚£ä¹ˆåˆ†æä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹.è®¾ä¸€ä¸ªç©ºçš„$s$æ•°ç»„,$b$æ•°ç»„çš„ä¸ªä½$\times a$ä»ä¸ªä½å¼€å§‹å’Œ$s$çš„æ¯ä¸€ä½ç›¸åŠ ,$b$æ•°ç»„çš„åä½$\times a$ä»åä½å¼€å§‹å’Œ$s$çš„æ¯ä¸€ä½ç›¸åŠ ,ä»¥æ­¤ç±»æ¨,ä¸€ç›´åˆ°$b$çš„åƒä½è®¡ç®—ç»“æŸ,å¾—åˆ°çš„ä¾¿æ˜¯ç­”æ¡ˆ 1234567891011121314151617181920212223242526BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; é«˜ç²¾åº¦é™¤æ³•å¥½çš„,æˆ‘ä»¬ç°åœ¨è¿˜æ˜¯å°å­¦ç”Ÿ é«˜ç²¾åº¦é™¤ä½ç²¾åº¦å¥½çš„,é¦–å…ˆ,é™¤æ³•æ˜¯ä¹˜æ³•çš„é€†å…ƒ,æ‰€ä»¥æˆ‘ä»¬~å€’ç€åšå›å» ä»å¤´å¾€åå¤„ç† $down$å‚¨å­˜ä½™æ•° å½“ä½™æ•°+è¯¥ä½å°äºä½ç²¾åº¦çš„æ•°æ—¶,æˆ‘ä»¬å‘åå»¶ç»­ä¸€ä½12345678910111213BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret, len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; å®Œæ•´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#define MAXN 9999 //MAXNæ§åˆ¶æ¯ä¸ªa[i]å†…å¤§å°#define DLEN 4 //DLENæ§åˆ¶a[i]ä¸­æœ‰å‡ ä½#define MAXSIZE 5010 //æ§åˆ¶æ•°å­—ä½æ•°class BigNum &#123;private: int a[MAXSIZE]; int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator +(const BigNum &amp;)const; BigNum operator -(const BigNum &amp;)const; BigNum operator *(const BigNum &amp;)const; BigNum operator /(const int &amp;)const; BigNum operator ^(const int &amp;)const; long long operator %(const long long &amp;)const; bool operator &gt;(const BigNum&amp;i_T)const; bool operator &gt;(const int &amp;i_T)const; void print();&#125;;//int-&gt;BigNumBigNum::BigNum(const int i_b)&#123; int c, d = i_b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1))*(MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;//char-&gt;BigNumBigNum::BigNum(const char *i_s)&#123; int t, k, index, L; memset(a, 0, sizeof(a)); L = strlen(i_s); len = L / DLEN; if (L%DLEN) len++; index = 0; for (int i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + i_s[j] - '0'; a[index++] = t; &#125;&#125;//copyBigNum::BigNum(const BigNum &amp;i_T) :len(i_T.len)&#123; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_T.a[i];&#125;//BigNumå¤åˆ¶BigNumBigNum&amp;BigNum::operator=(const BigNum&amp;i_n)&#123; len = i_n.len; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; len; i++) a[i] = i_n.a[i]; return *this;&#125;//cin&gt;&gt; BigNumistream&amp; operator &gt;&gt;(istream &amp;in, BigNum &amp;i_b)&#123; char ch[MAXSIZE * DLEN]; in &gt;&gt; ch; int L = strlen(ch), count = 0, sum = 0; for (int i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; DLEN &amp;&amp; i &gt;= 0; j++, i--, t *= 10) sum += (ch[i] - '0')*t; i_b.a[count] = sum; count++; &#125; i_b.len = count++; return in;&#125;//cout&lt;&lt;BigNumostream&amp; operator &lt;&lt;(ostream&amp; out, BigNum&amp; i_b)&#123; cout &lt;&lt; i_b.a[i_b.len - 1]; for (int i = i_b.len - 2; i &gt;= 0; i--) printf("%04d", i_b.a[i]); return out;&#125;//é«˜ç²¾åº¦é™¤ä½ç²¾åº¦BigNum BigNum::operator/(const int &amp;i_b)const&#123; BigNum ret; int down = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / i_b; down = a[i] + down * (MAXN + 1) - ret.a[i] * i_b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;//é«˜ç²¾åº¦%ä½ç²¾åº¦long long BigNum::operator%(const long long &amp;i_b)const&#123; long long d = 0; for (int i = len - 1; i &gt;= 0; i--) d = ((d*MAXN + 1) % i_b + a[i] * 1LL) % i_b; return d;&#125;//é«˜ç²¾åº¦æ±‚å¹‚BigNum BigNum::operator^(const int &amp;n)const&#123; int i; BigNum t, ret(1); if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;//é«˜ç²¾ä¸é«˜ç²¾æ¯”è¾ƒbool BigNum::operator&gt;(const BigNum &amp;i_T)const&#123; int ln; if (len &gt; i_T.len) return true; else if (len &lt; i_T.len) return false; else &#123; ln = len - 1; while (a[ln] == i_T.a[ln] &amp;&amp; ln &gt; 0) ln--; return (ln &gt;= 0 &amp;&amp; a[ln] &gt; i_T.a[ln]); &#125;&#125;//é«˜ç²¾ä¸ä½ç²¾åº¦bool BigNum::operator&gt;(const int &amp;i_T)const&#123; BigNum b(i_T); return *this &gt; b;&#125;//æ‰“å°é«˜ç²¾åº¦void BigNum::print()&#123; printf("%d", a[len - 1]); for (int i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;//é«˜ç²¾åº¦ç›¸ä¹˜BigNum BigNum::operator*(const BigNum &amp;i_T)const&#123; BigNum ret; int up, i=0, j=0, temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; i_T.len; j++) &#123; temp = a[i] * i_T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1)*(MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator+(const BigNum &amp;i_T)const //BigNum+BigNum&#123; BigNum t(*this); int big; big = i_T.len &gt; len ? i_T.len : len; for (int i = 0; i &lt; big; i++) &#123; t.a[i] += i_T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; t.len = (t.a[big] != 0) ? big + 1 : big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;i_T)const //num - num&#123; int big, j; bool flag; BigNum t1, t2; if (*this &gt; i_T) &#123; t1 = *this; t2 = i_T; flag = 0; &#125; else &#123; t1 = i_T; t2 = *this; flag = 1; &#125; big = t1.len; for (int i = 0; i &lt; big; i++) &#123; if (t1. a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125; é«˜ç²¾åº¦é™¤é«˜ç²¾åº¦å¥½çš„,æˆ‘ä»¬ç°åœ¨ä¸åšå°å­¦ç”Ÿäº†è€ƒè™‘ç”¨é™¤ä½ç²¾åº¦çš„åšæ³•,å¤ªéº»çƒ¦äº†.é‚£ä¹ˆæˆ‘ä»¬å†å›åˆ°é‚£å¥è¯,é™¤æ³•æ˜¯ä¹˜æ³•çš„é€†å…ƒ.è€ƒè™‘:$a/b=c\ldots d$,é‚£ä¹ˆä¹Ÿå°±æ„å‘³ç€$d+c\times b=a$,é‚£ä¹ˆåªè¦æ‰¾åˆ°ä¸€ä¸ªæ•°$c$,ä½¿å¾—$c\times b+d=a$å³å¯äºæ˜¯,é—®é¢˜å˜ä¸ºäº†åŠ æ³•å’Œä¹˜æ³•çš„ç»„åˆ.å¯¹äºåŠ æ³•,ä¸€ä¸ªä¸ªè¯•çš„è¯,å¿…å®šè¶…æ—¶.è€ƒè™‘ä¸¤ç§æ–¹å¼:äºŒåˆ†æ³•å’Œç‰›é¡¿æ³•.é«˜ç²¾åº¦ç”¨ä¸äº†ç‰›é¡¿æ³•å†µä¸”æˆ‘ä¹Ÿä¸ä¼š,ä½¿ç”¨äºŒåˆ†æ³•,å¤æ‚åº¦ä¸º$O(logN)$.å¯¹äºä¹˜æ³• æ™®é€šçš„æ¨¡æ‹Ÿ$O(N^2)$. åˆ†æ²»ä¹˜æ³•ï¼šæœ€ç®€å•çš„æ˜¯$Karatsuba$ä¹˜æ³•ï¼Œä¸€èˆ¬åŒ–ä»¥åæœ‰$Toom-Cook$ä¹˜æ³•ï¼› å¿«é€Ÿå‚…é‡Œå¶å˜æ¢$FFT$ï¼šï¼ˆä¸ºäº†é¿å…ç²¾åº¦é—®é¢˜ï¼Œå¯ä»¥æ”¹ç”¨å¿«é€Ÿæ•°è®ºå˜æ¢$FNTT$ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦$O(N lgN lglgN)$ã€‚å‚ç…§$SchÃ¶nhageâ€“Strassen algorithm$å’Œ$FÃ¼rerâ€™s algorithm$ ä¸­å›½å‰©ä½™å®šç†ï¼šæŠŠæ¯ä¸ªæ•°åˆ†è§£åˆ°ä¸€äº›äº’ç´ çš„æ¨¡ä¸Šï¼Œç„¶åæ¯ä¸ªåŒä½™æ–¹ç¨‹å¯¹åº”ä¹˜èµ·æ¥å°±è¡Œ ä¸¤è€…ç»“åˆå³å¯è§£å†³é—®é¢˜.$fft$çš„è¯å¯ä»¥çœ‹ä¸€ä¸‹$hdu1402$$java$$AC$å,$c/c++$è¿˜åœ¨æ•²ä»£ç .]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>é«˜ç²¾åº¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ†å—1-9(æœªå®Œ)]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%88%86%E5%9D%971-9-%E6%9C%AA%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[åºæ„Ÿè°¢@hzwerå¤§ä½¬å‡ºçš„ç»ƒä¹ é¢˜é¢˜ç›®é“¾æ¥LOJæœ¬è’Ÿè¿‡å¼±,å®åœ¨ä¸çŸ¥é“æ€ä¹ˆå‹ç¼©ä»£ç é‡äº†-&gt;_-&gt; æ•°åˆ—åˆ†å—å…¥é—¨ 1ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´åŠ æ³•ï¼Œå•ç‚¹æŸ¥å€¼ã€‚ å°†$n$ä¸ªæ•°,æŒ‰ç…§æ¯$\sqrt{n}$ä¸ºä¸€ä¸ªå—æ ‡è®°. 123belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x];start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x];end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x]; æ¯æ¬¡å¯¹æ‰€ç»™çš„$[l,r]$åŒºé—´è¿›è¡Œè®¨è®º,åˆ†ä¸ºâ€å•è¹¦â€å’Œâ€å—â€,å¯¹äºä¸æ»¡å—çš„æ•°,ç›´æ¥æš´åŠ›ä¿®æ”¹.å¯¹äºæ»¡è¶³å—çš„æ•°,ç›´æ¥æ‰“ä¸€ä¸ªæ ‡è®°,å½“è®¿é—®çš„æ—¶å€™å†è¿›è¡Œä¿®æ”¹å³å¯,ç±»ä¼¼äºçº¿æ®µæ ‘$lazy$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x];start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x];end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x];*/const int MAXN = 1e5 + 10;int belong[MAXN], tot = 1, a[MAXN], n, cnt;struct block &#123; int lazy; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // cin &gt;&gt; a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); // cin &gt;&gt; opt&gt;&gt; l &gt;&gt; r &gt;&gt; c; if (opt) cout &lt;&lt; p[belong[r]].lazy + a[r] &lt;&lt; endl; else &#123; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) a[j] += c; &#125; &#125; return 0;&#125; æ•°åˆ—åˆ†å—å…¥é—¨ 2ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´åŠ æ³•ï¼Œè¯¢é—®åŒºé—´å†…å°äºæŸä¸ªå€¼ $x$ çš„å…ƒç´ ä¸ªæ•°ã€‚ åŒºé—´åŠ æ³•ä»¿ç…§$1$å³å¯.å¯¹äºæ¯ä¸€ä¸ªå—å†…çš„æ•°æ®,ä¸ºäº†æ–¹ä¾¿æŸ¥è¯¢,æˆ‘ä»¬åˆ†ä¾¿å¯¹æ¯ä¸€ä¸ªå—å†…çš„æ•°æ®è¿›è¡Œæ’åº.å¯¹äºä¸æ»¡è¶³å—çš„æ•°æ®,æˆ‘ä»¬æš´åŠ›å¤„ç†,å†å°†è¿™ä¸ªå—å†…çš„æ•°æ®æ’åº,æ»¡è¶³å—çš„åŒºé—´,æˆ‘ä»¬ä¾ç„¶æ˜¯æ‰“æ ‡è®°å³å¯.æŸ¥è¯¢çš„æ—¶å€™,äºŒåˆ†æŸ¥æ‰¾å³å¯. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int MAXN = 1e5 + 10;/*belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x];start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x];end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN],b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for(int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //åœ¨å³è¾¹å­åºåˆ—ä¸­æŸ¥æ‰¾ &#125; else len = half; //åœ¨å·¦è¾¹å­åºåˆ—ï¼ˆåŒ…å«middleï¼‰ä¸­æŸ¥æ‰¾ &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[i]=a[i]; belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = 0; c *= c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans += lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; if (p[belong[r]].end == r) ans += lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans += lowerbound(b + p[j].start, p[j].end - p[j].start + 1, c, p[j].lazy); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans += lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; æ•°åˆ—åˆ†å—å…¥é—¨ 3ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´åŠ æ³•ï¼Œè¯¢é—®åŒºé—´å†…å°äºæŸä¸ªå€¼ $x$ çš„å‰é©±ï¼ˆæ¯”å…¶å°çš„æœ€å¤§å…ƒç´ ï¼‰ã€‚ å’Œ$2$ç±»ä¼¼. å‡ºé¢˜äººçš„æƒ³æ³•:å¯ä»¥åœ¨å—å†…ç»´æŠ¤å…¶å®ƒç»“æ„ä½¿å…¶æ›´å…·æœ‰æ‹“å±•æ€§ï¼Œæ¯”å¦‚æ”¾ä¸€ä¸ª set ï¼Œè¿™æ ·å¦‚æœè¿˜æœ‰æ’å…¥ã€åˆ é™¤å…ƒç´ çš„æ“ä½œï¼Œä¼šæ›´åŠ çš„æ–¹ä¾¿ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const int MAXN = 1e5 + 10;/*belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x];start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x];end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x];*/int belong[MAXN], tot = 1, n, cnt, a[MAXN], b[MAXN];struct block &#123; int lazy; int start, end;&#125; p[MAXN];void rechange(int l, int r)&#123; for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;int lowerbound(int *array, int size, int key, int lazy) &#123; int first = 0, middle; int half, len; len = size; while (len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if (array[middle] + lazy &lt; key) &#123; first = middle + 1; len = len - half - 1; //åœ¨å³è¾¹å­åºåˆ—ä¸­æŸ¥æ‰¾ &#125; else len = half; //åœ¨å·¦è¾¹å­åºåˆ—ï¼ˆåŒ…å«middleï¼‰ä¸­æŸ¥æ‰¾ &#125; return first;&#125;int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; //cin &gt;&gt; a[i];//scanf("%d", &amp;a[i]); belong[i] = tot; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt; tot; i++) sort(b + p[i].start, b + p[i].end + 1); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r, c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; int ans = -1; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) &#123; int t = lowerbound(b + l, p[belong[l]].end - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[p[belong[l]].start+t-1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= p[belong[l]].end; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); if (p[belong[r]].end == r) &#123; int t = lowerbound(b + p[belong[r]].start, r - p[belong[r]].start + 1, c, p[belong[r]].lazy); if (t) ans = max(ans, b[p[belong[r]].start + t - 1] + p[belong[r]].lazy); &#125; else for (int j = p[belong[r]].start; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); for (int j = belong[l] + 1; j &lt; belong[r]; j++) &#123; int t = lowerbound(b + p[j].start, p[j].end- p[j].start + 1, c, p[j].lazy); if (t) ans = max(ans, b[p[j].start + t - 1] + p[j].lazy); &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) &#123; int t = lowerbound(b + l, r - l + 1, c, p[belong[l]].lazy); if (t) ans = max(ans, b[l + t - 1] + p[belong[l]].lazy); &#125; else for (int j = l; j &lt;= r; j++) if (a[j] + p[belong[j]].lazy &lt; c) ans = max(ans, a[j] + p[belong[j]].lazy); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= p[belong[l]].end; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else &#123; for (int j = p[belong[r]].start; j &lt;= r; j++) a[j] += c; rechange(p[belong[r]].start, p[belong[r]].end); &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else &#123; for (int j = l; j &lt;= r; j++) a[j] += c; rechange(p[belong[l]].start, p[belong[l]].end); &#125; &#125; return 0;&#125; æ•°åˆ—åˆ†å—å…¥é—¨ 4ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´åŠ æ³•ï¼ŒåŒºé—´æ±‚å’Œã€‚ æ±‚å’Œé¢„å¤„ç†ä¸€ä¸‹å°±é˜”ä»¥äº†,æ‰“æ ‡è®°çš„æ—¶å€™æ˜¯é•¿åº¦$*$åŠ æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495typedef long long ll;const int MAXN = 1e5 + 10;/*belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x];start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x];end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x];*/ll cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; ll lazy; ll sum; int start, end;&#125; p[MAXN];int main() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; //scanf("%d", &amp;a[i]); belong[i] = tot; p[tot].sum += a[i]; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125; for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; ll c; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;// scanf("%d %d %d %d", &amp;opt, &amp;l, &amp;r, &amp;c); if (opt) &#123; ll ans = 0; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= p[belong[l]].end; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); if (p[belong[r]].end == r) ans = (ans + (p[belong[r]].lazy*(p[belong[r]].end - p[belong[r]].start + 1)) % (c + 1) + p[belong[r]].sum % (c + 1)) % (c + 1); else for (int j = p[belong[r]].start; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); for (int j = belong[l] + 1; j &lt; belong[r]; j++) ans = (ans + (p[j].lazy*(p[j].end - p[j].start + 1)) % (c + 1) + p[j].sum % (c + 1)) % (c + 1); &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) ans = (ans + (p[belong[l]].lazy*(p[belong[l]].end - p[belong[l]].start + 1)) % (c + 1) + p[belong[l]].sum % (c + 1)) % (c + 1); else for (int j = l; j &lt;= r; j++) ans = (ans + a[j] % (c + 1) + p[belong[j]].lazy % (c + 1)) % (c + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; else if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy += c; else for (int j = l; j &lt;= p[belong[l]].end; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; if (p[belong[r]].end == r) p[belong[r]].lazy += c; else for (int j = p[belong[r]].start; j &lt;= r; j++) &#123; p[belong[r]].sum += c; a[j] += c; &#125; for (int j = belong[l] + 1; j &lt; belong[r]; j++) p[j].lazy += c; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy += c; else for (int j = l; j &lt;= r; j++) &#123; a[j] += c; p[belong[l]].sum += c; &#125; &#125; return 0;&#125; æ•°åˆ—åˆ†å—å…¥é—¨ 5ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ— ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´å¼€æ–¹ï¼ŒåŒºé—´æ±‚å’Œã€‚ è¿™ä¸ªé¢˜ç›®å…¶å®æ¯”è¾ƒæäºº==å¯¹äºä¸€ä¸ªæ•°,å…¶å±äº${-2^{31},2^{31}-1}$,æœ€å¤šå¼€æ–¹ä¸è¶…è¿‡$4$æ¬¡.è¿˜æ˜¯å’Œä¹‹å‰ä¸€æ ·,å•ä¸ªæš´åŠ›,æ•´å—æ ‡è®°.å¯¹äºä¸€ä¸ªå—,å¦‚æœå¼€æ–¹æ¬¡æ•°è¶…è¿‡$4$æ¬¡,æˆ–è€…æ•´ä¸ªå—åªæœ‰$1$æˆ–$0$,æˆ‘ä»¬å°±å¯ä»¥è®¤ä¸ºä¸éœ€è¦å¯¹å…¶å¤„ç†äº†,åªè®°ä¸‹å’Œå³å¯.è‡ªå·±ä»£ç å®ç°çš„æ—¶å€™,æ³¨æ„ç»†èŠ‚. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200typedef long long ll;const int MAXN = 1e5 + 10;/* belong[x]:å…ƒç´ xæ‰€åœ¨çš„å—çš„ç¼–å·ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºbl[x]; start[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å·¦è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºst[x]; end[x]:ç¼–å·ä¸ºxçš„å—çš„æœ€å³è¾¹çš„ç‚¹ï¼Œæ ·ä¾‹ä»£ç ä¸­ä¸ºed[x]; */int cnt, a[MAXN];int belong[MAXN], tot = 1, n;struct block &#123; int lazy; ll sum; int start, end; bool f; block() &#123; lazy = start = end = sum = 0; f = false;&#125;&#125; p[MAXN];void built() &#123; cin &gt;&gt; n; cnt = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; // scanf("%d", &amp;a[i]); belong[i] = tot; if (a[i] != 0) p[tot].sum++; if (i % cnt == 1) p[tot].start = i; if (i % cnt == 0) p[tot++].end = i; &#125; if (n % cnt) &#123; p[tot].start = p[tot - 1].end + 1; p[tot++].end = n; &#125;&#125;void print(int l, int r) &#123; ll ans = 0, c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; if (p[belong[r]].end == r) if (p[belong[r]].lazy &gt; 4 || p[belong[r]].f) ans += p[belong[r]].sum; else &#123; p[belong[r]].f = true; for (int i = p[belong[r]].start; i &lt;= p[belong[r]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[r]].f = false; ans += x; &#125; &#125; else for (int i = p[belong[r]].start; i &lt;= r; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; for (int i = belong[l] + 1; i &lt; belong[r]; i++) if (p[i].lazy &gt; 4 || p[i].f) ans += p[i].sum; else &#123; p[i].f = true; for (int j = p[i].start; j &lt;= p[i].end; j++) &#123; int lazy = p[i].lazy, x = a[j]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[i].f = false; ans += x; &#125; &#125; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) if (p[belong[l]].lazy &gt; 4 || p[belong[l]].f) ans += p[belong[l]].sum; else &#123; p[belong[l]].f = true; for (int i = p[belong[l]].start; i &lt;= p[belong[l]].end; i++) &#123; int lazy = p[belong[r]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; if (x != 1 &amp;&amp; x != 0) p[belong[l]].f = false; ans += x; &#125; &#125; else for (int i = l; i &lt;= r; i++) &#123; int lazy = p[belong[l]].lazy, x = a[i]; while (lazy) &#123; if (x == 0 || x == 1) break; x = sqrt(x); lazy--; &#125; ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125;void update(int l, int r) &#123; ll c; cin &gt;&gt; c; if (belong[l] != belong[r]) &#123; if (p[belong[l]].start == l) p[belong[l]].lazy++; else for (int i = l; i &lt;= p[belong[l]].end; i++) a[i] = sqrt(a[i]); if (p[belong[r]].end == r) p[belong[r]].lazy++; else for (int i = p[belong[r]].start; i &lt;= r; i++) a[i] = sqrt(a[i]); for (int i = belong[l] + 1; i &lt; belong[r]; i++) p[i].lazy++; &#125; else if (p[belong[l]].start == l &amp;&amp; p[belong[r]].end == r) p[belong[l]].lazy++; else for (int i = l; i &lt;= r; i++) a[i] = sqrt(a[i]);&#125;int main() &#123; built(); for (int i = 1; i &lt;= n; i++) &#123; int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; // scanf("%d %d %d %d", // &amp;opt, // &amp;l, &amp;r, &amp;c); if (opt) print(l, r); else update(l, r); &#125; return 0;&#125; æ•°åˆ—åˆ†å—å…¥é—¨ 6ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠå•ç‚¹æ’å…¥ï¼Œå•ç‚¹è¯¢é—®ï¼Œæ•°æ®éšæœºç”Ÿæˆ. åˆ°äº†å–œé—»ä¹è§çš„åŠ¨æ€åˆ†å—äº†$23333$.$c++$çš„$vector$å¤§æ³•å¥½,æˆ‘æ˜¯ä¸ä¼šç”¨æŒ‡é’ˆå†™é“¾è¡¨çš„,æ‹’ç»æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°,å°±æ‰¾åˆ°å¯¹åº”çš„å—,æ‰”è¿›å»å°±è¡Œ.å°†æ’å…¥çš„æ¬¡æ•°è®°ä¸‹æ¥,å½“æ¬¡æ•°è¶…è¿‡$\sqrt n$çš„æ—¶å€™å°±è¿›è¡Œé‡æ„,ä¹Ÿå°±æ˜¯é‡æ–°åˆ†å—.ç„¶åå°±æ²¡æœ‰ç„¶åäº†. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int MAXN = 1e6 + 10;const int INF = 1e8 + 10;const int MOD = 998244353;const int ans = 11;typedef long long ll;int a[MAXN];vector&lt;int&gt;p[MAXN];int n, tot = 0, m, optt;void find(int k)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; cout &lt;&lt; p[i][k] &lt;&lt; '\n'; break; &#125; &#125;&#125;void rebuild()&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; for (int j = 0; j &lt; p[i].size(); j++) a[++num] = p[i][j]; p[i].clear(); &#125; n = num, m = sqrt(n), tot = 0; for (int i = 1; i &lt;= n; i++) &#123; p[tot].push_back(a[i]); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++;&#125;void insert(int k, int x)&#123; int num = 0; for (int i = 0; i &lt; tot; i++) &#123; num += p[i].size(); if (num &gt;= k) &#123; num -= p[i].size(); k = k - num - 1; p[i].insert(p[i].begin() + k, x); optt++; break; &#125; &#125; if (optt == m) &#123; rebuild(); optt = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d",&amp;x); p[tot].push_back(x); if (i%m == 0) tot++; &#125; if (n%m != 0) tot++; int opt, l, r, c, q = n; for (int i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d%d",&amp;opt,&amp;l,&amp;r,&amp;c); if (opt) find(r); else insert(l, r); &#125; return 0;&#125; æœªå®Œå¾…ç»­]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>åˆ†å—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #6.[NOI2014]éšæœºæ•°ç”Ÿæˆå™¨]]></title>
    <url>%2F2019%2F08%2F08%2FUOJ-6%2F</url>
    <content type="text"><![CDATA[åºè¿™ä¸ªé¢˜,éš¾åœ¨é˜…è¯». é¢˜ç›®å¤§æ„è·³è¿‡!é“¾æ¥:ğŸ”— è§£æ é¦–å…ˆæ ¹æ®é¢˜ç›®å¾—åˆ°ä¸€ä¸ªéšæœºæ•°åˆ—$\lbrace x_i=(aÃ—x_{iâˆ’1}^2+bÃ—x_{iâˆ’1}+c)$mod$d\rbrace$å…¶ä¸­$i\in{1â€¦nÃ—m}$ æä¸€ä¸ªæ•°åˆ—$T$,å…¶ä¸­$T_i=i$,$i\in{1â€¦.nÃ—m}$ å¯¹æ¯ä¸€é¡¹$T_i$,æˆ‘ä»¬$swap(T_i,$$T_{x_imodi+1})$ ä»¥ä¸Š$3$æ­¥ç»“æŸå,å¾—åˆ°çš„å°±æ˜¯æ£‹ç›˜è¦å¡«çš„æ•°$T_i$ æ ·ä¾‹ä¸€æ•°æ®ç”Ÿæˆçš„æ£‹ç›˜å¦‚ä¸‹: 12917 51162 41038 &emsp;&emsp;è·¯çº¿ä¾¿æ˜¯$12-&gt;9-&gt;1-&gt;6-&gt;2-&gt;8$&emsp;&emsp;ä¸€ä¸ªæœ‰æŠ€å·§çš„è´ªå¿ƒæ¥é€‰æ•°.&emsp;&emsp;é¦–å…ˆ,$map[1][1]$å¿…å®šé€‰.&emsp;&emsp;å¦‚æœæˆ‘ä»¬ä¸è€ƒè™‘æ£‹ç›˜é¡ºåº,è‹¥è¦åºåˆ—æœ€å°,æ˜¾ç„¶æ˜¯é€‰æœ€å°æ•°çš„æ”¾è¿›å»,é‚£ä¹ˆæˆ‘ä»¬ä¾¿ä»$1$è¿™ä¸ªæ•°å¼€å§‹è´ªå¿ƒ.é‚£ä¹ˆ,è¿™ä¸ªæ•°æˆ‘ä»¬ä»€ä¹ˆæ—¶å€™æ‰å–å®ƒå‘¢?&emsp;&emsp;æ ¹æ®é¢˜ç›®è¦æ±‚,æˆ‘ä»¬ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’,åªèƒ½å‘å³æˆ–è€…å‘ä¸‹èµ°,åªè¦é€‰è¿‡çš„æ•°åœ¨è¦é€‰çš„æ•°å·¦ä¸Šæ–¹æˆ–å³ä¸‹æ–¹çš„æ—¶å€™,è¿™ä¸ªæ•°æ‰æ˜¯å¯é€‰çš„,æˆ–è€…è¯´æ˜¯å¯åˆ°è¾¾çš„.&emsp;&emsp;å‡è®¾å½“æˆ‘ä»¬è¦é€‰$9$æ—¶,æˆ‘ä»¬å·²ç»é€‰äº†$1,2,6,8,12$,æˆ‘ä»¬çœ‹$9$èƒ½å¦åˆ°è¾¾å‘¢?&emsp;&emsp;æ˜¾ç„¶,å·¦ä¾§ç¦»å®ƒæœ€è¿‘çš„æ•°è¦$\ge$å®ƒçš„è¡Œ,å³ä¾§ç¦»å®ƒæœ€è¿‘çš„æ•°è¦$\leq$å®ƒçš„è¡Œ.è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€‰å®ƒ.&emsp;&emsp;å½“ç„¶,é€‰å®Œåæ›´æ–°$L[],R[]$. å³ä»£ç : 123456789101112//xä¸ºè¡Œ,yä¸ºåˆ—//nè¡Œ,måˆ—for (int i = 1; i &lt;= n; i++) L[i] = 1 ,R[i] = m;for (int i = 1; i &lt;= n * m; i++)&#123; L[x] &lt;= y &amp;&amp; y &lt;= R[x] for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y);&#125; &emsp;&emsp;ç†è§£äº†è¿™ä¸ªè´ªå¿ƒ,é¢˜ç›®å°±å¾ˆæ°´äº†.&emsp;&emsp;æ®è¯´è¦æ³¨æ„ç©ºé—´,æ—¶é—´â€¦..å…¨ç¨‹cinå¥½åƒæ²¡å•¥äº‹. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 1e7;const int MAXN = 5e3 + 10;int T[MAXN * MAXN], l[MAXN * MAXN], R[MAXN], L[MAXN];int main()&#123; int a, b, c, d; int n, m, q; cin &gt;&gt; l[0] &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= m * n; i++) T[i] = i, l[i] = (1LL * a * l[i - 1] * l[i - 1] + 1LL * b * l[i - 1] + c) % d; for (int i = 1; i &lt;= n * m; i++) swap(T[i], T[l[i] % i + 1]); int x, y; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; x &gt;&gt; y; swap(T[x], T[y]); &#125; for (int i = 1; i &lt;= n * m; i++) l[T[i]] = i; for (int i = 1; i &lt;= n; i++) R[i] = m, L[i] = 1; for (int i = 1, sum = 0; i &lt;= n * m; i++) &#123; x = (l[i] - 1) / m + 1, y = l[i] % m ? l[i] % m : m; if (L[x] &lt;= y &amp;&amp; y &lt;= R[x]) &#123; cout &lt;&lt; i &lt;&lt; ' '; sum++; if (sum == n * m - 1) break; for (int j = 1; j &lt; x; j++) R[j] = min(R[j], y); for (int j = n; j &gt; x; j--) L[j] = max(L[j], y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJç»ƒä¹ è®°å½•</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>æ¨¡æ‹Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é‚£äº›å¹´æˆ‘æ­åšå®¢æ‰€è¸©çš„å‘]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E6%90%AD%E5%8D%9A%E5%AE%A2%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[ä¸€.åšæ–‡æ’å…¥å›¾ç‰‡åœ¨ Hexoä¸­ æ’å…¥å›¾ç‰‡æ—¶ï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹çš„æ­¥éª¤è¿›è¡Œè®¾ç½® å°† ç«™ç‚¹é…ç½®æ–‡ä»¶ ä¸­çš„ post_asset_folde é€‰é¡¹çš„å€¼è®¾ç½®ä¸º true åœ¨ç«™ç‚¹æ–‡ä»¶å¤¹ä¸­æ‰“å¼€ git bashï¼Œè¾“å…¥å‘½ä»¤ npm install hexo-asset-image --save å®‰è£…æ’ä»¶ è¿™æ ·ï¼Œå½“ä½¿ç”¨ hexo new title åˆ›å»ºæ–‡ç« æ—¶ï¼Œå°†åŒæ—¶åœ¨ source/_post æ–‡ä»¶å¤¹ä¸­ç”Ÿæˆä¸€ä¸ªä¸ title åŒåçš„æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬åªéœ€å°†å›¾ç‰‡æ”¾è¿›æ­¤æ–‡ä»¶å¤¹ä¸­ï¼Œç„¶ååœ¨æ–‡ç« ä¸­é€šè¿‡ Markdown è¯­æ³•è¿›è¡Œå¼•ç”¨å³å¯ ä¾‹å¦‚ï¼Œåœ¨èµ„æºæ–‡ä»¶å¤¹ï¼ˆå°±æ˜¯é‚£ä¸ªä¸ title åŒåçš„æ–‡ä»¶å¤¹ï¼‰ä¸­æ·»åŠ å›¾ç‰‡ example.PNGï¼Œåˆ™å¯ä»¥åœ¨å¯¹åº”çš„æ–‡ç« ä¸­ä½¿ç”¨è¯­å¥ ![ç¤ºä¾‹å›¾ç‰‡](title/example.PNG &quot;ç¤ºä¾‹å›¾ç‰‡&quot;) æ·»åŠ å›¾ç‰‡ äºŒ.ä¿®æ”¹åšå®¢æ ‡é¢˜èƒŒæ™¯å¦‚æœä½ ä½¿ç”¨çš„æ˜¯piscesæ¨¡å¼çš„è¯,å¯ä»¥å‚è€ƒä¸‹åˆ—æ•™ç¨‹åœ¨\blog\themes\next\source\css\_schemes\Piscesä¸­çš„_brand.stylæ–‡ä»¶å†….åœ¨.site-meta ä¸‹çš„backgroundåé¢ä¿®æ”¹ä¸ºurl(å›¾ç‰‡é“¾æ¥); ä¸‰.æ’å…¥éŸ³ä¹åœ¨ç½‘æ˜“äº‘éŸ³ä¹ç”Ÿæˆå¤–é“¾åæ’å…¥åˆ°ä½ æƒ³æ”¾çš„åœ°æ–¹å³å¯.æ³¨æ„:ä¸è¦æ‰“å¼€â€é˜»æ­¢ç¬¬ä¸‰æ–¹ Cookieâ€è¿™ä¸ªé€‰é¡¹ä¸€æ—¦æ‰“å¼€,iframeå°±åŠ è½½ä¸å‡ºæ¥,æ’å…¥éŸ³ä¹é‚£ä¸€å—å…¨ç™½.ç½‘ä¸Šä¹Ÿæ²¡æœ‰å¤šå°‘äººç»å†è¿‡ä¼°è®¡(é€¼ç€æˆ‘å­¦ä¼šäº†çœ‹F12â€¦) å››.npmä¸‹è½½è¶…æ…¢çš„é—®é¢˜ä½¿ç”¨cnpm,è¿™æ˜¯å›½å†…çš„ä¸€ä¸ªé•œåƒ,é€Ÿåº¦å¾ˆå¿«,ä½†æ— æ³•ä½¿ç”¨publishé“¾æ¥:https://npm.taobao.org/ äº”.Algoliaæœç´¢æ­å»ºçš„é—®é¢˜nextçš„ä½¿ç”¨æ–‡æ¡£å·²ç»æ¯”è¾ƒå…¨é¢äº† è¿™ä¸ªåœ°æ–¹è¦åŠ ä¸€å¥ 12345algolia: applicationID: 'applicationID' indexName: 'indexName' apiKey: 'Search-Only API Key' chunkSize: 5000 å…¶æ¬¡ç”¨export,æœ€å¥½ä¸è¦ç”¨set 12export HEXO_ALGOLIA_INDEXING_KEY=ä½ çš„Search-Only API Key$ hexo algolia è¿™äº›éƒ½é€‰ä¸Š å…­.å¤´åƒæ—‹è½¬ä»¥åŠç‚¹å‡»å¤´åƒå›åˆ°ä¸»é¡µ å›åˆ°ä¸»é¡µ:åœ¨123456```html&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt; å°±æ˜¯åœ¨ä»£ç ä¸Šä¸‹åˆ†åˆ«åŠ äº†href1232. æ—‹è½¬~~è¿™ä¸ªæˆ‘ä¹Ÿä¸æ‡‚~~```\themes\next\source\css\_common\components\sidebar\sidebar-author.styl å†…æ·»åŠ : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* å¤´åƒåœ†å½¢ */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* è®¾ç½®å¾ªç¯åŠ¨ç”» [animation: (play)åŠ¨ç”»åç§° (2s)åŠ¨ç”»æ’­æ”¾æ—¶é•¿å•ä½ç§’æˆ–å¾®ç§’ (ase-out)åŠ¨ç”»æ’­æ”¾çš„é€Ÿåº¦æ›²çº¿ä¸ºä»¥ä½é€Ÿç»“æŸ (1s)ç­‰å¾…1ç§’ç„¶åå¼€å§‹åŠ¨ç”» (1)åŠ¨ç”»æ’­æ”¾æ¬¡æ•°(infiniteä¸ºå¾ªç¯æ’­æ”¾) ]*/ /* é¼ æ ‡ç»è¿‡å¤´åƒæ—‹è½¬360åº¦ */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* é¼ æ ‡ç»è¿‡åœæ­¢å¤´åƒæ—‹è½¬ -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* é¼ æ ‡ç»è¿‡å¤´åƒæ—‹è½¬360åº¦ */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z è½´æ—‹è½¬åŠ¨ç”» */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; æ­å»ºè¯„è®ºåŒº å¤šè¯´ ç½‘æ˜“äº‘è·Ÿå¸– ç•…è¨€ æ¥å¿…åŠ›ï¼ˆLiveReï¼‰ Disqus Hypercomments valinevaline YES!( â€¢Ì€ Ï‰ â€¢Ì )yè™½ç„¶å›½å†…ç‰ˆéœ€è¦å¤‡æ¡ˆ,ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å›½é™…ç‰ˆçš„ğŸ”— æ³¨å†Œ éªŒè¯é‚®ç®±å’Œæ‰‹æœºå· åˆ›å»ºä¸€ä¸ªåº”ç”¨ï¼Œåå­—å¯ä»¥éšä¾¿èµ· è¿›å…¥åº”ç”¨-&gt;è®¾ç½®-&gt;åº”ç”¨$key$ å¤åˆ¶ $appid$ å’Œ $appkey$ è¿›å…¥ä¸»é¢˜é…ç½®æ–‡ä»¶æœç´¢ $valine$ 12345678910valine: enable: ç”±falseæ”¹æˆtrue app_id: è¦å¡« app_key: è¦å¡« notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: å¯æ”¹ avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size åœ¨Leancloud -&gt; è®¾ç½® -&gt; å®‰å…¨ä¸­å¿ƒ -&gt; Web å®‰å…¨åŸŸå æŠŠä½ çš„åŸŸååŠ è¿›å»$d$ä¸€ä¸‹å®Œæˆ. å…ˆè¿™äº›,æŒç»­æ›´æ–°]]></content>
      <categories>
        <category>æ‚æ–‡</category>
      </categories>
      <tags>
        <tag>åšå®¢æ­å»º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMPç®—æ³•æ¨¡æ¿]]></title>
    <url>%2F2019%2F08%2F07%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[è’Ÿè’»å­¦è¯†æµ…é™‹,æ¬¢è¿å„ä½å¤§ç‰›æŒ‡æ­£ KMPä»å…¥é—¨åˆ°æ”¾å¼ƒè¯·è§‚å·¦ç¥ä¸ºä»€ä¹ˆæƒ³è¦æ€äºº%%%%njb7ç€é‡å¬1h12m20s$KMP$åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†,ä¸€éƒ¨åˆ†ä¸ºä¸¤ä¸ªå­—ç¬¦ä¸²é—´çš„æ¯”è¾ƒ,å¦ä¸€éƒ¨åˆ†ä¸ºè‡ªå·±ä¸è‡ªå·±çš„æ¯”è¾ƒ.ç®€å•çš„åˆ’åˆ†ä¸ºä¸‹é¢ä¸¤ä¸ªå›¾,è¯¦ç»†ç†è§£è¯·è§å·¦ç¥ä¸ç¨³å®šæƒ…ç»ªè®²è§£.ä¸è¿‡æˆ‘$jiao$çš„åœ¨$1:21:04$æ—¶,å°†ä¾‹å­æ¢ä¸º$â€ababcababakâ€$æ›´å¥½ç†è§£ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;char t[1000100],s[1000100];int len1, len2,n[1000100];void KMP(char *s,char *t)&#123; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; cout &lt;&lt; i - len2 + 2 &lt;&lt; endl; j = n[j]; &#125; &#125;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; cin &gt;&gt; s &gt;&gt; t; len1 = strlen(s); len2 = strlen(t); getnext(t); KMP(s, t); for (int i = 0; i &lt; len2; i++) cout &lt;&lt; n[i]+1 &lt;&lt; ' '; return 0;&#125; ä¾‹é¢˜G.OulipoHDU 1686The French author Georges Perec (1936â€“1982) once wrote a book, La disparition, without the letter â€˜eâ€™. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout sâ€™affirmait faux. Tout avait Fair normal, dâ€™abord, puis surgissait lâ€™inhumain, lâ€™affolant. Il aurait voulu savoir oÃ¹ sâ€™articulait lâ€™association qui lâ€™unissait au roman : stir son tapis, assaillant Ã  tout instant son imagination, lâ€™intuition dâ€™un tabou, la vision dâ€™un mal obscur, dâ€™un quoi vacant, dâ€™un non-dit : la vision, lâ€™avision dâ€™un oubli commandant tout, oÃ¹ sâ€™abolissait la raison : tout avait lâ€™air normal maisâ€¦ Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given â€œwordâ€ as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of $500000$ consecutive $â€™Tâ€™$s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet ${â€˜Aâ€™, â€˜Bâ€™, â€˜Câ€™, â€¦, â€˜Zâ€™}$ and two finite strings over that alphabet, a word $W$ and a text $T$, count the number of occurrences of $W$ in $T$. All the consecutive characters of $W$ must exactly match consecutive characters of $T$. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over ${â€˜Aâ€™, â€˜Bâ€™, â€˜Câ€™, â€¦, â€˜Zâ€™}$, with $1 â‰¤ |W| â‰¤ 10000$ (here $|W|$ denotes the length of the string $W$).One line with the text T, a string over ${â€˜Aâ€™, â€˜Bâ€™, â€˜Câ€™, â€¦, â€˜Zâ€™}$, with $|W| â‰¤ |T| â‰¤ 1000000$. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.Sample Input3$BAPC$$BAPC$$AZA$$AZAZAZA$$VERDI$$AVERDXIVYERDIAN$Sample Output130 è§£æ$kmp$æ¨¡æ¿,è¯»å…¥ä¸èƒ½ç”¨$cin$,å¦åˆ™è¶…æ—¶ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef long long ll;char t[1000100], s[1000100];int len1, len2, n[1000100];ll read()&#123; ll f = 1,x = 0; char s = getchar(); while (s&lt;'0' || s&gt;'9') &#123; if (s == '-') f = -1; s = getchar(); &#125; while (s &gt;= '0'&amp;&amp;s &lt;= '9') &#123; x = x * 10 + s - '0'; s = getchar(); &#125; x *= f; return x;&#125;int KMP(char *s, char *t)&#123; int ans = 0; for (int i = 0, j = -1; i &lt; len1; i++) &#123; while (j != -1 &amp;&amp; t[j + 1] != s[i]) j = n[j]; if (t[j + 1] == s[i]) j++; if (j == len2 - 1) &#123; ans++; j = n[j]; &#125; &#125; return ans;&#125;void getnext(char *t)&#123; n[0] = -1; for (int i = 1, j = -1; i &lt; len2; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j + 1]) j = n[j]; if (t[i] == t[j + 1]) j++; n[i] = j; &#125;&#125;int main()&#123; int m; m = read(); while (m--) &#123; memset(n, 0, sizeof(n)); scanf("%s %s", &amp;t, &amp;s); len1 = strlen(s); len2 = strlen(t); getnext(t); cout&lt;&lt;KMP(s, t)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #5.[NOI2014]åŠ¨ç‰©å›­]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-5%2F</url>
    <content type="text"><![CDATA[åºè¨€&emsp;&emsp;è¿™ä¸ªé¢˜å†™çš„æˆ‘å¥½è¿·å•Š== é¢˜ç›®ç®€è¿°&emsp;&emsp;å›­é•¿æƒ³è®©ä½ æ±‚ä¸€ä¸ªå­—ç¬¦ä¸²çš„â€ä¸äº’ç›¸é‡å çš„å…¬å…±å‰åç¼€ä¸ªæ•°â€ç„¶åå†ä¹˜èµ·æ¥.ä¸€å¤§éª¡å­çš„å­—,æ€»ç»“ä¸€ä¸‹å°±æ˜¯è¿™ä¸ªæ„æ€. è§£æ&emsp;&emsp;å¦‚æœä½ ä¸ä¼š$KMP$â€¦.é‚£æˆ‘ä¹Ÿæ²¡åŠæ³•(ç¬‘)&emsp;&emsp;æˆ‘ä»¬çŸ¥é“,$next$ä¿å­˜çš„æ˜¯æœ‰é‡å éƒ¨åˆ†çš„æœ€å¤§é•¿åº¦.é‚£ä¹ˆæˆ‘ä»¬åœ¨å®ƒè®¡ç®—çš„è¿‡ç¨‹ä¸­,æŠŠå½“å‰$next[i]$çš„ä½ç½®,å­˜ä¸€ä¸ªé•¿åº¦$cnt[i]$,å•¥æ„æ€?&emsp;&emsp;æˆ‘$next[i]$ä»å¤´æ‰«åˆ°å°¾,ç›¸å½“äºä¸€ä¸ªé€’æ¨å¾—åˆ°æœ€å¤§é•¿åº¦.åŒæ—¶è¿›è¡Œ$cnt[i]$ä»å¤´æ‰«åˆ°å°¾,ç›¸å½“äºé€’æ¨å¾—åˆ°æœ€å¤§ä¸ªæ•°.&emsp;&emsp;ç„¶åå†ç”¨$next[]$æ•°ç»„,æ‰¾åˆ°ä¸é‡å¤çš„ä½ç½®,ä¹Ÿå°±æ˜¯$j\leq{i/2}$è¿™æ ·çš„ä½ç½®,è®¡ç®—$cnt$,å®Œæˆ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e6 + 10;int n[MAXN],len,f[MAXN];char t[MAXN];void getnext(char *t)&#123; n[0] = 0,n[1]=1; f[0] = -1, f[1] = 0; for (int i = 1, j = 0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; ++j; f[i + 1] = j; n[i+1] = n[j]+1; &#125;&#125;const int mod = 1e9 + 7;int main() &#123; int k; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; t; len = strlen(t); getnext(t); ll ans = 1; for (int i = 1,j=0; i &lt; len; i++) &#123; while (j != -1 &amp;&amp; t[i] != t[j]) j = f[j]; j++; while (j * 2 &gt; i + 1) j = f[j]; ans = ans * (ll)(n[j] + 1)%mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>UOJç»ƒä¹ è®°å½•</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ’åˆ†æ ‘]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%88%92%E5%88%86%E6%A0%91%2F</url>
    <content type="text"><![CDATA[å¼•å¦‚é¢˜:POJ2014ç»™å®šä¸€$n$ä¸ªå…ƒç´ çš„æ•°ç»„,æ¯æ¬¡æŸ¥è¯¢$[l,r]$åŒºé—´å†…ä»å°åˆ°å¤§ç¬¬kä¸ªæ•°.æœ´ç´ è§£æ³•ä¸ºå°†æ•°ç»„$[l,r]$å†…çš„æ•°æ’åº,ç„¶åé€‰æ‹©ç¬¬$k$ä¸ªå³å¯.æœ€åæƒ…å†µ$O(m*n)$.è¿™ä¸ªæ—¶å€™,å°±éœ€è¦æ›´å¥½çš„æ•°æ®ç»“æ„,åˆ’åˆ†æ ‘/å½’å¹¶æ ‘. å®šä¹‰åŸæ•°ç»„ä¸º${4,2,5,7,1,8,3,6}$,åœ¨æ¯æ¬¡åˆ’åˆ†å·¦å³å­æ ‘æ—¶çš„ä¸­å€¼,éƒ½ç”¨çº¢è‰²è¡¨æ˜.å°äºä¸­å€¼çš„è¿›å…¥å·¦å­æ ‘,å¤§äºä¸­å€¼çš„è¿›å…¥å³å­æ ‘.è§‚å¯Ÿæˆ‘ä»¬å‘ç°,æ¯ä¸€å±‚éƒ½æ˜¯æ•°ç»„$n$,åªä¸è¿‡é¡ºåºæœ‰äº†å˜åŒ–.è€Œå¯¹äº$log2(1e9)$è¿™ä¸ªæ•°,ä¹Ÿä¸è¿‡$20$.æ‰€ä»¥æˆ‘ä»¬å®šä¹‰ä¸€ä¸ª$tree[20][n]$çš„æ•°ç»„,ç”¨æ¥å­˜æ ‘. 12//toleftç¨åå†è®²int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN]; å»ºæ ‘æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ•°ç»„$toleft[20][MAXN]$,å…¶æŒ‡åœ¨æŸæ•°çš„å·¦è¾¹æ‰€æœ‰è¿›å…¥å·¦å­æ ‘çš„æ•°çš„ä¸ªæ•°.toleftæ•°ç»„ 123456789101112ç¬¬ä¸€æ¬¡åˆ’åˆ†[4,2,5,7,1,8,3,6][1,2,2,2,3,3,4,4] çœ‹i-thå‰é¢æœ‰å¤šå°‘ä¸ªæ•°è¿›å…¥å·¦å­æ ‘.ç¬¬äºŒæ¬¡åˆ’åˆ†[4,2,1,3] [5,7,8,6][0,1,2,2] [1,1,1,2]ç¬¬ä¸‰æ¬¡åˆ’åˆ†[2,1][4,3][5,6][7,8][0,1][0,1][1,1][1,1]ç¬¬å››æ¬¡åˆ’åˆ†[1][2][3][4][5][6][7][8][0][0][0][0][0][0][0][0] 1234567891011121314151617181920212223void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) //sameå€¼æŒ‡ç›¸åŒçš„ä¸­å€¼ if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; //å°†[l,r]å†…çš„æ•°åˆ’åˆ† if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; //è®°ä¸‹å½“å‰æ•°çš„toleftå€¼ &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125; æŸ¥è¯¢ç±»ä¼¼äºçº¿æ®µæ ‘çš„å•ç‚¹æŸ¥è¯¢åªéœ€è¦è€ƒè™‘ä¸€ä¸ªä¸ç­‰å¼$toleft[dep][r] - toleft[dep][l - 1]\leq k$å¦‚æœæˆç«‹,è¯´æ˜è¿™ä¸ªæ•°è¢«åˆ’è¿›äº†å·¦å­æ ‘.é‚£ä¹ˆå¤§åŒºé—´$[L,(L+R)&gt;&gt;1]$,å°åŒºé—´$[l,r]$å˜ä¸º$$[L + toleft[dep][l - 1] - toleft[dep][L - 1],newl + cnt - 1]$$å¦‚æœ$$toleft[dep][r] - toleft[dep][l - 1]&lt;k$$é‚£ä¹ˆ,è¿™ä¸ªæ•°å°±è¢«åˆ’è¿›äº†å³å­æ ‘,é‚£ä¹ˆå¤§åŒºé—´å˜ä¸º$[(L+R)&gt;&gt;1+1,R]$,å°åŒºé—´å˜ä¸º$$[newr - (r - l - cnt),r + toleft[dep][R] - toleft[dep][r]]$$.è¿™æ ·ä¸æ–­é€’å½’,å½“å°åŒºé—´$l==r$æ—¶,ä¾¿ç¡®å®šäº†ä»å°åˆ°å¤§ç¬¬$k$ä¸ªæ•°æ˜¯å‡ . 1234567891011121314151617int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125; å®Œæ•´ä»£ç å½“æƒ³æŸ¥è¯¢ä»å¤§åˆ°å°ç¬¬$k$ä¸ªæ•°,åˆ™å°†(tree[dep][i] < sorted[mid])```æ”¹ä¸º```if (tree[dep][i] > sorted[mid])```,```sort(sorted + 1, sorted + n + 1);```æ”¹ä¸ºä»å¤§åˆ°å°æ’åºå³å¯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 1e5 + 10;int tree[20][MAXN], sorted[MAXN], toleft[20][MAXN];void built(int l, int r, int dep)&#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1, same = mid - l + 1; for (int i = l; i &lt;= r; i++) if (tree[dep][i] &lt; sorted[mid]) same--; int lpos = l, rpos = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (tree[dep][i] &lt; sorted[mid]) tree[dep + 1][lpos++] = tree[dep][i]; else if (tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep + 1][lpos++] = tree[dep][i]; same--; &#125; else tree[dep + 1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l - 1] + lpos - l; &#125; built(l, mid, dep + 1); built(mid + 1, r, dep + 1);&#125;int query(int L, int R, int l, int r, int dep, int k)&#123; if (l == r) return tree[dep][l]; int mid = (L + R) &gt;&gt; 1; int cnt = toleft[dep][r] - toleft[dep][l - 1]; if (cnt &gt;= k) &#123; int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1]; int newr = newl + cnt - 1; return query(L, mid, newl, newr, dep + 1, k); &#125; else &#123; int newr = r + toleft[dep][R] - toleft[dep][r]; int newl = newr - (r - l - cnt); return query(mid + 1, R, newl, newr, dep + 1, k - cnt); &#125;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[0][i]; sorted[i] = tree[0][i]; &#125; sort(sorted + 1, sorted + n + 1); built(1, n, 0); int s, t, k; while (m--) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; cout &lt;&lt; query(1, n, s, t, 0, k) &lt;&lt; endl; &#125; &#125; return 0;&#125; ç»ƒä¹ é¢˜ç›®æ´›è°·P2048]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>åˆ’åˆ†æ ‘</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çº¿æ®µæ ‘]]></title>
    <url>%2F2019%2F08%2F07%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[æ¬¢è¿å„å¤§ä½¬ï¼Œå¤§ç‰›å¯¹æœ¬æ–‡æŒ‡æ­£ï¼Œä¹Ÿå¸Œæœ›æœ¬æ–‡èƒ½å¯¹å„ä½æœ‰æ‰€å¸®åŠ© æœ¬ç¯‡å¾ˆå¤šåœ°æ–¹å€Ÿé‰´è‹±é›„å“ªé‡Œå‡ºæ¥çš„åšå®¢%%% ä¸€ã€åŸºæœ¬æ¦‚å¿µ çº¿æ®µæ ‘æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå®ƒå‚¨å­˜çš„æ˜¯ä¸€ä¸ªåŒºé—´çš„ä¿¡æ¯ã€‚ æ¯ä¸ªèŠ‚ç‚¹ä»¥ç»“æ„ä½“çš„æ–¹å¼å­˜å‚¨ï¼Œç»“æ„ä½“åŒ…å«ä»¥ä¸‹å‡ ä¸ªä¿¡æ¯ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»¥ç»“æ„ä½“çš„æ–¹å¼å­˜å‚¨ï¼Œç»“æ„ä½“åŒ…å«ä»¥ä¸‹å‡ ä¸ªä¿¡æ¯ï¼š (1). åŒºé—´å·¦ç«¯ç‚¹ã€å³ç«¯ç‚¹ (2). åŒºé—´æ‰€ä»£è¡¨çš„å€¼ (3). è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ çº¿æ®µæ ‘çš„åŸºæœ¬æ€æƒ³ï¼šäºŒåˆ†ã€‚ çº¿æ®µæ ‘ä¸€èˆ¬ç»“æ„å¦‚å›¾æ‰€ç¤ºï¼šå‡è®¾æ•°æ®ä¸º4ä¸ªæ•°ï¼Œåˆ™æ ‘åº”æ˜¯è¿™æ · ç”±ä¸Šå›¾å¯çŸ¥ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­©å­åŒºé—´èŒƒå›´ä¸º[leftï¼Œmid]ï¼Œå³å­©å­ä¸º[mid+1,right] äºŒã€ä»£ç å®ç°ä¸åŸºæœ¬æ“ä½œ0.åŸºç¡€æ•°æ®ç»“æ„123456789#ifndef NULL //é˜²æŠ¥é”™#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d; int left, right; Node lson, rson;&#125;*root; 1.å»ºæ ‘ builtå‡½æ•°12345678910111213141516171819Node built(int left, int right) &#123; Node p = new(Segment_Tree);//Node p=(Node) malloc(sizeof(Segment_Tree));,cç”¨æ³• //ç”³è¯·ä¸€ä¸ªæ–°å†…å­˜ï¼Œå¹¶ä»¤pæŒ‡å‘è¯¥å¤„ p-&gt;left = left; //å‚¨å­˜åŒºé—´ä¿¡æ¯ p-&gt;right = right; if (left == right) &#123; p-&gt;d = a[left]; //scanf("%d",&amp;p-&gt;d),cin&gt;&gt;p-&gt;d,çš†å¯ï¼ŒåŠå‚¨å­˜æ•°æ® p-&gt;lson = NULL; //ä»¤å·¦å„¿å­å’Œå³å„¿å­æŒ‡å‘NULL p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; //äºŒåˆ† p-&gt;lson = built(left, mid); //å·¦å„¿å­ p-&gt;rson = built(mid + 1, right); //å³å„¿å­ p-&gt;d=p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; //å­˜å‚¨å·¦å„¿å­å’Œå³å„¿å­çš„å’Œ &#125; return p; //è¿”å›æŒ‡å‘è¯¥å¤„çš„æŒ‡é’ˆ&#125; &emsp;&emsp;é™¤äº†å»ºæ ‘ï¼Œç›¸åº”å…³é—­æ ‘çš„å‡½æ•°ä¸ºï¼š 123456789void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cç”¨æ³• &#125; return;&#125; &emsp;éå¸¸éœ€è¦æ³¨æ„çš„ä¸€ä»¶äº‹ï¼Œæ¯æ¬¡ç”¨æŒ‡é’ˆå»ºç«‹æ ‘çš„æ—¶å€™ï¼Œè¯·åŠ¡å¿…å†™ä¸€ä¸ªå…³é—­æ¸…ç†ç”³è¯·çš„å†…å­˜çš„å‡½æ•° 2. å•ç‚¹æŸ¥è¯¢&emsp;&emsp;(1).æŸ¥æ‰¾kä½ç½®çš„æ•°æ® 123456789int find(Node p, int k)&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == k) return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (k &lt;= mid) return find(p-&gt;lson, k); return find(p-&gt;rson, k);&#125; 3.å•ç‚¹ä¿®æ”¹&emsp;&emsp;(1).çŸ¥é“ç‚¹æ‰€åœ¨ä½ç½®ï¼Œä¿®æ”¹è¯¥ç‚¹å¤„å€¼ 123456789int update(Node p, int x,int k) //å¯¹xä½ç½®çš„å€¼ï¼Œè¿›è¡Œkå€¼çš„å˜åŠ¨&#123; if (p-&gt;left == p-&gt;right&amp;&amp;p-&gt;left == x) //å¦‚è¿‡æ‰¾åˆ°äº†kä½ç½® return p-&gt;d +=k; //å¯¹è¯¥ç‚¹å€¼è¿›è¡Œæ“ä½œï¼Œå¯ä»¥ä¸º+-*/ç­‰ int mid = (p-&gt;left + p-&gt;right) / 2; //åˆ¤æ–­è¯¥ç‚¹åœ¨å·¦åŒºé—´è¿˜æ˜¯å³åŒºé—´ if (x &lt;= mid) //å¦‚æœæ˜¯å·¦åŒºé—´ï¼Œåªå¯¹å·¦åŒºé—´è¿›è¡Œé€’å½’æŸ¥è¯¢ return p-&gt;d = update(p-&gt;lson, x, k)+p-&gt;rson-&gt;d; //æŸ¥æ‰¾å®Œåå¯¹çˆ¶èŠ‚ç‚¹å­˜å‚¨å€¼è¿›è¡Œä¿®æ”¹ return p-&gt;d = p-&gt;lson-&gt;d+update(p-&gt;rson, x, k); //ä¸æ˜¯è¯¥ç‚¹ï¼Œä¹Ÿä¸åœ¨å·¦åŒºé—´ï¼Œåªèƒ½æ˜¯å³åŒºé—´&#125; 4.åŒºé—´æŸ¥è¯¢&emsp;&emsp;æ‰€ç»™åŒºé—´ä»…å¯èƒ½ä¸ºä¸Šå›¾å››ç§æƒ…å†µã€‚&emsp;&emsp;é€šè¿‡ä¸€å®šæ“ä½œï¼Œæˆ‘ä»¬éƒ½å¯ä»¥å°†ä¸Šä¸‰ç§ï¼Œå…¨éƒ¨è½¬æ¢ä¸ºæœ€åä¸€ç§ç›´æ¥è¾“å‡ºã€‚&emsp;&emsp;é—²è¯å°‘è¯´ï¼Œä»£ç å®ç° 12345678910111213int find(Node p, int x,int y) //æ³¨ï¼Œè¿™é‡Œå‡è®¾ä»»æ„x,yï¼Œéƒ½æœ‰x&lt;y&#123; if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //å¦‚æœæ˜¯ç¬¬å››ç§æƒ…å†µï¼Œç›´æ¥è¿”å› return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; //æ±‚ä¸­é—´å€¼ if (y &lt;= mid) //å¦‚æœæŸ¥è¯¢åŒºé—´åœ¨midå·¦è¾¹ï¼Œå› ä¸ºx&lt;y&lt;=mid return find(p-&gt;lson, x, y); //é‚£ä¹ˆç›´æ¥é€’å½’å·¦å„¿å­ if (x &gt; mid) //å¦‚æœæŸ¥è¯¢åŒºé—´åœ¨midå³è¾¹ï¼Œå› ä¸ºmid&lt;x&lt;y return find(p-&gt;rson, x, y); //é‚£ä¹ˆç›´æ¥é€’å½’å³å„¿å­ return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y); //ä¸¤å¼éƒ½ä¸ç¬¦åˆï¼ŒåŠx&lt;=mid&lt;y //åˆ™ä»midä¸ºä¸­é—´å€¼åˆ†å¼€ //å·¦å„¿å­æŸ¥è¯¢[x,mid],å³å„¿å­æŸ¥è¯¢[mid+1,y]&#125; 5.åŒºé—´ä¿®æ”¹1234567891011int update(Node p, int x, int y, int k) //è®¾åŒºé—´ä¸º[x,y]ï¼Œä¿®æ”¹çš„å€¼ä¸ºk&#123; if (p-&gt;left == p-&gt;right &amp;&amp; p-&gt;left == x) //å¦‚æœæ˜¯è¿™ä¸ªåŒºé—´å†…çš„å…ƒç´ ï¼Œå°±è®©å®ƒ+k return p-&gt;d+=k; int mid = (p-&gt;left + p-&gt;right) / 2; //äºŒåˆ† if (y &lt;= mid) //å¦‚æœåŒºé—´åœ¨ä¸­å€¼çš„å·¦ä¾§ return p-&gt;d=update(p-&gt;lson, x, y,k)+p-&gt;rson-&gt;d; //ä»…éœ€æ›´æ–°å·¦å„¿å­çš„å€¼ï¼Œå¹¶æ›´æ–°çˆ¶äº²çš„å€¼ if (x &gt; mid) //å¦‚æœåŒºé—´åœ¨ä¸­å€¼çš„å·¦ä¾§ return p-&gt;d=p-&gt;lson-&gt;d+update(p-&gt;rson, x, y,k); //åŒä¸Š return p-&gt;d=update(p-&gt;lson, x, mid,k) + update(p-&gt;rson, mid + 1, y,k); //å¦‚æœåŒºé—´è¢«ä¸­å€¼åˆ†å¼€&#125; ä¸‰.ä¼˜åŒ–ï¼ˆä¸€ï¼‰. Lazy-Tagæ‡’æ ‡è®°&emsp;&emsp;æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹åŒºé—´æ”¹å€¼çš„è¿‡ç¨‹ï¼šå½“æ›´æ”¹æŸä¸ªåŒºé—´çš„å€¼çš„æ—¶å€™ï¼Œå­åŒºé—´ä¹Ÿè·Ÿç€æ›´æ”¹ã€‚æ˜¾ç„¶ï¼Œåœ¨å¤§æ•°æ®ä¸‹ï¼Œè¿™æ ·æ“ä½œä¼šå¯¼è‡´TLEã€‚&emsp;&emsp;æ€ä¹ˆåŠï¼Ÿ&emsp;&emsp;è¿™æ—¶æˆ‘ä»¬å°±å¼•å…¥ä¸€ä¸ªä¼˜åŒ–æ–¹æ³•ï¼Œå«åšLazy-Tagæ‡’æ ‡è®°ã€‚&emsp;&emsp;ä½•ä¸ºæ‡’æ ‡è®°å‘¢ï¼Ÿé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ç”¨æ¥å·æ‡’çš„å‡å°‘ä¿®æ”¹æ—¶æ¶ˆè€—æ—¶é—´çš„ã€‚å³ï¼š&emsp;&emsp;å½“æˆ‘æƒ³è¦å¯¹æŸä¸€åŒºé—´çš„æ‰€æœ‰å…ƒç´ éƒ½+kæ—¶ï¼Œåœ¨ä¿®æ”¹è¯¥åŒºé—´èŠ‚ç‚¹æ—¶ï¼Œå¯¹å…¶æ‰“ä¸Šæ ‡è®°lazyï¼Œå¹¶è®°lazyä¸ºkï¼Œä¿®æ”¹è¯¥èŠ‚ç‚¹çš„å€¼ä¸º+åŒºé—´é•¿åº¦*kï¼Œç«‹åˆ»returnï¼Œè€Œä¸å°†è¯¥èŠ‚ç‚¹ä¸‹é¢çš„æ‰€æœ‰å­èŠ‚ç‚¹ä¸€ä¸€ä¿®æ”¹ã€‚ æ€æƒ³å®ç°&emsp;&emsp;å¦‚å›¾ç¤ºï¼š1~4çš„å€¼åˆ†åˆ«ä¸º1ï¼Œ2ï¼Œ3ï¼Œ4&emsp;&emsp;æˆ‘ä»¬é€‰æ‹©å¯¹[1,2]åŒºé—´è¿›è¡Œä¿®æ”¹ï¼Œè¦æ±‚æ”¹åŒºé—´æ‰€æœ‰å€¼+2ï¼Œåˆ™ï¼šåœ¨åŒºé—´[1,2]ï¼Œæ‰“ä¸Šæ ‡è®°lazy=2ï¼Œå¹¶ä¿®æ”¹å…¶å€¼ä¸º3+(2-1+1)2ï¼Œç›´æ¥è¿”å›ï¼Œå¹¶ä¸å¯¹å…¶å­èŠ‚ç‚¹è¿›è¡Œä¿®æ”¹&emsp;&emsp;å½“æˆ‘ä»¬å†æ¬¡å¯¹[1,2]åŒºé—´ä¿®æ”¹æ—¶ï¼Œå¹¶è¦æ±‚åŒºé—´å†…æ‰€æœ‰çš„å€¼+1ï¼Œåˆ™ï¼šç”±äº[1,2]æœ‰æ ‡è®°lazy=2ï¼Œäºæ˜¯æˆ‘ä»¬å°†lazyæ ‡è®°å‘å…¶å­èŠ‚ç‚¹ä¼ å¯¼ï¼Œå¹¶ä¿®æ”¹å…¶å­èŠ‚ç‚¹çš„å€¼ã€‚å†åœ¨[1,2]åŒºé—´æ‰“ä¸Šlazy=1ï¼Œä¿®æ”¹å€¼ä¸º(2-1+1)1ï¼Œè¿”å›ã€‚ ä»£ç å®ç°0.æ ¸å¿ƒä»£ç  pushdown12345678910void pushdown(Node p)&#123; if (p-&gt;lson != NULL) &#123; //å¦‚æœè¯¥èŠ‚ç‚¹è¿˜æœ‰åç»­èŠ‚ç‚¹ p-&gt;lson-&gt;lazy += p-&gt;lazy; //ä»¤å­èŠ‚ç‚¹lazyç»§æ‰¿çˆ¶èŠ‚ç‚¹lazyï¼Œä¸‹åŒ p-&gt;lson-&gt;d += (p-&gt;lson-&gt;right - p-&gt;lson-&gt;left + 1)*p-&gt;lazy; //ä¿®æ”¹å­èŠ‚ç‚¹çš„å€¼ï¼Œä¸‹åŒ p-&gt;rson-&gt;lazy += p-&gt;lazy; p-&gt;rson-&gt;d += (p-&gt;rson-&gt;right - p-&gt;rson-&gt;left + 1)*p-&gt;lazy; &#125; p-&gt;lazy = 0; //ä»¤è¯¥èŠ‚ç‚¹çš„lazyæ¸…é›¶&#125; 1.æ ‘æœ¬ä½“123456789#ifndef NULL#define NULL 0#endiftypedef struct Segment_Tree* Node;struct Segment_Tree &#123; int d,lazy; //ä»…ä»…å¤šäº†ä¸€ä¸ªlazyæ ‡è®° int left, right; Node lson, rson;&#125;*root; 2.å»ºæ ‘12345678910111213141516171819202122232425262728Node built(int left, int right)&#123; Node p = new(Segment_Tree); p-&gt;left = left; p-&gt;right = right; p-&gt;lazy = 0; //åªæ˜¯å¯¹lazyæ ‡è®°è¿›è¡Œåˆå§‹åŒ– if (left == right) &#123; p-&gt;d = a[left]; p-&gt;lson = NULL; p-&gt;rson = NULL; &#125; else &#123; int mid = (left + right) / 2; p-&gt;lson = built(left, mid); p-&gt;rson = built(mid + 1, right); p-&gt;d = p-&gt;lson-&gt;d+p-&gt;rson-&gt;d; &#125; return p;&#125;void close(Node p)&#123; if (p != NULL) &#123; close(p-&gt;lson); close(p-&gt;rson); delete(p); //free(p);cç”¨æ³• &#125; return;&#125; 3.å•ç‚¹æŸ¥è¯¢å’Œå•ç‚¹ä¿®æ”¹æ— æ”¹å˜4.åŒºé—´æŸ¥è¯¢12345678910111213long long find(Node p, int x, int y) //åŒºé—´æŸ¥è¯¢&#123; if (p-&gt;lazy != 0) //è§£å†³ä¸€ä¸‹å†å²é—ç•™é—®é¢˜å†æŸ¥è¯¢ pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right == y) //å…¶ä»–æœªå˜ return p-&gt;d; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return find(p-&gt;lson, x, y); if (x &gt; mid) return find(p-&gt;rson, x, y); return find(p-&gt;lson, x, mid)+find(p-&gt;rson, mid + 1, y);&#125; 5.åŒºé—´ä¿®æ”¹123456789101112131415int update(Node p, int x, int y, int k) //åŒºé—´ä¿®æ”¹&#123; if (p-&gt;lazy!=0) //å¦‚æœè¯¥èŠ‚ç‚¹çš„lazyä¸ä¸ºé›¶ï¼Œå°±å¤„ç†ä¸€ä¸‹ pushdown(p); if (p-&gt;left == x &amp;&amp; p-&gt;right==y) &#123; //å¦‚æœæ˜¯è¦è¿›è¡Œä¿®æ”¹çš„èŠ‚ç‚¹ï¼Œä¾¿è®©è¯¥èŠ‚ç‚¹çš„lazyä¸ºkï¼Œå¹¶ä¿®æ”¹å€¼ p-&gt;lazy = k; return p-&gt;d += k*(y - x + 1); &#125; int mid = (p-&gt;left + p-&gt;right) / 2; if (y &lt;= mid) return p-&gt;d = p-&gt;rson-&gt;d+update(p-&gt;lson, x, y, k); if (x &gt; mid) return p-&gt;d = p-&gt;lson-&gt;d+ update(p-&gt;rson, x, y, k); return p-&gt;d = update(p-&gt;lson, x, mid, k) + update(p-&gt;rson, mid + 1, y, k);&#125; ï¼ˆäºŒï¼‰. ç¦»æ•£åŒ–&emsp;&emsp;ç¦»æ•£åŒ–æ˜¯ä¸€ä¸ªå¬èµ·æ¥å¾ˆé«˜å¤§ä¸Šçš„æ–¹æ³•.&emsp;&emsp;å…¶å®åšèµ·æ¥å¾ˆç®€å•.å½“ç„¶å¦‚æœæƒ³é«˜æ·±çš„è¯,è‡ªç„¶ä¹Ÿæ‹¦ä¸ä½&emsp;&emsp;å…¶å®å°±æ˜¯å°†ä¸€ä¸²æ•°æ®å‚¨å­˜åˆ°æ•°ç»„ä¸­,ä¸å°†æ•°æ®æœ¬èº«ä½œä¸ºé”®å€¼,è€Œæ˜¯é€‰æ‹©ä½¿ç”¨æ•°ç»„çš„ä¸‹æ ‡ä½œä¸ºé”®å€¼.&emsp;&emsp;å½¢è±¡çš„,$1,2,3,10000000$è¿™å››ä¸ªæ•°,ä¿å­˜åœ¨æ•°ç»„$a[]$ä¸­,ç›¸å¯¹åº”çš„ä¸‹æ ‡ä¸º$1,2,3,4$å°±å¯ä»¥å‡å°‘ç©ºé—´çš„å¼€æ”¯. æ•°ç»„å®ç°å¦‚æœä½ è§‰å¾—è¿™ä¸ªä»£ç å¾ˆç†Ÿæ‚‰!é‚£å°±å½“æˆ‘æŠ„çš„å§,åš¯åš¯åš¯ æ´›è°·çº¿æ®µæ ‘1: æˆ³æˆ‘çœ‹ä»£ç ~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 100000 + 10;typedef long long ll;#define l(p) tree[p].lson#define r(p) tree[p].rsonstruct vec &#123; ll d; int lson, rson; ll lazy; int L, R;&#125; tree[MAXN &lt;&lt; 2];int tot;int rub()&#123; tot++; return tot;&#125;void built(int&amp; p, int l, int r)&#123; p = rub(); tree[p].L = l, tree[p].R = r; tree[p].lazy = 0; if (l == r) cin &gt;&gt; tree[p].d; else &#123; int mid = (l + r) &gt;&gt; 1; built(l(p), l, mid); built(r(p), mid + 1, r); tree[p].d = tree[l(p)].d + tree[r(p)].d; &#125;&#125;void pushdown(int p)&#123; if (l(p) &amp;&amp; r(p)) &#123; tree[l(p)].lazy += tree[p].lazy; tree[r(p)].lazy += tree[p].lazy; tree[l(p)].d += tree[p].lazy * (tree[l(p)].R - tree[l(p)].L + 1); tree[r(p)].d += tree[p].lazy * (tree[r(p)].R - tree[r(p)].L + 1); &#125; tree[p].lazy = 0;&#125;ll query(int p, int l, int r)&#123; pushdown(p); int L = tree[p].L, R = tree[p].R; if (L == l &amp;&amp; R == r) return tree[p].d; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) return query(r(p), l, r); else if (r &lt;= mid) return query(l(p), l, r); return query(l(p), l, mid) + query(r(p), mid + 1, r);&#125;void up(int p)&#123; tree[p].d = tree[l(p)].d + tree[r(p)].d;&#125;void update(int p, int l, int r, ll k)&#123; pushdown(p); int L = tree[p].L, R = tree[p].R; if (L == l &amp;&amp; r == R) &#123; tree[p].d += k * (tree[p].R - tree[p].L + 1); tree[p].lazy += k; return; &#125; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) update(r(p), l, r, k); else if (r &lt;= mid) update(l(p), l, r, k); else update(l(p), l, mid, k), update(r(p), mid + 1, r, k); up(p);&#125;void print(int p)&#123; if (p == 0) return; pushdown(p); cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; tree[p].L &lt;&lt; ' ' &lt;&lt; tree[p].R &lt;&lt; ":" &lt;&lt; tree[p].d &lt;&lt; endl; print(l(p)); print(r(p));&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int root; built(root, 1, n); while (m--) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; ll k; cin &gt;&gt; k; update(root, x, y, k); &#125; else cout &lt;&lt; query(root, x, y) &lt;&lt; endl; &#125; return 0;&#125; æ´›è°·çº¿æ®µæ ‘2: æˆ³æˆ‘çœ‹ä»£ç ~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 100000 + 10;typedef long long ll;#define l(p) tree[p].lson#define r(p) tree[p].rsonstruct vec &#123; ll d; int lson, rson; ll add_lazy, mul_lazy; int L, R;&#125; tree[MAXN &lt;&lt; 2];int tot, mod;int rub()&#123; tot++; return tot;&#125;void built(int&amp; p, int l, int r)&#123; p = rub(); tree[p].L = l, tree[p].R = r; tree[p].add_lazy = 0; tree[p].mul_lazy = 1; if (l == r) cin &gt;&gt; tree[p].d; else &#123; int mid = (l + r) &gt;&gt; 1; built(l(p), l, mid); built(r(p), mid + 1, r); tree[p].d = (tree[l(p)].d + tree[r(p)].d) % mod; &#125;&#125;void pushdown(int p)&#123; if (l(p) &amp;&amp; r(p)) &#123; tree[l(p)].add_lazy = tree[l(p)].add_lazy * tree[p].mul_lazy % mod; tree[r(p)].add_lazy = tree[r(p)].add_lazy * tree[p].mul_lazy % mod; tree[l(p)].mul_lazy = tree[l(p)].mul_lazy * tree[p].mul_lazy % mod; tree[r(p)].mul_lazy = tree[r(p)].mul_lazy * tree[p].mul_lazy % mod; tree[l(p)].add_lazy = (tree[l(p)].add_lazy + tree[p].add_lazy) % mod; tree[r(p)].add_lazy = (tree[r(p)].add_lazy + tree[p].add_lazy) % mod; tree[l(p)].d = (tree[l(p)].d * tree[p].mul_lazy + tree[p].add_lazy * (tree[l(p)].R - tree[l(p)].L + 1)) % mod; tree[r(p)].d = (tree[r(p)].d * tree[p].mul_lazy + tree[p].add_lazy * (tree[r(p)].R - tree[r(p)].L + 1)) % mod; &#125; tree[p].add_lazy = 0; tree[p].mul_lazy = 1;&#125;ll query(int p, int l, int r)&#123; pushdown(p); int L = tree[p].L, R = tree[p].R; if (L == l &amp;&amp; R == r) return tree[p].d; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) return query(r(p), l, r) % mod; else if (r &lt;= mid) return query(l(p), l, r) % mod; return (query(l(p), l, mid) + query(r(p), mid + 1, r)) % mod;&#125;void up(int p)&#123; tree[p].d = tree[l(p)].d + tree[r(p)].d;&#125;void add_update(int p, int l, int r, ll k)&#123; pushdown(p); int L = tree[p].L, R = tree[p].R; if (L == l &amp;&amp; r == R) &#123; tree[p].d += k * (tree[p].R - tree[p].L + 1); tree[p].add_lazy += k; return; &#125; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) add_update(r(p), l, r, k); else if (r &lt;= mid) add_update(l(p), l, r, k); else add_update(l(p), l, mid, k), add_update(r(p), mid + 1, r, k); up(p);&#125;void mul_update(int p, int l, int r, ll k)&#123; pushdown(p); int L = tree[p].L, R = tree[p].R; if (L == l &amp;&amp; r == R) &#123; tree[p].d *= k; tree[p].add_lazy *= k; tree[p].mul_lazy *= k; return; &#125; int mid = (L + R) &gt;&gt; 1; if (l &gt; mid) mul_update(r(p), l, r, k); else if (r &lt;= mid) mul_update(l(p), l, r, k); else mul_update(l(p), l, mid, k), mul_update(r(p), mid + 1, r, k); up(p);&#125;void print(int p)&#123; if (p == 0) return; pushdown(p); cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; tree[p].L &lt;&lt; ' ' &lt;&lt; tree[p].R &lt;&lt; ":" &lt;&lt; tree[p].d &lt;&lt; endl; print(l(p)); print(r(p));&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod; int root; built(root, 1, n); while (m--) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; ll k; cin &gt;&gt; k; mul_update(root, x, y, k); &#125; else if (op == 2) &#123; ll k; cin &gt;&gt; k; add_update(root, x, y, k); &#125; else cout &lt;&lt; query(root, x, y) % mod &lt;&lt; endl; &#125; return 0;&#125; ç»ƒä¹ é¢˜ç›®æ´›è°·P2251è£¸çš„RMQé—®é¢˜,æ•°æ®é‡å°.æ´›è°·P3372æ´›è°·P3373æ´›è°·çº¿æ®µæ ‘æ¨¡æ¿é¢˜]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #3.[NOI2014]é­”æ³•æ£®æ—]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-3%2F</url>
    <content type="text"><![CDATA[åºè¨€$UOJ$æœç„¶æ˜¯ç¥ä»™$OJ$å•Šé‡Œé¢ä¸ªä¸ªéƒ½æ˜¯äººæ‰,è¯´è¯è¿˜å¥½å¬é¢˜ç›®çš„$hack$æ•°æ®è¿˜å¯ä»¥$hack$æ‰ç½‘ä¸Šä¸€å¤§ç‰‡çš„é¢˜è§£â€¦.. é¢˜ç›®æè¿°ä¸ºäº†å¾—åˆ°ä¹¦æ³•å¤§å®¶çš„çœŸä¼ ï¼Œå°$E$åŒå­¦ä¸‹å®šå†³å¿ƒå»æ‹œè®¿ä½åœ¨é­”æ³•æ£®æ—ä¸­çš„éšå£«ã€‚é­”æ³•æ£®æ—å¯ä»¥è¢«çœ‹æˆä¸€ä¸ªåŒ…å«ä¸ª$N$èŠ‚ç‚¹$M$æ¡è¾¹çš„æ— å‘å›¾ï¼ŒèŠ‚ç‚¹æ ‡å·ä¸º$1â€¦n$ï¼Œè¾¹æ ‡å·ä¸º$1â€¦m$ã€‚åˆå§‹æ—¶å°$E$åŒå­¦åœ¨$1$ å·èŠ‚ç‚¹ï¼Œéšå£«åˆ™ä½åœ¨ $n$ å·èŠ‚ç‚¹ã€‚å°$E$éœ€è¦é€šè¿‡è¿™ä¸€ç‰‡é­”æ³•æ£®æ—ï¼Œæ‰èƒ½å¤Ÿæ‹œè®¿åˆ°éšå£«ã€‚é­”æ³•æ£®æ—ä¸­å±…ä½äº†ä¸€äº›å¦–æ€ªã€‚æ¯å½“æœ‰äººç»è¿‡ä¸€æ¡è¾¹çš„æ—¶å€™ï¼Œè¿™æ¡è¾¹ä¸Šçš„å¦–æ€ªå°±ä¼šå¯¹å…¶å‘èµ·æ”»å‡»ã€‚å¹¸è¿çš„æ˜¯ï¼Œåœ¨ $1$ å·èŠ‚ç‚¹ä½ç€ä¸¤ç§å®ˆæŠ¤ç²¾çµï¼š$A$å‹å®ˆæŠ¤ç²¾çµä¸$B$å‹å®ˆæŠ¤ç²¾çµã€‚å°$E$å¯ä»¥å€ŸåŠ©å®ƒä»¬çš„åŠ›é‡ï¼Œè¾¾åˆ°è‡ªå·±çš„ç›®çš„ã€‚åªè¦å°Eå¸¦ä¸Šè¶³å¤Ÿå¤šçš„å®ˆæŠ¤ç²¾çµï¼Œå¦–æ€ªä»¬å°±ä¸ä¼šå‘èµ·æ”»å‡»äº†ã€‚å…·ä½“æ¥è¯´ï¼Œæ— å‘å›¾ä¸­çš„æ¯ä¸€æ¡è¾¹ $e_i$ åŒ…å«ä¸¤ä¸ªæƒå€¼ $a_i$ ä¸ $b_i$ã€‚è‹¥èº«ä¸Šæºå¸¦çš„$A$å‹å®ˆæŠ¤ç²¾çµä¸ªæ•°ä¸å°‘äº $a_i$ï¼Œä¸”$B$å‹å®ˆæŠ¤ç²¾çµä¸ªæ•°ä¸å°‘äº $b_i$ï¼Œè¿™æ¡è¾¹ä¸Šçš„å¦–æ€ªå°±ä¸ä¼šå¯¹é€šè¿‡è¿™æ¡è¾¹çš„äººå‘èµ·æ”»å‡»ã€‚å½“ä¸”ä»…å½“é€šè¿‡è¿™ç‰‡é­”æ³•æ£®æ—çš„è¿‡ç¨‹ä¸­æ²¡æœ‰ä»»æ„ä¸€æ¡è¾¹çš„å¦–æ€ªå‘å°$E$å‘èµ·æ”»å‡»ï¼Œä»–æ‰èƒ½æˆåŠŸæ‰¾åˆ°éšå£«ã€‚ç”±äºæºå¸¦å®ˆæŠ¤ç²¾çµæ˜¯ä¸€ä»¶éå¸¸éº»çƒ¦çš„äº‹ï¼Œå°Eæƒ³è¦çŸ¥é“ï¼Œè¦èƒ½å¤ŸæˆåŠŸæ‹œè®¿åˆ°éšå£«ï¼Œæœ€å°‘éœ€è¦æºå¸¦å®ˆæŠ¤ç²¾çµçš„æ€»ä¸ªæ•°ã€‚å®ˆæŠ¤ç²¾çµçš„æ€»ä¸ªæ•°ä¸º$A$å‹å®ˆæŠ¤ç²¾çµçš„ä¸ªæ•°ä¸$B$å‹å®ˆæŠ¤ç²¾çµçš„ä¸ªæ•°ä¹‹å’Œã€‚ é¢˜ç›®å¤§æ„:ä»$1$èµ°åˆ°$n$,$m$æ¡è¾¹,å¦‚ä½•èµ°èƒ½ä½¿$a$å’Œ$b$çš„å’Œæœ€å¤§å€¼æœ€å°. è§£æé¦–å…ˆ,è¿™æ˜¯ä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘çš„é¢˜ç›®.å…¶æ¬¡,è¿™åº”è¯¥æ˜¯ä¸€ä¸ªåŠ¨æ€æœ€å°ç”Ÿæˆæ ‘çš„é¢˜ç›®.(å¦‚æœä½ å­¦è¿‡ç”¨LCTåšæœ€å°ç”Ÿæˆæ ‘,è¿™ä¸ªé¢˜å°±éå¸¸çš„æ°´)æˆ‘ä»¬å°†$a_i$æ’åºå,æŒ‰è¾¹å–,å¯ä»¥ä¿è¯$a_i$æ˜¯æœ€å°çš„.åœ¨æŒ‰$a_i$å¤§å°å–è¾¹çš„æ—¶å€™,åŒæ—¶æ›´æ–°è·¯ä¸Š$b_i$çš„æœ€å¤§å€¼.å½“æˆ‘ä»¬å–åˆ°ä¸€ä¸ªç¯çš„æ—¶å€™æ€ä¹ˆåŠ?åˆ—å¦‚è¿™æ ·:æˆ‘ä»¬å°±è¦å¯¹æ–°åŠ å…¥çš„è¾¹ä¸Š$b_i$çš„å€¼,å’Œç»´æŠ¤çš„é“¾ä¸Š$b_i$çš„æœ€å¤§å€¼è¿›è¡Œæ¯”è¾ƒ. å¦‚æœé“¾ä¸Šçš„å€¼å¤§,é‚£ä¹ˆæˆ‘ä»¬æŠŠé“¾ä¸Šæœ€å¤§çš„é‚£æ¡è¾¹$cut$,å¦‚ä½•æŠŠæ–°è¾¹è¿ä¸Š. å¦‚æœæ–°è¾¹å¤§,æˆ‘ä»¬ä¾¿ç›´æ¥è·³è¿‡. å¦‚æ­¤å¾€å¤,ç›´åˆ°$1$$n$è¿™æ¡è·¯è¿é€š.è¿é€šå,æˆ‘ä»¬åŠ å…¥å¦ä¸€ä¸ªæ“ä½œ:åˆ¤æ–­,åŠ å…¥çš„è¿™æ¡è¾¹å¯¹äºç­”æ¡ˆçš„å½±å“.$a$å¤§å¹¶ä¸ä»£è¡¨$b$ä¹Ÿå¤§,å› ä¸ºé—®çš„æ˜¯$a+b$çš„å’Œ.ç›´åˆ°éå†å®Œæ‰€æœ‰è¾¹.~è¿‡äº†æœ€å°ç”Ÿæˆæ ‘çš„ä»£ç å±…ç„¶åªæœ‰97~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int INF = 1e9;const int MAXN = 2e5 + 10;struct node &#123; int x, y, a, b; bool operator &lt; (const node &amp;rhs) const &#123; return a &lt; rhs.a; &#125;&#125;edge[MAXN];struct vec &#123; int fa, son[2]; bool rev; int maxx, id;&#125;p[MAXN];int n;int isroot(int x) &#123; return p[p[x].fa].son[0] != x &amp;&amp; p[p[x].fa].son[1] != x;&#125;void pushup(int x) &#123; int A = p[x].id, B = p[p[x].son[0]].maxx, C = p[p[x].son[1]].maxx; if (edge[A].b &gt;= edge[B].b&amp;&amp;edge[A].b &gt;= edge[C].b) p[x].maxx = A; else if (edge[B].b &gt;= edge[C].b) p[x].maxx = B; else p[x].maxx = C;&#125;void pushdown(int x) &#123; if (p[x].rev) &#123; int l = p[x].son[0], r = p[x].son[1]; swap(p[l].son[0], p[l].son[1]), p[l].rev ^= 1; swap(p[r].son[0], p[r].son[1]), p[r].rev ^= 1; p[x].rev ^= 1; &#125;&#125;int get(int x) &#123; return p[p[x].fa].son[1] == x;&#125;void rotate(int x) &#123; int y = p[x].fa, t = p[y].fa, f = get(x), k = p[x].son[f ^ 1]; p[p[k].fa = y].son[f] = p[x].son[f ^ 1]; p[x].fa = t; if (!isroot(y)) p[t].son[get(y)] = x; p[p[y].fa = x].son[f ^ 1] = y; pushup(y);&#125;int top, stk[MAXN];void splay(int x) &#123; stk[top = 1] = x; for (int i = x; !isroot(i); i = p[i].fa) stk[++top] = p[i].fa; while (top) pushdown(stk[top--]); for (; !isroot(x); rotate(x)) if (!isroot(p[x].fa)) rotate(get(x) ^ get(p[x].fa) ? x : p[x].fa); pushup(x);&#125;void access(int x) &#123; for (int i = 0; x; x = p[i = x].fa) splay(x), p[x].son[1] = i, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); p[x].rev ^= 1; swap(p[x].son[0], p[x].son[1]);&#125;int findroot(int x) &#123; access(x); splay(x); while (p[x].son[0]) pushdown(x), x = p[x].son[0]; splay(x); return x;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;int link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; p[x].fa = y; return true;&#125;void Cut(int x, int y) &#123; split(x, y); if (p[y].son[0] == x) p[x].fa = p[y].son[0] = 0;&#125;void Addedge(int id) &#123; int x = edge[id].x, y = edge[id].y; if (findroot(x) != findroot(y)) link(x, id + n), link(id + n, y); else &#123; split(x, y); if (edge[p[y].maxx].b &gt; edge[id].b) &#123; int tmp = p[y].maxx; Cut(edge[tmp].x, tmp + n), Cut(tmp + n, edge[tmp].y); link(edge[id].x, id + n), link(id + n, edge[id].y); &#125; &#125;&#125;int main() &#123; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].a &gt;&gt; edge[i].b; sort(edge + 1, edge + m + 1); for (int i = 1; i &lt;= m; i++) p[i + n].maxx = p[i + n].id = i; int ans = INF; for (int i = 1; i &lt;= m; i++) &#123; Addedge(i); while (edge[i].a == edge[i + 1].a) Addedge(++i); if (findroot(1) == findroot(n)) &#123; split(1, n); ans = min(ans, edge[p[n].maxx].b + edge[i].a); &#125; &#125; printf("%d\n", ans == INF ? -1 : ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>UOJç»ƒä¹ è®°å½•</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ #2.[NOI2014]èµ·åºŠå›°éš¾ç»¼åˆç—‡]]></title>
    <url>%2F2019%2F08%2F07%2FUOJ-2%2F</url>
    <content type="text"><![CDATA[æè¿° é“¾æ¥:http://uoj.ac/problem/2 21 ä¸–çºªï¼Œè®¸å¤šäººå¾—äº†ä¸€ç§å¥‡æ€ªçš„ç—…ï¼šèµ·åºŠå›°éš¾ç»¼åˆç—‡ï¼Œå…¶ä¸´åºŠè¡¨ç°ä¸ºï¼šèµ·åºŠéš¾ï¼Œèµ·åºŠåç²¾ç¥ä¸ä½³ã€‚ä½œä¸ºä¸€åé’æ˜¥é˜³å…‰å¥½å°‘å¹´ï¼Œatm ä¸€ç›´åšæŒä¸èµ·åºŠå›°éš¾ç»¼åˆç—‡ä½œæ–—äº‰ã€‚é€šè¿‡ç ”ç©¶ç›¸å…³æ–‡çŒ®ï¼Œä»–æ‰¾åˆ°äº†è¯¥ç—…çš„å‘ç—…åŸå› ï¼šåœ¨æ·±é‚ƒçš„å¤ªå¹³æ´‹æµ·åº•ä¸­ï¼Œå‡ºç°äº†ä¸€æ¡åä¸º drd çš„å·¨é¾™ï¼Œå®ƒæŒæ¡ç€ç¡çœ ä¹‹ç²¾é«“ï¼Œèƒ½éšæ„å»¶é•¿å¤§å®¶çš„ç¡çœ æ—¶é—´ã€‚æ­£æ˜¯ç”±äº drd çš„æ´»åŠ¨ï¼Œèµ·åºŠå›°éš¾ç»¼åˆç—‡æ„ˆæ¼”æ„ˆçƒˆï¼Œä»¥æƒŠäººçš„é€Ÿåº¦åœ¨ä¸–ç•Œä¸Šä¼ æ’­ã€‚ä¸ºäº†å½»åº•æ¶ˆç­è¿™ç§ç—…ï¼Œatm å†³å®šå‰å¾€æµ·åº•ï¼Œæ¶ˆç­è¿™æ¡æ¶é¾™. å†ç»åƒè¾›ä¸‡è‹¦ï¼Œatm ç»ˆäºæ¥åˆ°äº† drd æ‰€åœ¨çš„åœ°æ–¹ï¼Œå‡†å¤‡ä¸å…¶å±•å¼€è‰°è‹¦å“ç»çš„æˆ˜æ–—ã€‚drd æœ‰ç€ååˆ†ç‰¹æ®Šçš„æŠ€èƒ½ï¼Œä»–çš„é˜²å¾¡æˆ˜çº¿èƒ½å¤Ÿä½¿ç”¨ä¸€å®šçš„è¿ç®—æ¥æ”¹å˜ä»–å—åˆ°çš„ä¼¤å®³ã€‚å…·ä½“è¯´æ¥ï¼Œdrd çš„é˜²å¾¡æˆ˜çº¿ç”± $n$ æ‰‡é˜²å¾¡é—¨ç»„æˆã€‚æ¯æ‰‡é˜²å¾¡é—¨åŒ…æ‹¬ä¸€ä¸ªè¿ç®—$op$ å’Œä¸€ä¸ªå‚æ•°$t$ï¼Œå…¶ä¸­è¿ç®—ä¸€å®šæ˜¯ $OR,XOR,AND$ ä¸­çš„ä¸€ç§ï¼Œå‚æ•°åˆ™ä¸€å®šä¸ºéè´Ÿæ•´æ•°ã€‚å¦‚æœè¿˜æœªé€šè¿‡é˜²å¾¡é—¨æ—¶æ”»å‡»åŠ›ä¸º $x$ï¼Œåˆ™å…¶é€šè¿‡è¿™æ‰‡é˜²å¾¡é—¨åæ”»å‡»åŠ›å°†å˜ä¸º $x$ $op$ $t$ã€‚æœ€ç»ˆdrd å—åˆ°çš„ä¼¤å®³ä¸ºå¯¹æ–¹åˆå§‹æ”»å‡»åŠ› $x$ ä¾æ¬¡ç»è¿‡æ‰€æœ‰ $n$æ‰‡é˜²å¾¡é—¨åè½¬å˜å¾—åˆ°çš„æ”»å‡»åŠ›ã€‚ ç”±äº atm æ°´å¹³æœ‰é™ï¼Œä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½ä¸º $0$ åˆ° $m$ ä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼ˆå³ä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½åœ¨ $0,1,â€¦,m$ ä¸­ä»»é€‰ï¼Œä½†åœ¨é€šè¿‡é˜²å¾¡é—¨ä¹‹åçš„æ”»å‡»åŠ›ä¸å— $m$ çš„é™åˆ¶ï¼‰ã€‚ä¸ºäº†èŠ‚çœä½“åŠ›ï¼Œä»–å¸Œæœ›é€šè¿‡é€‰æ‹©åˆé€‚çš„åˆå§‹æ”»å‡»åŠ›ä½¿å¾—ä»–çš„æ”»å‡»èƒ½è®© drd å—åˆ°æœ€å¤§çš„ä¼¤å®³ï¼Œè¯·ä½ å¸®ä»–è®¡ç®—ä¸€ä¸‹ï¼Œä»–çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šèƒ½ä½¿ drd å—åˆ°å¤šå°‘ä¼¤å®³ã€‚ è§£æå¾ˆæœ‰æ„æ€çš„é¢˜ç›®,æƒ³åˆ°äºŒè¿›åˆ¶æ‹†ä½çš„è¯,æ€è·¯å°±å¾ˆæ¸…æ™°äº†. è™½ç„¶æˆ‘ç”±äºä¸çŸ¥åçš„åŸå› ä¸€ç›´50åˆ† æˆ‘ä»¬æŒ‰ä½è¿ç®—,å› ä¸ºæ¯ä¸€ä½çš„è¿ç®—æ˜¯ç‹¬ç«‹çš„,è€Œæ¯ä¸€ä½åªå¯èƒ½æ˜¯$0$æˆ–$1$. åªéœ€è¦æ³¨æ„å‡ ç‚¹å³å¯ åŸæ•°ç¬¬$k$ä½å¦‚æœæ˜¯$0$,å‡ºæ¥çš„ç»“æœæ˜¯$1$,æˆ‘ä»¬å°±å­˜ä¸‹æ¥ åŸæ•°çš„ç¬¬$k$ä½å¦‚æœæ˜¯$1$,å‡ºæ¥çš„ç»“æœæ˜¯$1$,ä¸”åŸæ•°å°äºm,æˆ‘ä»¬å°±å­˜ä¸‹æ¥. ==97åˆ†ä»£ç == 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int i, int now) &#123; int temp = 1 &amp; (this-&gt;t &gt;&gt; i); if (op[0] == 'A') now &amp;= temp; else if (op[0] == 'O') now |= temp; else now ^= temp; return now; &#125;&#125;p[MAXN];bool check(int i, int now) &#123; for (vec x : p) now = x.check(i, now); return now;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].op &gt;&gt; p[i].t; ll ans=0; for (int i = 30; i &gt;= 0; i--) &#123; int k = (1 &lt;&lt; i); if (check(i, 0)) ans += k; else if (m &gt; k &amp;&amp; check(i, 1)) ans += k, m -= k; &#125; printf("%lld\n", ans); return 0;&#125; ä¸çŸ¥é“æ˜¯å“ªä½å¸¦ä½¬å‡ºçš„hackæ•°æ®, 123452 13983XOR 12XOR 12ç­”æ¡ˆæ˜¯13983 åŒæ ·çš„æ€è·¯,ä¸åŒçš„åšæ³•,æˆ‘ä»¬å¯ä»¥å°†$11111â€¦$å’Œ$0$åˆ†åˆ«æ‰”è¿›å»,é‚£ä¹ˆåˆ†åˆ«å°†å‡ºæ¥çš„é$0$çš„ä½åŠ èµ·æ¥,å°±æ˜¯æˆ‘ä»¬çš„ç­”æ¡ˆ.åŒæ ·,ä¼˜å…ˆçº§$0$&gt;$1$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#ifndef NULL#define NULL 0#endifusing namespace std;typedef unsigned long long ull;typedef long long ll;const int MAXN = 1e5 + 10;const int mod = 10007;int n, m;struct vec &#123; int t; char op[10]; int check(int now) &#123; if (op[0] == 'A') now &amp;= t; else if (op[0] == 'O') now |= t; else now ^= t; return now; &#125;&#125;p[MAXN];int main() &#123; int x = 0, y = (1LL &lt;&lt; 31) - 1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].op &gt;&gt; p[i].t; x = p[i].check(x); y = p[i].check(y); &#125; ll ans=0; for (int i = 29; i &gt;= 0; i--) &#123; int k = 1 &lt;&lt; i; if ((k&amp;x) == 0&amp;&amp; (k&amp;y) == 0) continue; if ((k&amp;x) &gt; 0) ans += k; else if ((k&amp;y) &gt; 0&amp;&amp;m&gt;k) &#123; m -= k; ans += k; &#125; &#125; printf("%lld\n", ans); return 0;&#125; è¿™é‡Œ$i$å¦‚æœä»$30$å¼€å§‹ç®—,é¢å¤–æ•°æ®å°±æ˜¯é”™çš„,$29$å¼€å§‹ç®—,é¢å¤–æ•°æ®å°±èƒ½è¿‡. $emmmm$]]></content>
      <categories>
        <category>UOJç»ƒä¹ è®°å½•</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>äºŒçº§åˆ¶</tag>
      </tags>
  </entry>
</search>
