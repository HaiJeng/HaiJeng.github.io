<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>rp++</title>
    <link>https://haijeng.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>我想刷穿一个OJ</description>
    <pubDate>Mon, 26 Aug 2019 06:54:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>acm2014-I.The Queen’s Super-circular Patio</title>
      <link>https://haijeng.github.io/2019/08/13/acm2014-I/</link>
      <guid>https://haijeng.github.io/2019/08/13/acm2014-I/</guid>
      <pubDate>Tue, 13 Aug 2019 09:16:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;I-The-Queen’s-Super-circular-Patio&quot;&gt;&lt;a href=&quot;#I-The-Queen’s-Super-circular-Patio&quot; class=&quot;headerlink&quot; title=&quot;I: The Queen’s Super-cir
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="I-The-Queen’s-Super-circular-Patio"><a href="#I-The-Queen’s-Super-circular-Patio" class="headerlink" title="I: The Queen’s Super-circular Patio"></a>I: The Queen’s Super-circular Patio</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The queen wishes to build a patio paved with of a circular center stone surrounded by circular rings of circular stones. All the stones in a ring will be the same size with the same number of stones in each ring. The stones in the innermost ring will be placed touching (tangent to) the adjacent stones in the ring and the central stone. The stones in the other rings will touch the two adjacent stones in the next inner ring and their neighbors in the same ring. The figures below depict a patio with one ring of three stones and a patio with $5$ rings of $11$ stones. The patio is to be surrounded by a fence that goes around the outermost stones and straight between them (the heavier line in the figures).<br><img src="https://i.loli.net/2019/08/13/p1ZoRkhv3g4q8Js.png" alt="1.png"><br>The queen does not yet know how many stones there will be in each circle nor how many circles of stones there will be. To be prepared for whatever she decides, write a program to calculate the sizes of the stones in each circle and the length of the surrounding fence. The radius of the central stone is to be one queenly foot.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>The first line of input contains a single integer $P$, ($1 ≤ P ≤ 1000$), which is the number of data sets that follow. Each data set should be processed identically and independently.<br>Each data set consists of a single line of input. It contains the data set number, $K$, the number, $N$ ($3 ≤ N ≤ 20$), of stsones in each circle and the number, $M$ ($1 ≤ M ≤ 15$), of circles of stones around the central stone.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each data set there is a single line of output. It contains the data set number, $K$, followed by a single space which is then followed by the radius (in queenly feet) of the stones in the outermost ring (to $3$ decimal places) which is followed by a single space which is then followed by the length (in queenly feet) of the fence (to $3$ decimal places).</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>3<br>1 3 1<br>2 7 3<br>3 11 5</p><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>1 6.464 79.400<br>2 3.834 77.760<br>3 2.916 82.481</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>$t$组数据,第一个是编号,第二个是一层有几个,第三个是有几层.<br>问你最外层的圆的半径$r$和围栏长度$l$.<br>首先,最外围的围栏长度$l$必定是最外围$1$个圆的周长$+n\times 2\times$最外围圆的半径$r$.<br>那么问题变为如何求最外围圆的半径$r$.<br>对于第一个图,很明显,最外层,即第一层的半径为$\frac{\sin\theta}{(1.0 - \sin\theta)}$,这里$\theta=\frac{\pi}{n}$<br>就像这样,理解一下.<br><img src="https://i.loli.net/2019/08/13/eFuOpMBEdR9g3Wy.png" alt="2.png"><br>我们改一下图,让第二个图只有两层<br>那么问题变为如何求$r_2$.<br>我们连接两球的圆心,外切圆和外切圆的外切圆<br><img src="https://i.loli.net/2019/08/13/nGv8fPaVhHTseRN.png" alt="4.png"></p><p>由$r_1=R_1\times\sin\theta,r_2=R_2\times\sin\theta$我们可以得到一个公式:<br><img src="https://i.loli.net/2019/08/13/qu4ZM5I9Lbdca3t.png" alt="5.png"><br>一系列化简得到</p><p><img src="https://i.loli.net/2019/08/13/MeEpfnVZWm3kwqS.png" alt="6.png"></p><p>$$r_2=R_2*\sin\theta$$</p><p>之后每个$R_i=f(i-1)$递推求得.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, n, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">double</span> alpha = pi / (<span class="keyword">double</span>)n;</span><br><span class="line">        <span class="keyword">double</span> si=<span class="built_in">sin</span>(alpha),ci=<span class="built_in">cos</span>(alpha),ti=<span class="built_in">tan</span>(alpha);</span><br><span class="line">        <span class="keyword">double</span> r1 = si / (<span class="number">1.0</span> - si);</span><br><span class="line">        <span class="keyword">double</span> R1=<span class="number">1.0</span>+r1,R2,r2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            R2=R1*ci+r1*si+<span class="built_in">sqrt</span>(r1*r1+<span class="number">2</span>*r1*R1*ci*si);</span><br><span class="line">            R2=R2/(ci*ci);</span><br><span class="line"></span><br><span class="line">            r2=R2*si;</span><br><span class="line">            R1=R2;</span><br><span class="line">            r1=r2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> r=r1;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">2.0</span>*r*(pi+(<span class="keyword">double</span>)(n));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %.3f %.3f\n"</span>, opt, r, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://haijeng.github.io/2019/08/13/acm2014-I/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算几何相关知识</title>
      <link>https://haijeng.github.io/2019/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</link>
      <guid>https://haijeng.github.io/2019/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</guid>
      <pubDate>Sun, 11 Aug 2019 19:03:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;向量旋转其一&quot;&gt;&lt;a href=&quot;#向量旋转其一&quot; class=&quot;headerlink&quot; title=&quot;向量旋转其一&quot;&gt;&lt;/a&gt;向量旋转其一&lt;/h2&gt;&lt;p&gt;给定点向量$\overrightarrow{A}$,令其按起点旋转一个角度$\alpha$&lt;br&gt;问终点的位
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="向量旋转其一"><a href="#向量旋转其一" class="headerlink" title="向量旋转其一"></a>向量旋转其一</h2><p>给定点向量$\overrightarrow{A}$,令其按起点旋转一个角度$\alpha$<br>问终点的位置.<br>我们定义逆时针为正向.<br>假设,向量$\overrightarrow{A}$终点为$(x,y)$<br>旋转后为$(x’,y’)$.<br>我们可以知道,这个向量的起点为$(0,0)$,终点在$r=\sqrt{x^2+y^2}$为半径得圆上.<br>那么,根据$x=r\cdot cosβ,y=r\cdot sinβ$<br>则旋转后的$x’=r\cdot cos(α+β)$,$y’=r\cdot sin(α+β)$<br>拆开后:<br>$x’=r\cdot cosα\cdot cosβ-r\cdot sinα\cdot sinβ$<br>$y’=r\cdot sinα\cdot cosβ+r\cdot cosα\cdot sinβ$<br>再将$x$和$y$回代得:<br>$x’=cosα\cdot x-sinα\cdot y$<br>$y’=sinα\cdot x+cosα\cdot y$</p>]]></content:encoded>
      
      <comments>https://haijeng.github.io/2019/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>凸包的几种求法</title>
      <link>https://haijeng.github.io/2019/08/10/%E5%87%B8%E5%8C%85/</link>
      <guid>https://haijeng.github.io/2019/08/10/%E5%87%B8%E5%8C%85/</guid>
      <pubDate>Sat, 10 Aug 2019 15:37:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;凸包&quot;&gt;&lt;a href=&quot;#凸包&quot; class=&quot;headerlink&quot; title=&quot;凸包&quot;&gt;&lt;/a&gt;凸包&lt;/h
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><blockquote><p>不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。</p></blockquote><p>列如下图:用红色的直线,将黑色的点包裹起来.<br><img src="https://i.loli.net/2019/08/12/3BitWpxf8zhgADZ.png" alt="1.png"></p><h3 id="向量旋转"><a href="#向量旋转" class="headerlink" title="向量旋转"></a>向量旋转</h3><p>定义两个同一起点的向量:<br>分别为向量$\overrightarrow{ab}$和向量$\overrightarrow{ac}$<br><img src="https://i.loli.net/2019/08/12/H7dmyKTBRvlCoFx.png" alt="2.png"><br>定义向量旋转,$\overrightarrow{ab}$旋转为$\overrightarrow{ac}$为右旋,即顺时针旋转.<br>$\overrightarrow{ac}$旋转为$\overrightarrow{ab}$为左旋,即逆时针旋转.<br><strong>如何计算:</strong></p><ul><li>判断向量$\overrightarrow{ab}.x*\overrightarrow{ac}.y-\overrightarrow{ab}.y*\overrightarrow{ac}.x$的值.</li><li>若为正,则为$\overrightarrow{ab}$右旋变为$\overrightarrow{ac}$.</li><li>若为负,则为$\overrightarrow{ab}$左旋变为$\overrightarrow{ac}$.</li><li>若为$0$,则为共线.</li></ul><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="前篇"><a href="#前篇" class="headerlink" title="前篇"></a>前篇</h3><p>我们知道,一个凸包,它要包含所有点集中的点.<br>那么如图:<br><img src="https://i.loli.net/2019/08/12/SpX5GoeyDuUNnWK.png" alt="4.png"><br>为了符合凸包定义,只有$1,2,3,4$四点时,我们的凸包如图所示(在这里,我们假设所有的点按照$x$从小到大给出)<br>那么,对于第$5$个点,我们应该怎么处理呢?<br><img src="https://i.loli.net/2019/08/12/RpfvrCs8mDI35kl.png" alt="5.png"></p><ol><li>边$2\rightarrow4$应该断开,然后将$2\rightarrow5$连接</li><li>再将$3\rightarrow4$断开.然后将$3\rightarrow5$连接<br>变成这样:<br><img src="https://i.loli.net/2019/08/12/bO2wZ6Lsi8y7QkH.png" alt="6.png"><br>我们可以简单把这个凸包划分为上半部分和下半部分.</li></ol><ul><li>对于上半部分的$1,2,4,5$<ul><li>为什么断开$2\rightarrow4$而连接$2\rightarrow5$?</li><li>因为$4$在$2\rightarrow5$的内侧?</li><li>这是一个原因,但本质是<ul><li><strong>向量$\overrightarrow{2\rightarrow4}$是需要左旋才能成为$\overrightarrow{2\rightarrow5}$</strong></li></ul></li></ul></li><li>同理可以得到,对于$3\rightarrow4$变$3\rightarrow5$<ul><li><strong>向量$\overrightarrow{3\rightarrow4}$是需要右旋才能成为$\overrightarrow{3\rightarrow5}$</strong></li></ul></li></ul><h3 id="中篇"><a href="#中篇" class="headerlink" title="中篇"></a>中篇</h3><p>由上面得到的这条性质.<br>我们能做什么?</p><ul><li>在离线,所给的点集无序时,我们有了$O(n\log{n})$的算法.</li><li>当所给的点集是有序时,我们有$O(n)$的算法.</li></ul><h3 id="后篇"><a href="#后篇" class="headerlink" title="后篇"></a>后篇</h3><p>我们分为两种类型进行讨论.</p><h4 id="有序的且符合简单多边形的点集"><a href="#有序的且符合简单多边形的点集" class="headerlink" title="有序的且符合简单多边形的点集"></a>有序的且符合简单多边形的点集</h4><ul><li><p>什么是简单多边形?</p><ul><li>顶点与顶点不重合。</li><li>顶点不在边上。</li><li>边与边不相交的多边形。</li></ul></li><li><p>有序是什么?</p><ul><li>按照$X$,$Y$坐标排序的有序</li><li>按照逆时针或顺时针给出的有序,当然也阔以称之为极角排序的有序.</li></ul></li><li><p>首先先看第一种排序,按照逆时针或顺时针给出的有序,(极角排序的有序).</p><ul><li><p><strong>当仁不让$Graham$算法</strong></p><ul><li>算法思路:<ul><li>1.栈名$q$,栈尾指针$tail$,初始化在栈中加入最左下角的点,和第二个点</li><li>2.假设即将加入的点$c$</li><li>3.判断向量$\overrightarrow{q_{tail-1}q_{tail}}$和向量$\overrightarrow{q_{tail-1}c}$的旋转关系.<ul><li>1).如果是$\overrightarrow{q_{tail-1}q_{tail}}$右旋变为$\overrightarrow{q_{tail-1}c}$,将栈顶元素$q_{tail}$弹出,进行步骤$3$,直到进行步骤$2)$不成立或栈内只剩$2$个元素.</li><li>2).如果是$\overrightarrow{q_{tail-1}q_{tail}}$左旋变为$\overrightarrow{q_{tail-1}c}$,将$c$压入栈,回到步骤$2$.</li></ul></li></ul></li><li>如果发现三点共线的情况，算法可以考虑将其视为左转或者右转。这取决于究竟只是要求凸包的边界，还是要找到在凸包边界上所有的点。</li><li>示意图:<img src="https://i.loli.net/2019/08/12/OE27JzWA6MYadQg.png" alt="8.png"></li></ul></li><li><p><strong>被大家吹的很厉害的$Melkman$算法</strong></p><ul><li><p>援引一下$Melkman$在论文中说的:</p></li><li><blockquote><p>It is the purpose of this short article to show that a slightly modified version of their algorithm constructs, on-line, the convex hull of any simple polyline in $O(n)$ time.</p></blockquote></li><li><p>在论文中,$Melkman$使用的是:顺时针.</p></li><li><p>当然,逆时针也阔以.</p></li><li><p>算法思路:</p><ul><li>根据简单多边形的性质,我们知道边和边是不相交的.</li><li>1.确立一条边,使其他所有的点都在这条边的一侧</li><li>2.在一个双端队列的队尾放入边的两点,</li><li>3.再在队列头和尾都放入第三个点.</li><li>4.依次读入每一个点$p$,并与$q_{tail},q_{tail-1},q_{head},q_{head+1}$比较.<ul><li>1).如果是$\overrightarrow{q_{tail-1}q_{tail}}$右旋变为$\overrightarrow{q_{tail-1}p}$,将队尾元素$q_{tail}$弹出,进行步骤$4$,直到进行步骤$1)$不成立或栈内只剩$3$个元素.</li><li>2).如果是$\overrightarrow{q_{tail-1}q_{tail}}$左旋变为$\overrightarrow{q_{tail-1}c}$,将$c$压入队尾,回到步骤$3$.</li><li>3).如果是$\overrightarrow{q_{head+1}q_{head}}$右旋变为$\overrightarrow{q_{head+1}p}$,将队首元素$q_{head}$弹出,进行步骤$4$,直到进行步骤$3)$不成立或队内只剩$3$个元素.</li><li>4).如果是$\overrightarrow{q_{head+1}q_{head}}$左旋变为$\overrightarrow{q_{head+1}p}$,将$p$压入队尾,回到步骤$3$.</li></ul></li></ul></li><li><p><img src="https://i.loli.net/2019/08/12/V3Ap1XEbxsMYJyi.gif" alt="9.gif"></p></li><li><p>我们来进一步理解这个算法</p><ul><li>看图<img src="https://i.loli.net/2019/08/12/LTC9qvoOfEl7Imh.png" alt="11.png"></li><li>因为所给的点是有序的,那么点只能落在$I,II,III$这三个位置.<ul><li>在这里,我们的$q[head]$和$q[tail]$都是$3$.</li><li>加入点$4$便判断,在$I$,那么$head++$,然后压入$4$</li><li>若在$III$,那么$tail–$,压入$4$.</li><li>若在$II$,则$head++,tail–$,再分别压入$4$.</li><li>重复上述步骤,直到所有点遍历结束.</li></ul></li></ul></li></ul></li></ul></li><li><p>对于数据是按$x$从小到大,$x$相等时$y$从小到大的排列的点集</p><ul><li><strong>升级版的$Graham$算法:$Andrew$算法</strong><ul><li>当使用极角排序时的精度丢失又是一个折磨人的事情.</li><li>对于$Graham$算法,对于判断三点共线时有可能出现错误:<img src="https://i.loli.net/2019/08/12/bhfEeDyGActY2rN.png" alt="7.png"></li><li>算法思路:<ul><li>我们结合$Graham$来看.</li><li>在$Andrew$算法中,数据要按照$x$坐标来排列.</li><li>之后,先从点$1$扫到$n$,按照$Gramham$的处理,得到上凸包</li><li>再从$n$扫到$1$,得到下凸包,结束.</li></ul></li><li><img src="https://i.loli.net/2019/08/12/KbRWQIzTlF37uda.gif" alt="10.gif"></li></ul></li></ul></li></ul><h4 id="无序的点集"><a href="#无序的点集" class="headerlink" title="无序的点集"></a>无序的点集</h4><p>其实理解了上面有序的点集如何求解,无序的点集也就非常明了了.<br>对于:$Graham$算法和$Melkman$算法,我们需要按照极角排序.<br>对于:$Andrew$算法,我们要按照$x$从小到大的顺序排列.<br>也就是说,目前,据我所知,对于无序的点集,我们都需要$O(n\log n)$的时间寻找凸包.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Graham-算法"><a href="#Graham-算法" class="headerlink" title="$Graham$算法"></a>$Graham$算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(vec A, vec B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x * B.y - A.y * B.x; <span class="comment">// 正为A-&gt;B左旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">side</span><span class="params">(vec a, vec b, vec p)</span> <span class="comment">// 祖父点a,父点b,新增儿子点p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec A = vec(b.x - a.x, b.y - a.y); <span class="comment">// 向量ab</span></span><br><span class="line">    vec B = vec(p.x - a.x, p.y - a.y); <span class="comment">// 向量ap</span></span><br><span class="line">    <span class="keyword">return</span> Cross(A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graham</span><span class="params">(<span class="keyword">int</span>&amp; tail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (p[i].y &lt; p[zz].y || (p[i].y == p[zz].y &amp;&amp; p[zz].x &gt; p[i].x))</span><br><span class="line">            zz = i;</span><br><span class="line">    swap(p[<span class="number">0</span>], p[zz]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p[i] = p[i] - p[<span class="number">0</span>];</span><br><span class="line">        p[i].p = <span class="built_in">atan2</span>(p[i].y, p[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>].x = p[<span class="number">0</span>].y = <span class="number">0</span>;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + n);</span><br><span class="line"></span><br><span class="line">    q[<span class="number">0</span>] = p[<span class="number">0</span>];</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail&gt;<span class="number">0</span> &amp;&amp; side(q[tail - <span class="number">1</span>], q[tail], p[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            tail--;</span><br><span class="line">        q[++tail] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Andrew-算法"><a href="#Andrew-算法" class="headerlink" title="$Andrew$算法"></a>$Andrew$算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(vec A, vec B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x * B.y - A.y * B.x; <span class="comment">//正为A-&gt;B左旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">side</span><span class="params">(vec a, vec b, vec p)</span> <span class="comment">//祖父点a,父点b,新增儿子点p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec A = vec(b.x - a.x, b.y - a.y, <span class="number">0</span>); <span class="comment">//向量ab</span></span><br><span class="line">    vec B = vec(p.x - a.x, p.y - a.y, <span class="number">0</span>); <span class="comment">//向量ap</span></span><br><span class="line">    <span class="keyword">return</span> Cross(A, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span>&amp; tail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(p, p + n);</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">0</span> &amp;&amp; side(q[tail - <span class="number">1</span>], q[tail], p[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            tail--;</span><br><span class="line">        q[++tail] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic = tail;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; basic &amp;&amp; side(q[tail - <span class="number">1</span>], q[tail], p[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            tail--;</span><br><span class="line">        q[++tail] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://haijeng.github.io/2019/08/10/%E5%87%B8%E5%8C%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>前向星</title>
      <link>https://haijeng.github.io/2019/08/09/%E5%89%8D%E5%90%91%E6%98%9F/</link>
      <guid>https://haijeng.github.io/2019/08/09/%E5%89%8D%E5%90%91%E6%98%9F/</guid>
      <pubDate>Fri, 09 Aug 2019 15:54:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;font color=&quot;blue&quot;&gt;欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-基本概念&quot;&gt;&lt;a href=&quot;#一-基本概念&quot; class=&quot;headerlink&quot; title=&quot;一.基本概念&quot;&gt;&lt;/a&gt;一.基本概念&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><font color="blue">欢迎各大佬，大牛对本文指正，也希望本文能对各位有所帮助</font></p><h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h2><p>&emsp;&emsp;前向星是什么??<br>&emsp;&emsp;前向星是一个边集数组.<del>啥玩意啊,拽什么专业词汇啊</del>.也就是说,与邻接矩阵相比,前向星更像是用vector储存的邻接链表,是储存边的数组.<br>&emsp;&emsp;这个数组储存的是图里的每一条边.(下面上图)<br>&emsp;&emsp;下面是一组图的数据<br>&emsp;&emsp;$4$个顶点,$6$条边,起点,终点,这条边的长度<br>4 6<br>1 2 2<br>2 3 2<br>2 4 1<br>1 3 5<br>3 4 3<br>1 4 4</p><p><img src="https://img-blog.csdnimg.cn/20181217195435354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VuS2Zyb3plbg==,size_16,color_FFFFFF,t_70" alt="1"></p><p>&emsp;&emsp;前向星储存什么呢,存的是</p><table>    <tr>        <th>第i条边</th><th> 起点 </th><th> 终点 </th><th>长度</th>    </tr>    <tr>        <td> 1 </td><td> 1 </td><td> 2 </td><td> 2 </td>    </tr>    <tr>        <td> 2 </td><td> 2 </td><td> 3 </td><td> 2 </td>    </tr>    <tr>        <td> 3 </td><td> 2 </td><td> 4 </td><td> 1 </td>    </tr>    <tr>        <td> 4 </td><td> 1 </td><td> 3 </td><td> 5 </td>    </tr>    <tr>        <td> 5 </td><td> 3 </td><td> 4 </td><td> 3 </td>    </tr>    <tr>        <td> 6 </td><td> 1 </td><td> 4 </td><td> 4 </td>    </tr></table><h2 id="二-代码实现"><a href="#二-代码实现" class="headerlink" title="二.代码实现"></a>二.代码实现</h2><p>&emsp;&emsp;看了一下存储方式是不是感觉so~~easy,确实如此.<br>&emsp;&emsp;但是依然改变不了这是一个很优秀的数据结构(雾)</p><h3 id="1-核心代码"><a href="#1-核心代码" class="headerlink" title="1.核心代码"></a>1.核心代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> star, end, cost;</span><br><span class="line">&#125;p[<span class="number">100000</span>];</span><br></pre></td></tr></table></figure><h3 id="2-保存和输出"><a href="#2-保存和输出" class="headerlink" title="2.保存和输出"></a>2.保存和输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(edge a, edge b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.star &lt; b.star;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i].star &gt;&gt; p[i].end&gt;&gt;p[i].cost;</span><br><span class="line">    sort(p, p + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,p[i].star,p[i].end,p[i].cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当一个巨大的图却只有几个边的时候,这种保存方式的优势就大大的体现了出来.但是储存后需要按照起点排序.才能进行搜索或者求最短路.<br>&emsp;&emsp;于是复杂度就要加上了排序的耗时.</p><h2 id="三-优化–链式前向星"><a href="#三-优化–链式前向星" class="headerlink" title="三.优化–链式前向星"></a>三.优化–链式前向星</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>&emsp;&emsp;没错,就是优化,让我们来考虑如何去掉这个鬼畜的排序$呢^呢$??<br>&emsp;&emsp;只需要稍微改变一点点储存方式,再加入一个next就可以了.于是就像是从一个点发出去的链子一样.所以称为链式前向星(雾).<br>&emsp;&emsp;怎么弄呢?<br>&emsp;&emsp;$head[i]$保存的是第i个点的始边的位置,edge保存的是第i点的一条边的终点与长度,以及第i个点的下一条边的位置.分别用$end$,$cost$,$next$表示.<br>&emsp;&emsp;于是就这样子了<br>&emsp;&emsp;还是这个数据,会变成什么样子呢??</p><table>    <tr>        <th>第i条边</th><th> 起点 </th><th> 终点 </th><th>长度</th>    </tr>    <tr>        <td> 1 </td><td> 1 </td><td> 2 </td><td> 2 </td>    </tr>    <tr>        <td> 2 </td><td> 2 </td><td> 3 </td><td> 2 </td>    </tr>    <tr>        <td> 3 </td><td> 2 </td><td> 4 </td><td> 1 </td>    </tr>    <tr>        <td> 4 </td><td> 1 </td><td> 3 </td><td> 5 </td>    </tr>    <tr>        <td> 5 </td><td> 3 </td><td> 4 </td><td> 3 </td>    </tr>    <tr>        <td> 6 </td><td> 1 </td><td> 4 </td><td> 4 </td>    </tr></table>&emsp;&emsp;使$next=0$表示木有出边<img src="https://img-blog.csdnimg.cn/20181217203838598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VuS2Zyb3plbg==,size_16,color_FFFFFF,t_70" width="100%">为什么边序号是倒着的??(这里先卖个关子,后面会说)<h3 id="2-代码实现-边的储存以及输出"><a href="#2-代码实现-边的储存以及输出" class="headerlink" title="2.代码实现(边的储存以及输出)"></a>2.代码实现(边的储存以及输出)</h3><h4 id="1-数组实现"><a href="#1-数组实现" class="headerlink" title="(1).数组实现"></a>(1).数组实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> end, cost,next;</span><br><span class="line">&#125;p[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s,e, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; e &gt;&gt; c;</span><br><span class="line">        p[i].end = e, p[i].cost = c;</span><br><span class="line">        p[i].next=head[s];</span><br><span class="line">        head[s] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = head[i];</span><br><span class="line">        <span class="keyword">while</span> (f) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, p[f].end, p[f].cost);</span><br><span class="line">            f = p[f].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为什么边的位置是倒着的,木措,就是因为这两行,保存方式为下图演示.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[i].next=head[s];</span><br><span class="line">head[s] = i;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;让$head[i]$储存输入的边的位置,再让这条边的指向变为$head[i]$储存的位置.那么就意味着,越晚输入的边,它越靠近$head[i]$.<br><img src="https://img-blog.csdnimg.cn/20181218123946874.gif" alt="杂色不知道为什么"></p><h4 id="2-指针实现"><a href="#2-指针实现" class="headerlink" title="(2).指针实现"></a>(2).指针实现</h4><p>&emsp;&emsp;作为一个忠于指针写数据结构的人,怎么可能不用指针写一下这个家伙呢(雾).<br>&emsp;&emsp;看懂上面的,这个应该没什么问题吧(逃)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>* <span class="title">nd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> end, cost;</span><br><span class="line">    nd next;</span><br><span class="line">&#125;;</span><br><span class="line">nd head[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nd p = head[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            nd f = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(p);  <span class="comment">//free(p);</span></span><br><span class="line">            p = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s, e, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; e &gt;&gt; c;</span><br><span class="line">        nd p = <span class="keyword">new</span>(edge);    <span class="comment">//nd p=(nd) malloc(sizeof(edge));</span></span><br><span class="line">        p-&gt;end = e, p-&gt;cost = c;</span><br><span class="line">        p-&gt;next = head[s];</span><br><span class="line">        head[s] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nd f = head[i];</span><br><span class="line">        <span class="keyword">while</span> (f!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, f-&gt;end, f-&gt;cost);</span><br><span class="line">            f = f-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://haijeng.github.io/2019/08/09/%E5%89%8D%E5%90%91%E6%98%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>线性基</title>
      <link>https://haijeng.github.io/2019/08/09/%E7%BA%BF%E6%80%A7%E5%9F%BA/</link>
      <guid>https://haijeng.github.io/2019/08/09/%E7%BA%BF%E6%80%A7%E5%9F%BA/</guid>
      <pubDate>Fri, 09 Aug 2019 15:48:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;del&gt;即使线性代数课结束,依然逃不过线性代数&lt;/del&gt;&lt;br&gt;线性基,类似于线代里面的矩阵求最大线性无关组.&lt;br&gt;看一下大佬的说法:
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><del>即使线性代数课结束,依然逃不过线性代数</del><br>线性基,类似于线代里面的矩阵求最大线性无关组.<br>看一下大佬的说法:锵锵,传送门<a href="https://www.cnblogs.com/vb4896/p/6149022.html" target="_blank" rel="noopener">%%%%</a></p><blockquote><p>首先来看一个问题： 给出N个数,要从中选出一个最大的子集,使得子集中的任意个元素异或值不为0.<br>这个和极大线性无关组有些类似。异或可以看出是模2域下的加法运算,如果把一个数转化为二进制,对应成一个由01构成的向量,<br>所有这些向量就构成了一个线性空间。 原问题就转化为求这个向量组的极大线性无关组,把这样一个极大线性无关组成为线性基。<br>可以用$O(60*60*n)$的高斯消元来解决。 但是还有更加快速的构造线性基的方法： 复杂度是$O(60*n)$</p></blockquote><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&emsp;&emsp;可以这么看,我们有n多个数.这些数x相互xor(异或)得到的一些数y,我们称y是他们x的值域.但是n多个数可能都太大,不好维护或者储存.于是我们想用尽量小的数,假使有k个比较小的数,相互xor同样能求出值域y.而这些k个数,我们就称之为线性基.<br>又有xor是在(0,1)为基底的空间里的运算.所以我们要把n多个数,解成二进制.举个栗子:<br>我们有集合{x}={2,9,10,17}他们相互异或可以得到值域{y}.但是这4个数,太大了<del>夸张一下</del>.我们就要想办法缩小x得到集合{k}.<br><img src="https://img-blog.csdnimg.cn/20190123135437550.png" alt="1"><br>于是,我们把这四个数写成矩阵,就成了矩阵A.<br><img src="https://img-blog.csdnimg.cn/20190123135810942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VuS2Zyb3plbg==,size_16,color_FFFFFF,t_70" alt="2"><br>.我们考虑把这个变成上三角形,那么可以r3-r2+r4,然后r3和r4互换.<br>就可以得到一个行阶梯型的矩阵.<br>于是集合{x}-&gt;{k}={1,2,10,17}.嗯,没错,{k}就是我们要求得的线性基.<del>当然,我们也可以处理掉10,保留9</del><br><img src="https://img-blog.csdnimg.cn/20190123141111674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1VuS2Zyb3plbg==,size_16,color_FFFFFF,t_70" alt="3"><br>如果计算一下的话,会发现,得到的值域{y}是相同的.于是,我们就可以称{k}为线性基.</p><h2 id="求解线性筛"><a href="#求解线性筛" class="headerlink" title="求解线性筛"></a>求解线性筛</h2><p>由图3,很明显我们知道了一个求线性基的方法,是高斯消元.但是太麻烦,繁琐,耗时.常用的是另一种.<br>一句话介绍就是:</p><blockquote><p>将x转换为二进制,从高位向低位扫,如果第一个1是第p位,如果$k_p=0$,就令$k_p=x$;如果$k_p!=0$,就令$x$XOR$k_p$后,重复上述阶段.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = Bit ; i &gt;= <span class="number">0</span> ; i-- )   <span class="comment">//Bit是二进制的位数,常见题目大多为62.</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> &lt;&lt; i &amp; Num )</span><br><span class="line">        <span class="keyword">if</span>( !Base[i] ) &#123;</span><br><span class="line">            Base[i] = Num ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Num ^= Base[i] ;</span><br></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="一-查询最值"><a href="#一-查询最值" class="headerlink" title="一.查询最值"></a>一.查询最值</h3><p>贪心,从高位向低位贪心,可知,从高到底,后面的无法改变高位,只要高位变为最大的即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    ans = max(ans, ans^p[i]);</span><br></pre></td></tr></table></figure><h3 id="二-查询最小值"><a href="#二-查询最小值" class="headerlink" title="二.查询最小值"></a>二.查询最小值</h3><p>贪心,从高位向低位贪心,可知,从高到底,后面的无法改变高位,只要高位变为最小的即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    ans = min(ans, ans^p[i]);</span><br></pre></td></tr></table></figure><h2 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h2><h3 id="一-P3812-【模板】线性基"><a href="#一-P3812-【模板】线性基" class="headerlink" title="一.P3812 【模板】线性基"></a>一.<a href="https://www.luogu.org/problemnew/show/P3812" target="_blank" rel="noopener">P3812 【模板】线性基</a></h3><p>这是一道模板题。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p><strong>输入格式:</strong><br>第一行一个数n，表示元素个数<br>接下来一行n个数<br><strong>输出格式：</strong><br>仅一行，表示答案。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>输入样例#1:</strong><br>2<br>1 1<br><strong>输出样例#1:</strong><br>1</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>$1≤n≤50,0≤S_i≤2^{50}$</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>模板题目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn], p[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">62</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; j &amp; a[i])</span><br><span class="line">                <span class="keyword">if</span> (!p[j]) &#123;</span><br><span class="line">                    p[j] = a[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    a[i] ^= p[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        ans = max(ans, ans^p[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-小a与星际探索"><a href="#二-小a与星际探索" class="headerlink" title="二.小a与星际探索"></a>二.小a与星际探索</h3><pre><code>链接：https://ac.nowcoder.com/acm/contest/317/C来源：牛客网</code></pre><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>&emsp;&emsp;小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数p。星球i能到达星球j当且仅当$p_i&gt;p_j$。<br>&emsp;&emsp;同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为$t$⊕$p_j$(即$t$异或$p_j$，关于其定义请自行百度)<br>&emsp;&emsp;小a想知道到达n号星球时耐久度最大为多少.<br>注意：对于每个位置来说，从它出发可以到达的位置仅与两者的p有关，与下标无关</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><p>&emsp;&emsp;第一行一个整数n，表示星球数<br>&emsp;&emsp;接下来一行有n个整数，第i个整数表示pi</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><p>&emsp;&emsp;一个整数表示到达n号星球时最大的耐久度<br>&emsp;&emsp;若不能到达n号星球或到达时的最大耐久度为0则输出−1</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>输入</strong><br>3<br>457 456 23<br><strong>输出</strong><br>478<br><strong>说明</strong><br>&emsp;&emsp;小a有两种方法到达3号星球<br>&emsp;&emsp;第一种：1→2→3，最终耐久度为457⊕456⊕23=22<br>&emsp;&emsp;第二种：1→3，最终耐久度为457⊕23=478<br><strong>输入</strong><br>4<br>2 4 4 2<br><strong>输出</strong><br>-1<br><strong>输入</strong><br>5<br>234 233 123 2333 23<br><strong>输出</strong><br>253<br><strong>备注:1⩽n,∀pi⩽3000</strong></p><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;求从$p_1$到$p_n$的异或和最大值,套板子….然后注意的是$p_i$到$p_j$的话需要$p_i&gt;p_j$.所以不符合的数直接扔掉就可以了.<br>&emsp;&emsp;最后再判断一下$p_1$和$p_n$之间的大小关系就好了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">12</span>; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; j &amp; p[i]&amp;&amp;p[<span class="number">0</span>]&gt;p[i]&amp;&amp;p[i]&gt;p[n])</span><br><span class="line">                <span class="keyword">if</span> (!a[j]) &#123;</span><br><span class="line">                    a[j] = p[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p[i] ^= a[j];</span><br><span class="line">    <span class="keyword">int</span> ans = p[<span class="number">0</span>] ^ p[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">12</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        ans = max(ans, ans^a[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (p[<span class="number">0</span>]&gt;p[n<span class="number">-1</span>]?ans:<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://haijeng.github.io/2019/08/09/%E7%BA%BF%E6%80%A7%E5%9F%BA/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
